var s4 = Object.defineProperty
var o4 = (e, t, n) =>
  t in e ? s4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n)
var zn = (e, t, n) => (o4(e, typeof t != 'symbol' ? t + '' : t, n), n),
  xg = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  }
var M = (e, t, n) => (xg(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  De = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  ve = (e, t, n, r) => (xg(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n)
var ud = (e, t, n, r) => ({
    set _(i) {
      ve(e, t, i, n)
    },
    get _() {
      return M(e, t, r)
    },
  }),
  nt = (e, t, n) => (xg(e, t, 'access private method'), n)
function EC(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n]
    if (typeof r != 'string' && !Array.isArray(r)) {
      for (const i in r)
        if (i !== 'default' && !(i in e)) {
          const s = Object.getOwnPropertyDescriptor(r, i)
          s && Object.defineProperty(e, i, s.get ? s : { enumerable: !0, get: () => r[i] })
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }))
}
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i)
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === 'childList')
        for (const o of s.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && r(o)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(i) {
    const s = {}
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === 'use-credentials'
        ? (s.credentials = 'include')
        : i.crossOrigin === 'anonymous'
        ? (s.credentials = 'omit')
        : (s.credentials = 'same-origin'),
      s
    )
  }
  function r(i) {
    if (i.ep) return
    i.ep = !0
    const s = n(i)
    fetch(i.href, s)
  }
})()
function Ic(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
}
function a4(e) {
  if (e.__esModule) return e
  var t = e.default
  if (typeof t == 'function') {
    var n = function r() {
      return this instanceof r
        ? Reflect.construct(t, arguments, this.constructor)
        : t.apply(this, arguments)
    }
    n.prototype = t.prototype
  } else n = {}
  return (
    Object.defineProperty(n, '__esModule', { value: !0 }),
    Object.keys(e).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(e, r)
      Object.defineProperty(
        n,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return e[r]
              },
            }
      )
    }),
    n
  )
}
var CC = { exports: {} },
  y0 = {},
  _C = { exports: {} },
  ct = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Hf = Symbol.for('react.element'),
  l4 = Symbol.for('react.portal'),
  c4 = Symbol.for('react.fragment'),
  u4 = Symbol.for('react.strict_mode'),
  f4 = Symbol.for('react.profiler'),
  d4 = Symbol.for('react.provider'),
  h4 = Symbol.for('react.context'),
  p4 = Symbol.for('react.forward_ref'),
  g4 = Symbol.for('react.suspense'),
  m4 = Symbol.for('react.memo'),
  y4 = Symbol.for('react.lazy'),
  zb = Symbol.iterator
function v4(e) {
  return e === null || typeof e != 'object'
    ? null
    : ((e = (zb && e[zb]) || e['@@iterator']), typeof e == 'function' ? e : null)
}
var OC = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  kC = Object.assign,
  TC = {}
function Dc(e, t, n) {
  ;(this.props = e), (this.context = t), (this.refs = TC), (this.updater = n || OC)
}
Dc.prototype.isReactComponent = {}
Dc.prototype.setState = function (e, t) {
  if (typeof e != 'object' && typeof e != 'function' && e != null)
    throw Error(
      'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
    )
  this.updater.enqueueSetState(this, e, t, 'setState')
}
Dc.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, 'forceUpdate')
}
function AC() {}
AC.prototype = Dc.prototype
function w1(e, t, n) {
  ;(this.props = e), (this.context = t), (this.refs = TC), (this.updater = n || OC)
}
var b1 = (w1.prototype = new AC())
b1.constructor = w1
kC(b1, Dc.prototype)
b1.isPureReactComponent = !0
var Wb = Array.isArray,
  RC = Object.prototype.hasOwnProperty,
  x1 = { current: null },
  PC = { key: !0, ref: !0, __self: !0, __source: !0 }
function IC(e, t, n) {
  var r,
    i = {},
    s = null,
    o = null
  if (t != null)
    for (r in (t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (s = '' + t.key), t))
      RC.call(t, r) && !PC.hasOwnProperty(r) && (i[r] = t[r])
  var a = arguments.length - 2
  if (a === 1) i.children = n
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2]
    i.children = l
  }
  if (e && e.defaultProps) for (r in ((a = e.defaultProps), a)) i[r] === void 0 && (i[r] = a[r])
  return { $$typeof: Hf, type: e, key: s, ref: o, props: i, _owner: x1.current }
}
function w4(e, t) {
  return { $$typeof: Hf, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner }
}
function S1(e) {
  return typeof e == 'object' && e !== null && e.$$typeof === Hf
}
function b4(e) {
  var t = { '=': '=0', ':': '=2' }
  return (
    '$' +
    e.replace(/[=:]/g, function (n) {
      return t[n]
    })
  )
}
var Vb = /\/+/g
function Sg(e, t) {
  return typeof e == 'object' && e !== null && e.key != null ? b4('' + e.key) : t.toString(36)
}
function sh(e, t, n, r, i) {
  var s = typeof e
  ;(s === 'undefined' || s === 'boolean') && (e = null)
  var o = !1
  if (e === null) o = !0
  else
    switch (s) {
      case 'string':
      case 'number':
        o = !0
        break
      case 'object':
        switch (e.$$typeof) {
          case Hf:
          case l4:
            o = !0
        }
    }
  if (o)
    return (
      (o = e),
      (i = i(o)),
      (e = r === '' ? '.' + Sg(o, 0) : r),
      Wb(i)
        ? ((n = ''),
          e != null && (n = e.replace(Vb, '$&/') + '/'),
          sh(i, t, n, '', function (c) {
            return c
          }))
        : i != null &&
          (S1(i) &&
            (i = w4(
              i,
              n +
                (!i.key || (o && o.key === i.key) ? '' : ('' + i.key).replace(Vb, '$&/') + '/') +
                e
            )),
          t.push(i)),
      1
    )
  if (((o = 0), (r = r === '' ? '.' : r + ':'), Wb(e)))
    for (var a = 0; a < e.length; a++) {
      s = e[a]
      var l = r + Sg(s, a)
      o += sh(s, t, n, l, i)
    }
  else if (((l = v4(e)), typeof l == 'function'))
    for (e = l.call(e), a = 0; !(s = e.next()).done; )
      (s = s.value), (l = r + Sg(s, a++)), (o += sh(s, t, n, l, i))
  else if (s === 'object')
    throw (
      ((t = String(e)),
      Error(
        'Objects are not valid as a React child (found: ' +
          (t === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : t) +
          '). If you meant to render a collection of children, use an array instead.'
      ))
    )
  return o
}
function fd(e, t, n) {
  if (e == null) return e
  var r = [],
    i = 0
  return (
    sh(e, r, '', '', function (s) {
      return t.call(n, s, i++)
    }),
    r
  )
}
function x4(e) {
  if (e._status === -1) {
    var t = e._result
    ;(t = t()),
      t.then(
        function (n) {
          ;(e._status === 0 || e._status === -1) && ((e._status = 1), (e._result = n))
        },
        function (n) {
          ;(e._status === 0 || e._status === -1) && ((e._status = 2), (e._result = n))
        }
      ),
      e._status === -1 && ((e._status = 0), (e._result = t))
  }
  if (e._status === 1) return e._result.default
  throw e._result
}
var Xn = { current: null },
  oh = { transition: null },
  S4 = { ReactCurrentDispatcher: Xn, ReactCurrentBatchConfig: oh, ReactCurrentOwner: x1 }
ct.Children = {
  map: fd,
  forEach: function (e, t, n) {
    fd(
      e,
      function () {
        t.apply(this, arguments)
      },
      n
    )
  },
  count: function (e) {
    var t = 0
    return (
      fd(e, function () {
        t++
      }),
      t
    )
  },
  toArray: function (e) {
    return (
      fd(e, function (t) {
        return t
      }) || []
    )
  },
  only: function (e) {
    if (!S1(e)) throw Error('React.Children.only expected to receive a single React element child.')
    return e
  },
}
ct.Component = Dc
ct.Fragment = c4
ct.Profiler = f4
ct.PureComponent = w1
ct.StrictMode = u4
ct.Suspense = g4
ct.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = S4
ct.cloneElement = function (e, t, n) {
  if (e == null)
    throw Error(
      'React.cloneElement(...): The argument must be a React element, but you passed ' + e + '.'
    )
  var r = kC({}, e.props),
    i = e.key,
    s = e.ref,
    o = e._owner
  if (t != null) {
    if (
      (t.ref !== void 0 && ((s = t.ref), (o = x1.current)),
      t.key !== void 0 && (i = '' + t.key),
      e.type && e.type.defaultProps)
    )
      var a = e.type.defaultProps
    for (l in t)
      RC.call(t, l) &&
        !PC.hasOwnProperty(l) &&
        (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l])
  }
  var l = arguments.length - 2
  if (l === 1) r.children = n
  else if (1 < l) {
    a = Array(l)
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2]
    r.children = a
  }
  return { $$typeof: Hf, type: e.type, key: i, ref: s, props: r, _owner: o }
}
ct.createContext = function (e) {
  return (
    (e = {
      $$typeof: h4,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (e.Provider = { $$typeof: d4, _context: e }),
    (e.Consumer = e)
  )
}
ct.createElement = IC
ct.createFactory = function (e) {
  var t = IC.bind(null, e)
  return (t.type = e), t
}
ct.createRef = function () {
  return { current: null }
}
ct.forwardRef = function (e) {
  return { $$typeof: p4, render: e }
}
ct.isValidElement = S1
ct.lazy = function (e) {
  return { $$typeof: y4, _payload: { _status: -1, _result: e }, _init: x4 }
}
ct.memo = function (e, t) {
  return { $$typeof: m4, type: e, compare: t === void 0 ? null : t }
}
ct.startTransition = function (e) {
  var t = oh.transition
  oh.transition = {}
  try {
    e()
  } finally {
    oh.transition = t
  }
}
ct.unstable_act = function () {
  throw Error('act(...) is not supported in production builds of React.')
}
ct.useCallback = function (e, t) {
  return Xn.current.useCallback(e, t)
}
ct.useContext = function (e) {
  return Xn.current.useContext(e)
}
ct.useDebugValue = function () {}
ct.useDeferredValue = function (e) {
  return Xn.current.useDeferredValue(e)
}
ct.useEffect = function (e, t) {
  return Xn.current.useEffect(e, t)
}
ct.useId = function () {
  return Xn.current.useId()
}
ct.useImperativeHandle = function (e, t, n) {
  return Xn.current.useImperativeHandle(e, t, n)
}
ct.useInsertionEffect = function (e, t) {
  return Xn.current.useInsertionEffect(e, t)
}
ct.useLayoutEffect = function (e, t) {
  return Xn.current.useLayoutEffect(e, t)
}
ct.useMemo = function (e, t) {
  return Xn.current.useMemo(e, t)
}
ct.useReducer = function (e, t, n) {
  return Xn.current.useReducer(e, t, n)
}
ct.useRef = function (e) {
  return Xn.current.useRef(e)
}
ct.useState = function (e) {
  return Xn.current.useState(e)
}
ct.useSyncExternalStore = function (e, t, n) {
  return Xn.current.useSyncExternalStore(e, t, n)
}
ct.useTransition = function () {
  return Xn.current.useTransition()
}
ct.version = '18.2.0'
_C.exports = ct
var w = _C.exports
const fn = Ic(w),
  cp = EC({ __proto__: null, default: fn }, [w])
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var E4 = w,
  C4 = Symbol.for('react.element'),
  _4 = Symbol.for('react.fragment'),
  O4 = Object.prototype.hasOwnProperty,
  k4 = E4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  T4 = { key: !0, ref: !0, __self: !0, __source: !0 }
function DC(e, t, n) {
  var r,
    i = {},
    s = null,
    o = null
  n !== void 0 && (s = '' + n),
    t.key !== void 0 && (s = '' + t.key),
    t.ref !== void 0 && (o = t.ref)
  for (r in t) O4.call(t, r) && !T4.hasOwnProperty(r) && (i[r] = t[r])
  if (e && e.defaultProps) for (r in ((t = e.defaultProps), t)) i[r] === void 0 && (i[r] = t[r])
  return { $$typeof: C4, type: e, key: s, ref: o, props: i, _owner: k4.current }
}
y0.Fragment = _4
y0.jsx = DC
y0.jsxs = DC
CC.exports = y0
var E = CC.exports,
  qm = {},
  NC = { exports: {} },
  Rr = {},
  MC = { exports: {} },
  jC = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (e) {
  function t(K, H) {
    var oe = K.length
    K.push(H)
    e: for (; 0 < oe; ) {
      var Ae = (oe - 1) >>> 1,
        Ie = K[Ae]
      if (0 < i(Ie, H)) (K[Ae] = H), (K[oe] = Ie), (oe = Ae)
      else break e
    }
  }
  function n(K) {
    return K.length === 0 ? null : K[0]
  }
  function r(K) {
    if (K.length === 0) return null
    var H = K[0],
      oe = K.pop()
    if (oe !== H) {
      K[0] = oe
      e: for (var Ae = 0, Ie = K.length, fe = Ie >>> 1; Ae < fe; ) {
        var _e = 2 * (Ae + 1) - 1,
          re = K[_e],
          Z = _e + 1,
          it = K[Z]
        if (0 > i(re, oe))
          Z < Ie && 0 > i(it, re)
            ? ((K[Ae] = it), (K[Z] = oe), (Ae = Z))
            : ((K[Ae] = re), (K[_e] = oe), (Ae = _e))
        else if (Z < Ie && 0 > i(it, oe)) (K[Ae] = it), (K[Z] = oe), (Ae = Z)
        else break e
      }
    }
    return H
  }
  function i(K, H) {
    var oe = K.sortIndex - H.sortIndex
    return oe !== 0 ? oe : K.id - H.id
  }
  if (typeof performance == 'object' && typeof performance.now == 'function') {
    var s = performance
    e.unstable_now = function () {
      return s.now()
    }
  } else {
    var o = Date,
      a = o.now()
    e.unstable_now = function () {
      return o.now() - a
    }
  }
  var l = [],
    c = [],
    u = 1,
    f = null,
    d = 3,
    p = !1,
    h = !1,
    m = !1,
    b = typeof setTimeout == 'function' ? setTimeout : null,
    y = typeof clearTimeout == 'function' ? clearTimeout : null,
    v = typeof setImmediate < 'u' ? setImmediate : null
  typeof navigator < 'u' &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling)
  function S(K) {
    for (var H = n(c); H !== null; ) {
      if (H.callback === null) r(c)
      else if (H.startTime <= K) r(c), (H.sortIndex = H.expirationTime), t(l, H)
      else break
      H = n(c)
    }
  }
  function T(K) {
    if (((m = !1), S(K), !h))
      if (n(l) !== null) (h = !0), We(A)
      else {
        var H = n(c)
        H !== null && Me(T, H.startTime - K)
      }
  }
  function A(K, H) {
    ;(h = !1), m && ((m = !1), y(D), (D = -1)), (p = !0)
    var oe = d
    try {
      for (S(H), f = n(l); f !== null && (!(f.expirationTime > H) || (K && !ie())); ) {
        var Ae = f.callback
        if (typeof Ae == 'function') {
          ;(f.callback = null), (d = f.priorityLevel)
          var Ie = Ae(f.expirationTime <= H)
          ;(H = e.unstable_now()),
            typeof Ie == 'function' ? (f.callback = Ie) : f === n(l) && r(l),
            S(H)
        } else r(l)
        f = n(l)
      }
      if (f !== null) var fe = !0
      else {
        var _e = n(c)
        _e !== null && Me(T, _e.startTime - H), (fe = !1)
      }
      return fe
    } finally {
      ;(f = null), (d = oe), (p = !1)
    }
  }
  var I = !1,
    k = null,
    D = -1,
    F = 5,
    V = -1
  function ie() {
    return !(e.unstable_now() - V < F)
  }
  function de() {
    if (k !== null) {
      var K = e.unstable_now()
      V = K
      var H = !0
      try {
        H = k(!0, K)
      } finally {
        H ? xe() : ((I = !1), (k = null))
      }
    } else I = !1
  }
  var xe
  if (typeof v == 'function')
    xe = function () {
      v(de)
    }
  else if (typeof MessageChannel < 'u') {
    var we = new MessageChannel(),
      Pe = we.port2
    ;(we.port1.onmessage = de),
      (xe = function () {
        Pe.postMessage(null)
      })
  } else
    xe = function () {
      b(de, 0)
    }
  function We(K) {
    ;(k = K), I || ((I = !0), xe())
  }
  function Me(K, H) {
    D = b(function () {
      K(e.unstable_now())
    }, H)
  }
  ;(e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (K) {
      K.callback = null
    }),
    (e.unstable_continueExecution = function () {
      h || p || ((h = !0), We(A))
    }),
    (e.unstable_forceFrameRate = function (K) {
      0 > K || 125 < K
        ? console.error(
            'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
          )
        : (F = 0 < K ? Math.floor(1e3 / K) : 5)
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return d
    }),
    (e.unstable_getFirstCallbackNode = function () {
      return n(l)
    }),
    (e.unstable_next = function (K) {
      switch (d) {
        case 1:
        case 2:
        case 3:
          var H = 3
          break
        default:
          H = d
      }
      var oe = d
      d = H
      try {
        return K()
      } finally {
        d = oe
      }
    }),
    (e.unstable_pauseExecution = function () {}),
    (e.unstable_requestPaint = function () {}),
    (e.unstable_runWithPriority = function (K, H) {
      switch (K) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          K = 3
      }
      var oe = d
      d = K
      try {
        return H()
      } finally {
        d = oe
      }
    }),
    (e.unstable_scheduleCallback = function (K, H, oe) {
      var Ae = e.unstable_now()
      switch (
        (typeof oe == 'object' && oe !== null
          ? ((oe = oe.delay), (oe = typeof oe == 'number' && 0 < oe ? Ae + oe : Ae))
          : (oe = Ae),
        K)
      ) {
        case 1:
          var Ie = -1
          break
        case 2:
          Ie = 250
          break
        case 5:
          Ie = 1073741823
          break
        case 4:
          Ie = 1e4
          break
        default:
          Ie = 5e3
      }
      return (
        (Ie = oe + Ie),
        (K = {
          id: u++,
          callback: H,
          priorityLevel: K,
          startTime: oe,
          expirationTime: Ie,
          sortIndex: -1,
        }),
        oe > Ae
          ? ((K.sortIndex = oe),
            t(c, K),
            n(l) === null && K === n(c) && (m ? (y(D), (D = -1)) : (m = !0), Me(T, oe - Ae)))
          : ((K.sortIndex = Ie), t(l, K), h || p || ((h = !0), We(A))),
        K
      )
    }),
    (e.unstable_shouldYield = ie),
    (e.unstable_wrapCallback = function (K) {
      var H = d
      return function () {
        var oe = d
        d = H
        try {
          return K.apply(this, arguments)
        } finally {
          d = oe
        }
      }
    })
})(jC)
MC.exports = jC
var A4 = MC.exports
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var LC = w,
  kr = A4
function ee(e) {
  for (
    var t = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, n = 1;
    n < arguments.length;
    n++
  )
    t += '&args[]=' + encodeURIComponent(arguments[n])
  return (
    'Minified React error #' +
    e +
    '; visit ' +
    t +
    ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
  )
}
var $C = new Set(),
  Yu = {}
function Ha(e, t) {
  uc(e, t), uc(e + 'Capture', t)
}
function uc(e, t) {
  for (Yu[e] = t, e = 0; e < t.length; e++) $C.add(t[e])
}
var Ps = !(
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
  ),
  Km = Object.prototype.hasOwnProperty,
  R4 =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Hb = {},
  qb = {}
function P4(e) {
  return Km.call(qb, e) ? !0 : Km.call(Hb, e) ? !1 : R4.test(e) ? (qb[e] = !0) : ((Hb[e] = !0), !1)
}
function I4(e, t, n, r) {
  if (n !== null && n.type === 0) return !1
  switch (typeof t) {
    case 'function':
    case 'symbol':
      return !0
    case 'boolean':
      return r
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((e = e.toLowerCase().slice(0, 5)), e !== 'data-' && e !== 'aria-')
    default:
      return !1
  }
}
function D4(e, t, n, r) {
  if (t === null || typeof t > 'u' || I4(e, t, n, r)) return !0
  if (r) return !1
  if (n !== null)
    switch (n.type) {
      case 3:
        return !t
      case 4:
        return t === !1
      case 5:
        return isNaN(t)
      case 6:
        return isNaN(t) || 1 > t
    }
  return !1
}
function Zn(e, t, n, r, i, s, o) {
  ;(this.acceptsBooleans = t === 2 || t === 3 || t === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = e),
    (this.type = t),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o)
}
var kn = {}
'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
  .split(' ')
  .forEach(function (e) {
    kn[e] = new Zn(e, 0, !1, e, null, !1, !1)
  })
;[
  ['acceptCharset', 'accept-charset'],
  ['className', 'class'],
  ['htmlFor', 'for'],
  ['httpEquiv', 'http-equiv'],
].forEach(function (e) {
  var t = e[0]
  kn[t] = new Zn(t, 1, !1, e[1], null, !1, !1)
})
;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
  kn[e] = new Zn(e, 2, !1, e.toLowerCase(), null, !1, !1)
})
;['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) {
  kn[e] = new Zn(e, 2, !1, e, null, !1, !1)
})
'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
  .split(' ')
  .forEach(function (e) {
    kn[e] = new Zn(e, 3, !1, e.toLowerCase(), null, !1, !1)
  })
;['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
  kn[e] = new Zn(e, 3, !0, e, null, !1, !1)
})
;['capture', 'download'].forEach(function (e) {
  kn[e] = new Zn(e, 4, !1, e, null, !1, !1)
})
;['cols', 'rows', 'size', 'span'].forEach(function (e) {
  kn[e] = new Zn(e, 6, !1, e, null, !1, !1)
})
;['rowSpan', 'start'].forEach(function (e) {
  kn[e] = new Zn(e, 5, !1, e.toLowerCase(), null, !1, !1)
})
var E1 = /[\-:]([a-z])/g
function C1(e) {
  return e[1].toUpperCase()
}
'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
  .split(' ')
  .forEach(function (e) {
    var t = e.replace(E1, C1)
    kn[t] = new Zn(t, 1, !1, e, null, !1, !1)
  })
'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
  .split(' ')
  .forEach(function (e) {
    var t = e.replace(E1, C1)
    kn[t] = new Zn(t, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1)
  })
;['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
  var t = e.replace(E1, C1)
  kn[t] = new Zn(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1)
})
;['tabIndex', 'crossOrigin'].forEach(function (e) {
  kn[e] = new Zn(e, 1, !1, e.toLowerCase(), null, !1, !1)
})
kn.xlinkHref = new Zn('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)
;['src', 'href', 'action', 'formAction'].forEach(function (e) {
  kn[e] = new Zn(e, 1, !1, e.toLowerCase(), null, !0, !0)
})
function _1(e, t, n, r) {
  var i = kn.hasOwnProperty(t) ? kn[t] : null
  ;(i !== null
    ? i.type !== 0
    : r || !(2 < t.length) || (t[0] !== 'o' && t[0] !== 'O') || (t[1] !== 'n' && t[1] !== 'N')) &&
    (D4(t, n, i, r) && (n = null),
    r || i === null
      ? P4(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, '' + n))
      : i.mustUseProperty
      ? (e[i.propertyName] = n === null ? (i.type === 3 ? !1 : '') : n)
      : ((t = i.attributeName),
        (r = i.attributeNamespace),
        n === null
          ? e.removeAttribute(t)
          : ((i = i.type),
            (n = i === 3 || (i === 4 && n === !0) ? '' : '' + n),
            r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var Fs = LC.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  dd = Symbol.for('react.element'),
  gl = Symbol.for('react.portal'),
  ml = Symbol.for('react.fragment'),
  O1 = Symbol.for('react.strict_mode'),
  Gm = Symbol.for('react.profiler'),
  FC = Symbol.for('react.provider'),
  BC = Symbol.for('react.context'),
  k1 = Symbol.for('react.forward_ref'),
  Ym = Symbol.for('react.suspense'),
  Qm = Symbol.for('react.suspense_list'),
  T1 = Symbol.for('react.memo'),
  co = Symbol.for('react.lazy'),
  UC = Symbol.for('react.offscreen'),
  Kb = Symbol.iterator
function Qc(e) {
  return e === null || typeof e != 'object'
    ? null
    : ((e = (Kb && e[Kb]) || e['@@iterator']), typeof e == 'function' ? e : null)
}
var Wt = Object.assign,
  Eg
function gu(e) {
  if (Eg === void 0)
    try {
      throw Error()
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/)
      Eg = (t && t[1]) || ''
    }
  return (
    `
` +
    Eg +
    e
  )
}
var Cg = !1
function _g(e, t) {
  if (!e || Cg) return ''
  Cg = !0
  var n = Error.prepareStackTrace
  Error.prepareStackTrace = void 0
  try {
    if (t)
      if (
        ((t = function () {
          throw Error()
        }),
        Object.defineProperty(t.prototype, 'props', {
          set: function () {
            throw Error()
          },
        }),
        typeof Reflect == 'object' && Reflect.construct)
      ) {
        try {
          Reflect.construct(t, [])
        } catch (c) {
          var r = c
        }
        Reflect.construct(e, [], t)
      } else {
        try {
          t.call()
        } catch (c) {
          r = c
        }
        e.call(t.prototype)
      }
    else {
      try {
        throw Error()
      } catch (c) {
        r = c
      }
      e()
    }
  } catch (c) {
    if (c && r && typeof c.stack == 'string') {
      for (
        var i = c.stack.split(`
`),
          s = r.stack.split(`
`),
          o = i.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && i[o] !== s[a];

      )
        a--
      for (; 1 <= o && 0 <= a; o--, a--)
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || i[o] !== s[a])) {
                var l =
                  `
` + i[o].replace(' at new ', ' at ')
                return (
                  e.displayName &&
                    l.includes('<anonymous>') &&
                    (l = l.replace('<anonymous>', e.displayName)),
                  l
                )
              }
            while (1 <= o && 0 <= a)
          break
        }
    }
  } finally {
    ;(Cg = !1), (Error.prepareStackTrace = n)
  }
  return (e = e ? e.displayName || e.name : '') ? gu(e) : ''
}
function N4(e) {
  switch (e.tag) {
    case 5:
      return gu(e.type)
    case 16:
      return gu('Lazy')
    case 13:
      return gu('Suspense')
    case 19:
      return gu('SuspenseList')
    case 0:
    case 2:
    case 15:
      return (e = _g(e.type, !1)), e
    case 11:
      return (e = _g(e.type.render, !1)), e
    case 1:
      return (e = _g(e.type, !0)), e
    default:
      return ''
  }
}
function Xm(e) {
  if (e == null) return null
  if (typeof e == 'function') return e.displayName || e.name || null
  if (typeof e == 'string') return e
  switch (e) {
    case ml:
      return 'Fragment'
    case gl:
      return 'Portal'
    case Gm:
      return 'Profiler'
    case O1:
      return 'StrictMode'
    case Ym:
      return 'Suspense'
    case Qm:
      return 'SuspenseList'
  }
  if (typeof e == 'object')
    switch (e.$$typeof) {
      case BC:
        return (e.displayName || 'Context') + '.Consumer'
      case FC:
        return (e._context.displayName || 'Context') + '.Provider'
      case k1:
        var t = e.render
        return (
          (e = e.displayName),
          e ||
            ((e = t.displayName || t.name || ''),
            (e = e !== '' ? 'ForwardRef(' + e + ')' : 'ForwardRef')),
          e
        )
      case T1:
        return (t = e.displayName || null), t !== null ? t : Xm(e.type) || 'Memo'
      case co:
        ;(t = e._payload), (e = e._init)
        try {
          return Xm(e(t))
        } catch {}
    }
  return null
}
function M4(e) {
  var t = e.type
  switch (e.tag) {
    case 24:
      return 'Cache'
    case 9:
      return (t.displayName || 'Context') + '.Consumer'
    case 10:
      return (t._context.displayName || 'Context') + '.Provider'
    case 18:
      return 'DehydratedFragment'
    case 11:
      return (
        (e = t.render),
        (e = e.displayName || e.name || ''),
        t.displayName || (e !== '' ? 'ForwardRef(' + e + ')' : 'ForwardRef')
      )
    case 7:
      return 'Fragment'
    case 5:
      return t
    case 4:
      return 'Portal'
    case 3:
      return 'Root'
    case 6:
      return 'Text'
    case 16:
      return Xm(t)
    case 8:
      return t === O1 ? 'StrictMode' : 'Mode'
    case 22:
      return 'Offscreen'
    case 12:
      return 'Profiler'
    case 21:
      return 'Scope'
    case 13:
      return 'Suspense'
    case 19:
      return 'SuspenseList'
    case 25:
      return 'TracingMarker'
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == 'function') return t.displayName || t.name || null
      if (typeof t == 'string') return t
  }
  return null
}
function Lo(e) {
  switch (typeof e) {
    case 'boolean':
    case 'number':
    case 'string':
    case 'undefined':
      return e
    case 'object':
      return e
    default:
      return ''
  }
}
function zC(e) {
  var t = e.type
  return (e = e.nodeName) && e.toLowerCase() === 'input' && (t === 'checkbox' || t === 'radio')
}
function j4(e) {
  var t = zC(e) ? 'checked' : 'value',
    n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    r = '' + e[t]
  if (
    !e.hasOwnProperty(t) &&
    typeof n < 'u' &&
    typeof n.get == 'function' &&
    typeof n.set == 'function'
  ) {
    var i = n.get,
      s = n.set
    return (
      Object.defineProperty(e, t, {
        configurable: !0,
        get: function () {
          return i.call(this)
        },
        set: function (o) {
          ;(r = '' + o), s.call(this, o)
        },
      }),
      Object.defineProperty(e, t, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r
        },
        setValue: function (o) {
          r = '' + o
        },
        stopTracking: function () {
          ;(e._valueTracker = null), delete e[t]
        },
      }
    )
  }
}
function hd(e) {
  e._valueTracker || (e._valueTracker = j4(e))
}
function WC(e) {
  if (!e) return !1
  var t = e._valueTracker
  if (!t) return !0
  var n = t.getValue(),
    r = ''
  return (
    e && (r = zC(e) ? (e.checked ? 'true' : 'false') : e.value),
    (e = r),
    e !== n ? (t.setValue(e), !0) : !1
  )
}
function up(e) {
  if (((e = e || (typeof document < 'u' ? document : void 0)), typeof e > 'u')) return null
  try {
    return e.activeElement || e.body
  } catch {
    return e.body
  }
}
function Zm(e, t) {
  var n = t.checked
  return Wt({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? e._wrapperState.initialChecked,
  })
}
function Gb(e, t) {
  var n = t.defaultValue == null ? '' : t.defaultValue,
    r = t.checked != null ? t.checked : t.defaultChecked
  ;(n = Lo(t.value != null ? t.value : n)),
    (e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: t.type === 'checkbox' || t.type === 'radio' ? t.checked != null : t.value != null,
    })
}
function VC(e, t) {
  ;(t = t.checked), t != null && _1(e, 'checked', t, !1)
}
function Jm(e, t) {
  VC(e, t)
  var n = Lo(t.value),
    r = t.type
  if (n != null)
    r === 'number'
      ? ((n === 0 && e.value === '') || e.value != n) && (e.value = '' + n)
      : e.value !== '' + n && (e.value = '' + n)
  else if (r === 'submit' || r === 'reset') {
    e.removeAttribute('value')
    return
  }
  t.hasOwnProperty('value')
    ? ey(e, t.type, n)
    : t.hasOwnProperty('defaultValue') && ey(e, t.type, Lo(t.defaultValue)),
    t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}
function Yb(e, t, n) {
  if (t.hasOwnProperty('value') || t.hasOwnProperty('defaultValue')) {
    var r = t.type
    if (!((r !== 'submit' && r !== 'reset') || (t.value !== void 0 && t.value !== null))) return
    ;(t = '' + e._wrapperState.initialValue),
      n || t === e.value || (e.value = t),
      (e.defaultValue = t)
  }
  ;(n = e.name),
    n !== '' && (e.name = ''),
    (e.defaultChecked = !!e._wrapperState.initialChecked),
    n !== '' && (e.name = n)
}
function ey(e, t, n) {
  ;(t !== 'number' || up(e.ownerDocument) !== e) &&
    (n == null
      ? (e.defaultValue = '' + e._wrapperState.initialValue)
      : e.defaultValue !== '' + n && (e.defaultValue = '' + n))
}
var mu = Array.isArray
function Nl(e, t, n, r) {
  if (((e = e.options), t)) {
    t = {}
    for (var i = 0; i < n.length; i++) t['$' + n[i]] = !0
    for (n = 0; n < e.length; n++)
      (i = t.hasOwnProperty('$' + e[n].value)),
        e[n].selected !== i && (e[n].selected = i),
        i && r && (e[n].defaultSelected = !0)
  } else {
    for (n = '' + Lo(n), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === n) {
        ;(e[i].selected = !0), r && (e[i].defaultSelected = !0)
        return
      }
      t !== null || e[i].disabled || (t = e[i])
    }
    t !== null && (t.selected = !0)
  }
}
function ty(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(ee(91))
  return Wt({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: '' + e._wrapperState.initialValue,
  })
}
function Qb(e, t) {
  var n = t.value
  if (n == null) {
    if (((n = t.children), (t = t.defaultValue), n != null)) {
      if (t != null) throw Error(ee(92))
      if (mu(n)) {
        if (1 < n.length) throw Error(ee(93))
        n = n[0]
      }
      t = n
    }
    t == null && (t = ''), (n = t)
  }
  e._wrapperState = { initialValue: Lo(n) }
}
function HC(e, t) {
  var n = Lo(t.value),
    r = Lo(t.defaultValue)
  n != null &&
    ((n = '' + n),
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    r != null && (e.defaultValue = '' + r)
}
function Xb(e) {
  var t = e.textContent
  t === e._wrapperState.initialValue && t !== '' && t !== null && (e.value = t)
}
function qC(e) {
  switch (e) {
    case 'svg':
      return 'http://www.w3.org/2000/svg'
    case 'math':
      return 'http://www.w3.org/1998/Math/MathML'
    default:
      return 'http://www.w3.org/1999/xhtml'
  }
}
function ny(e, t) {
  return e == null || e === 'http://www.w3.org/1999/xhtml'
    ? qC(t)
    : e === 'http://www.w3.org/2000/svg' && t === 'foreignObject'
    ? 'http://www.w3.org/1999/xhtml'
    : e
}
var pd,
  KC = (function (e) {
    return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
      ? function (t, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return e(t, n, r, i)
          })
        }
      : e
  })(function (e, t) {
    if (e.namespaceURI !== 'http://www.w3.org/2000/svg' || 'innerHTML' in e) e.innerHTML = t
    else {
      for (
        pd = pd || document.createElement('div'),
          pd.innerHTML = '<svg>' + t.valueOf().toString() + '</svg>',
          t = pd.firstChild;
        e.firstChild;

      )
        e.removeChild(e.firstChild)
      for (; t.firstChild; ) e.appendChild(t.firstChild)
    }
  })
function Qu(e, t) {
  if (t) {
    var n = e.firstChild
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t
      return
    }
  }
  e.textContent = t
}
var Iu = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  L4 = ['Webkit', 'ms', 'Moz', 'O']
Object.keys(Iu).forEach(function (e) {
  L4.forEach(function (t) {
    ;(t = t + e.charAt(0).toUpperCase() + e.substring(1)), (Iu[t] = Iu[e])
  })
})
function GC(e, t, n) {
  return t == null || typeof t == 'boolean' || t === ''
    ? ''
    : n || typeof t != 'number' || t === 0 || (Iu.hasOwnProperty(e) && Iu[e])
    ? ('' + t).trim()
    : t + 'px'
}
function YC(e, t) {
  e = e.style
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var r = n.indexOf('--') === 0,
        i = GC(n, t[n], r)
      n === 'float' && (n = 'cssFloat'), r ? e.setProperty(n, i) : (e[n] = i)
    }
}
var $4 = Wt(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
)
function ry(e, t) {
  if (t) {
    if ($4[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(ee(137, e))
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(ee(60))
      if (typeof t.dangerouslySetInnerHTML != 'object' || !('__html' in t.dangerouslySetInnerHTML))
        throw Error(ee(61))
    }
    if (t.style != null && typeof t.style != 'object') throw Error(ee(62))
  }
}
function iy(e, t) {
  if (e.indexOf('-') === -1) return typeof t.is == 'string'
  switch (e) {
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return !1
    default:
      return !0
  }
}
var sy = null
function A1(e) {
  return (
    (e = e.target || e.srcElement || window),
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
  )
}
var oy = null,
  Ml = null,
  jl = null
function Zb(e) {
  if ((e = Gf(e))) {
    if (typeof oy != 'function') throw Error(ee(280))
    var t = e.stateNode
    t && ((t = S0(t)), oy(e.stateNode, e.type, t))
  }
}
function QC(e) {
  Ml ? (jl ? jl.push(e) : (jl = [e])) : (Ml = e)
}
function XC() {
  if (Ml) {
    var e = Ml,
      t = jl
    if (((jl = Ml = null), Zb(e), t)) for (e = 0; e < t.length; e++) Zb(t[e])
  }
}
function ZC(e, t) {
  return e(t)
}
function JC() {}
var Og = !1
function e3(e, t, n) {
  if (Og) return e(t, n)
  Og = !0
  try {
    return ZC(e, t, n)
  } finally {
    ;(Og = !1), (Ml !== null || jl !== null) && (JC(), XC())
  }
}
function Xu(e, t) {
  var n = e.stateNode
  if (n === null) return null
  var r = S0(n)
  if (r === null) return null
  n = r[t]
  e: switch (t) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      ;(r = !r.disabled) ||
        ((e = e.type),
        (r = !(e === 'button' || e === 'input' || e === 'select' || e === 'textarea'))),
        (e = !r)
      break e
    default:
      e = !1
  }
  if (e) return null
  if (n && typeof n != 'function') throw Error(ee(231, t, typeof n))
  return n
}
var ay = !1
if (Ps)
  try {
    var Xc = {}
    Object.defineProperty(Xc, 'passive', {
      get: function () {
        ay = !0
      },
    }),
      window.addEventListener('test', Xc, Xc),
      window.removeEventListener('test', Xc, Xc)
  } catch {
    ay = !1
  }
function F4(e, t, n, r, i, s, o, a, l) {
  var c = Array.prototype.slice.call(arguments, 3)
  try {
    t.apply(n, c)
  } catch (u) {
    this.onError(u)
  }
}
var Du = !1,
  fp = null,
  dp = !1,
  ly = null,
  B4 = {
    onError: function (e) {
      ;(Du = !0), (fp = e)
    },
  }
function U4(e, t, n, r, i, s, o, a, l) {
  ;(Du = !1), (fp = null), F4.apply(B4, arguments)
}
function z4(e, t, n, r, i, s, o, a, l) {
  if ((U4.apply(this, arguments), Du)) {
    if (Du) {
      var c = fp
      ;(Du = !1), (fp = null)
    } else throw Error(ee(198))
    dp || ((dp = !0), (ly = c))
  }
}
function qa(e) {
  var t = e,
    n = e
  if (e.alternate) for (; t.return; ) t = t.return
  else {
    e = t
    do (t = e), t.flags & 4098 && (n = t.return), (e = t.return)
    while (e)
  }
  return t.tag === 3 ? n : null
}
function t3(e) {
  if (e.tag === 13) {
    var t = e.memoizedState
    if ((t === null && ((e = e.alternate), e !== null && (t = e.memoizedState)), t !== null))
      return t.dehydrated
  }
  return null
}
function Jb(e) {
  if (qa(e) !== e) throw Error(ee(188))
}
function W4(e) {
  var t = e.alternate
  if (!t) {
    if (((t = qa(e)), t === null)) throw Error(ee(188))
    return t !== e ? null : e
  }
  for (var n = e, r = t; ; ) {
    var i = n.return
    if (i === null) break
    var s = i.alternate
    if (s === null) {
      if (((r = i.return), r !== null)) {
        n = r
        continue
      }
      break
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === n) return Jb(i), e
        if (s === r) return Jb(i), t
        s = s.sibling
      }
      throw Error(ee(188))
    }
    if (n.return !== r.return) (n = i), (r = s)
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === n) {
          ;(o = !0), (n = i), (r = s)
          break
        }
        if (a === r) {
          ;(o = !0), (r = i), (n = s)
          break
        }
        a = a.sibling
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === n) {
            ;(o = !0), (n = s), (r = i)
            break
          }
          if (a === r) {
            ;(o = !0), (r = s), (n = i)
            break
          }
          a = a.sibling
        }
        if (!o) throw Error(ee(189))
      }
    }
    if (n.alternate !== r) throw Error(ee(190))
  }
  if (n.tag !== 3) throw Error(ee(188))
  return n.stateNode.current === n ? e : t
}
function n3(e) {
  return (e = W4(e)), e !== null ? r3(e) : null
}
function r3(e) {
  if (e.tag === 5 || e.tag === 6) return e
  for (e = e.child; e !== null; ) {
    var t = r3(e)
    if (t !== null) return t
    e = e.sibling
  }
  return null
}
var i3 = kr.unstable_scheduleCallback,
  ex = kr.unstable_cancelCallback,
  V4 = kr.unstable_shouldYield,
  H4 = kr.unstable_requestPaint,
  Jt = kr.unstable_now,
  q4 = kr.unstable_getCurrentPriorityLevel,
  R1 = kr.unstable_ImmediatePriority,
  s3 = kr.unstable_UserBlockingPriority,
  hp = kr.unstable_NormalPriority,
  K4 = kr.unstable_LowPriority,
  o3 = kr.unstable_IdlePriority,
  v0 = null,
  Ji = null
function G4(e) {
  if (Ji && typeof Ji.onCommitFiberRoot == 'function')
    try {
      Ji.onCommitFiberRoot(v0, e, void 0, (e.current.flags & 128) === 128)
    } catch {}
}
var Oi = Math.clz32 ? Math.clz32 : X4,
  Y4 = Math.log,
  Q4 = Math.LN2
function X4(e) {
  return (e >>>= 0), e === 0 ? 32 : (31 - ((Y4(e) / Q4) | 0)) | 0
}
var gd = 64,
  md = 4194304
function yu(e) {
  switch (e & -e) {
    case 1:
      return 1
    case 2:
      return 2
    case 4:
      return 4
    case 8:
      return 8
    case 16:
      return 16
    case 32:
      return 32
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424
    case 134217728:
      return 134217728
    case 268435456:
      return 268435456
    case 536870912:
      return 536870912
    case 1073741824:
      return 1073741824
    default:
      return e
  }
}
function pp(e, t) {
  var n = e.pendingLanes
  if (n === 0) return 0
  var r = 0,
    i = e.suspendedLanes,
    s = e.pingedLanes,
    o = n & 268435455
  if (o !== 0) {
    var a = o & ~i
    a !== 0 ? (r = yu(a)) : ((s &= o), s !== 0 && (r = yu(s)))
  } else (o = n & ~i), o !== 0 ? (r = yu(o)) : s !== 0 && (r = yu(s))
  if (r === 0) return 0
  if (
    t !== 0 &&
    t !== r &&
    !(t & i) &&
    ((i = r & -r), (s = t & -t), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return t
  if ((r & 4 && (r |= n & 16), (t = e.entangledLanes), t !== 0))
    for (e = e.entanglements, t &= r; 0 < t; )
      (n = 31 - Oi(t)), (i = 1 << n), (r |= e[n]), (t &= ~i)
  return r
}
function Z4(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1
    default:
      return -1
  }
}
function J4(e, t) {
  for (
    var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes;
    0 < s;

  ) {
    var o = 31 - Oi(s),
      a = 1 << o,
      l = i[o]
    l === -1 ? (!(a & n) || a & r) && (i[o] = Z4(a, t)) : l <= t && (e.expiredLanes |= a), (s &= ~a)
  }
}
function cy(e) {
  return (e = e.pendingLanes & -1073741825), e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}
function a3() {
  var e = gd
  return (gd <<= 1), !(gd & 4194240) && (gd = 64), e
}
function kg(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e)
  return t
}
function qf(e, t, n) {
  ;(e.pendingLanes |= t),
    t !== 536870912 && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
    (e = e.eventTimes),
    (t = 31 - Oi(t)),
    (e[t] = n)
}
function eA(e, t) {
  var n = e.pendingLanes & ~t
  ;(e.pendingLanes = t),
    (e.suspendedLanes = 0),
    (e.pingedLanes = 0),
    (e.expiredLanes &= t),
    (e.mutableReadLanes &= t),
    (e.entangledLanes &= t),
    (t = e.entanglements)
  var r = e.eventTimes
  for (e = e.expirationTimes; 0 < n; ) {
    var i = 31 - Oi(n),
      s = 1 << i
    ;(t[i] = 0), (r[i] = -1), (e[i] = -1), (n &= ~s)
  }
}
function P1(e, t) {
  var n = (e.entangledLanes |= t)
  for (e = e.entanglements; n; ) {
    var r = 31 - Oi(n),
      i = 1 << r
    ;(i & t) | (e[r] & t) && (e[r] |= t), (n &= ~i)
  }
}
var Tt = 0
function l3(e) {
  return (e &= -e), 1 < e ? (4 < e ? (e & 268435455 ? 16 : 536870912) : 4) : 1
}
var c3,
  I1,
  u3,
  f3,
  d3,
  uy = !1,
  yd = [],
  _o = null,
  Oo = null,
  ko = null,
  Zu = new Map(),
  Ju = new Map(),
  ho = [],
  tA =
    'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
      ' '
    )
function tx(e, t) {
  switch (e) {
    case 'focusin':
    case 'focusout':
      _o = null
      break
    case 'dragenter':
    case 'dragleave':
      Oo = null
      break
    case 'mouseover':
    case 'mouseout':
      ko = null
      break
    case 'pointerover':
    case 'pointerout':
      Zu.delete(t.pointerId)
      break
    case 'gotpointercapture':
    case 'lostpointercapture':
      Ju.delete(t.pointerId)
  }
}
function Zc(e, t, n, r, i, s) {
  return e === null || e.nativeEvent !== s
    ? ((e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      t !== null && ((t = Gf(t)), t !== null && I1(t)),
      e)
    : ((e.eventSystemFlags |= r),
      (t = e.targetContainers),
      i !== null && t.indexOf(i) === -1 && t.push(i),
      e)
}
function nA(e, t, n, r, i) {
  switch (t) {
    case 'focusin':
      return (_o = Zc(_o, e, t, n, r, i)), !0
    case 'dragenter':
      return (Oo = Zc(Oo, e, t, n, r, i)), !0
    case 'mouseover':
      return (ko = Zc(ko, e, t, n, r, i)), !0
    case 'pointerover':
      var s = i.pointerId
      return Zu.set(s, Zc(Zu.get(s) || null, e, t, n, r, i)), !0
    case 'gotpointercapture':
      return (s = i.pointerId), Ju.set(s, Zc(Ju.get(s) || null, e, t, n, r, i)), !0
  }
  return !1
}
function h3(e) {
  var t = da(e.target)
  if (t !== null) {
    var n = qa(t)
    if (n !== null) {
      if (((t = n.tag), t === 13)) {
        if (((t = t3(n)), t !== null)) {
          ;(e.blockedOn = t),
            d3(e.priority, function () {
              u3(n)
            })
          return
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null
        return
      }
    }
  }
  e.blockedOn = null
}
function ah(e) {
  if (e.blockedOn !== null) return !1
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = fy(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent)
    if (n === null) {
      n = e.nativeEvent
      var r = new n.constructor(n.type, n)
      ;(sy = r), n.target.dispatchEvent(r), (sy = null)
    } else return (t = Gf(n)), t !== null && I1(t), (e.blockedOn = n), !1
    t.shift()
  }
  return !0
}
function nx(e, t, n) {
  ah(e) && n.delete(t)
}
function rA() {
  ;(uy = !1),
    _o !== null && ah(_o) && (_o = null),
    Oo !== null && ah(Oo) && (Oo = null),
    ko !== null && ah(ko) && (ko = null),
    Zu.forEach(nx),
    Ju.forEach(nx)
}
function Jc(e, t) {
  e.blockedOn === t &&
    ((e.blockedOn = null),
    uy || ((uy = !0), kr.unstable_scheduleCallback(kr.unstable_NormalPriority, rA)))
}
function ef(e) {
  function t(i) {
    return Jc(i, e)
  }
  if (0 < yd.length) {
    Jc(yd[0], e)
    for (var n = 1; n < yd.length; n++) {
      var r = yd[n]
      r.blockedOn === e && (r.blockedOn = null)
    }
  }
  for (
    _o !== null && Jc(_o, e),
      Oo !== null && Jc(Oo, e),
      ko !== null && Jc(ko, e),
      Zu.forEach(t),
      Ju.forEach(t),
      n = 0;
    n < ho.length;
    n++
  )
    (r = ho[n]), r.blockedOn === e && (r.blockedOn = null)
  for (; 0 < ho.length && ((n = ho[0]), n.blockedOn === null); )
    h3(n), n.blockedOn === null && ho.shift()
}
var Ll = Fs.ReactCurrentBatchConfig,
  gp = !0
function iA(e, t, n, r) {
  var i = Tt,
    s = Ll.transition
  Ll.transition = null
  try {
    ;(Tt = 1), D1(e, t, n, r)
  } finally {
    ;(Tt = i), (Ll.transition = s)
  }
}
function sA(e, t, n, r) {
  var i = Tt,
    s = Ll.transition
  Ll.transition = null
  try {
    ;(Tt = 4), D1(e, t, n, r)
  } finally {
    ;(Tt = i), (Ll.transition = s)
  }
}
function D1(e, t, n, r) {
  if (gp) {
    var i = fy(e, t, n, r)
    if (i === null) Lg(e, t, r, mp, n), tx(e, r)
    else if (nA(i, e, t, n, r)) r.stopPropagation()
    else if ((tx(e, r), t & 4 && -1 < tA.indexOf(e))) {
      for (; i !== null; ) {
        var s = Gf(i)
        if ((s !== null && c3(s), (s = fy(e, t, n, r)), s === null && Lg(e, t, r, mp, n), s === i))
          break
        i = s
      }
      i !== null && r.stopPropagation()
    } else Lg(e, t, r, null, n)
  }
}
var mp = null
function fy(e, t, n, r) {
  if (((mp = null), (e = A1(r)), (e = da(e)), e !== null))
    if (((t = qa(e)), t === null)) e = null
    else if (((n = t.tag), n === 13)) {
      if (((e = t3(t)), e !== null)) return e
      e = null
    } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated)
        return t.tag === 3 ? t.stateNode.containerInfo : null
      e = null
    } else t !== e && (e = null)
  return (mp = e), null
}
function p3(e) {
  switch (e) {
    case 'cancel':
    case 'click':
    case 'close':
    case 'contextmenu':
    case 'copy':
    case 'cut':
    case 'auxclick':
    case 'dblclick':
    case 'dragend':
    case 'dragstart':
    case 'drop':
    case 'focusin':
    case 'focusout':
    case 'input':
    case 'invalid':
    case 'keydown':
    case 'keypress':
    case 'keyup':
    case 'mousedown':
    case 'mouseup':
    case 'paste':
    case 'pause':
    case 'play':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointerup':
    case 'ratechange':
    case 'reset':
    case 'resize':
    case 'seeked':
    case 'submit':
    case 'touchcancel':
    case 'touchend':
    case 'touchstart':
    case 'volumechange':
    case 'change':
    case 'selectionchange':
    case 'textInput':
    case 'compositionstart':
    case 'compositionend':
    case 'compositionupdate':
    case 'beforeblur':
    case 'afterblur':
    case 'beforeinput':
    case 'blur':
    case 'fullscreenchange':
    case 'focus':
    case 'hashchange':
    case 'popstate':
    case 'select':
    case 'selectstart':
      return 1
    case 'drag':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'mousemove':
    case 'mouseout':
    case 'mouseover':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'scroll':
    case 'toggle':
    case 'touchmove':
    case 'wheel':
    case 'mouseenter':
    case 'mouseleave':
    case 'pointerenter':
    case 'pointerleave':
      return 4
    case 'message':
      switch (q4()) {
        case R1:
          return 1
        case s3:
          return 4
        case hp:
        case K4:
          return 16
        case o3:
          return 536870912
        default:
          return 16
      }
    default:
      return 16
  }
}
var Eo = null,
  N1 = null,
  lh = null
function g3() {
  if (lh) return lh
  var e,
    t = N1,
    n = t.length,
    r,
    i = 'value' in Eo ? Eo.value : Eo.textContent,
    s = i.length
  for (e = 0; e < n && t[e] === i[e]; e++);
  var o = n - e
  for (r = 1; r <= o && t[n - r] === i[s - r]; r++);
  return (lh = i.slice(e, 1 < r ? 1 - r : void 0))
}
function ch(e) {
  var t = e.keyCode
  return (
    'charCode' in e ? ((e = e.charCode), e === 0 && t === 13 && (e = 13)) : (e = t),
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
  )
}
function vd() {
  return !0
}
function rx() {
  return !1
}
function Pr(e) {
  function t(n, r, i, s, o) {
    ;(this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null)
    for (var a in e) e.hasOwnProperty(a) && ((n = e[a]), (this[a] = n ? n(s) : s[a]))
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? vd
        : rx),
      (this.isPropagationStopped = rx),
      this
    )
  }
  return (
    Wt(t.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0
        var n = this.nativeEvent
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != 'unknown' && (n.returnValue = !1),
          (this.isDefaultPrevented = vd))
      },
      stopPropagation: function () {
        var n = this.nativeEvent
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != 'unknown' && (n.cancelBubble = !0),
          (this.isPropagationStopped = vd))
      },
      persist: function () {},
      isPersistent: vd,
    }),
    t
  )
}
var Nc = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  M1 = Pr(Nc),
  Kf = Wt({}, Nc, { view: 0, detail: 0 }),
  oA = Pr(Kf),
  Tg,
  Ag,
  eu,
  w0 = Wt({}, Kf, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: j1,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0
        ? e.fromElement === e.srcElement
          ? e.toElement
          : e.fromElement
        : e.relatedTarget
    },
    movementX: function (e) {
      return 'movementX' in e
        ? e.movementX
        : (e !== eu &&
            (eu && e.type === 'mousemove'
              ? ((Tg = e.screenX - eu.screenX), (Ag = e.screenY - eu.screenY))
              : (Ag = Tg = 0),
            (eu = e)),
          Tg)
    },
    movementY: function (e) {
      return 'movementY' in e ? e.movementY : Ag
    },
  }),
  ix = Pr(w0),
  aA = Wt({}, w0, { dataTransfer: 0 }),
  lA = Pr(aA),
  cA = Wt({}, Kf, { relatedTarget: 0 }),
  Rg = Pr(cA),
  uA = Wt({}, Nc, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  fA = Pr(uA),
  dA = Wt({}, Nc, {
    clipboardData: function (e) {
      return 'clipboardData' in e ? e.clipboardData : window.clipboardData
    },
  }),
  hA = Pr(dA),
  pA = Wt({}, Nc, { data: 0 }),
  sx = Pr(pA),
  gA = {
    Esc: 'Escape',
    Spacebar: ' ',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown',
    Del: 'Delete',
    Win: 'OS',
    Menu: 'ContextMenu',
    Apps: 'ContextMenu',
    Scroll: 'ScrollLock',
    MozPrintableKey: 'Unidentified',
  },
  mA = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta',
  },
  yA = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
function vA(e) {
  var t = this.nativeEvent
  return t.getModifierState ? t.getModifierState(e) : (e = yA[e]) ? !!t[e] : !1
}
function j1() {
  return vA
}
var wA = Wt({}, Kf, {
    key: function (e) {
      if (e.key) {
        var t = gA[e.key] || e.key
        if (t !== 'Unidentified') return t
      }
      return e.type === 'keypress'
        ? ((e = ch(e)), e === 13 ? 'Enter' : String.fromCharCode(e))
        : e.type === 'keydown' || e.type === 'keyup'
        ? mA[e.keyCode] || 'Unidentified'
        : ''
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: j1,
    charCode: function (e) {
      return e.type === 'keypress' ? ch(e) : 0
    },
    keyCode: function (e) {
      return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0
    },
    which: function (e) {
      return e.type === 'keypress'
        ? ch(e)
        : e.type === 'keydown' || e.type === 'keyup'
        ? e.keyCode
        : 0
    },
  }),
  bA = Pr(wA),
  xA = Wt({}, w0, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  ox = Pr(xA),
  SA = Wt({}, Kf, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: j1,
  }),
  EA = Pr(SA),
  CA = Wt({}, Nc, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  _A = Pr(CA),
  OA = Wt({}, w0, {
    deltaX: function (e) {
      return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0
    },
    deltaY: function (e) {
      return 'deltaY' in e
        ? e.deltaY
        : 'wheelDeltaY' in e
        ? -e.wheelDeltaY
        : 'wheelDelta' in e
        ? -e.wheelDelta
        : 0
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  kA = Pr(OA),
  TA = [9, 13, 27, 32],
  L1 = Ps && 'CompositionEvent' in window,
  Nu = null
Ps && 'documentMode' in document && (Nu = document.documentMode)
var AA = Ps && 'TextEvent' in window && !Nu,
  m3 = Ps && (!L1 || (Nu && 8 < Nu && 11 >= Nu)),
  ax = String.fromCharCode(32),
  lx = !1
function y3(e, t) {
  switch (e) {
    case 'keyup':
      return TA.indexOf(t.keyCode) !== -1
    case 'keydown':
      return t.keyCode !== 229
    case 'keypress':
    case 'mousedown':
    case 'focusout':
      return !0
    default:
      return !1
  }
}
function v3(e) {
  return (e = e.detail), typeof e == 'object' && 'data' in e ? e.data : null
}
var yl = !1
function RA(e, t) {
  switch (e) {
    case 'compositionend':
      return v3(t)
    case 'keypress':
      return t.which !== 32 ? null : ((lx = !0), ax)
    case 'textInput':
      return (e = t.data), e === ax && lx ? null : e
    default:
      return null
  }
}
function PA(e, t) {
  if (yl)
    return e === 'compositionend' || (!L1 && y3(e, t))
      ? ((e = g3()), (lh = N1 = Eo = null), (yl = !1), e)
      : null
  switch (e) {
    case 'paste':
      return null
    case 'keypress':
      if (!(t.ctrlKey || t.altKey || t.metaKey) || (t.ctrlKey && t.altKey)) {
        if (t.char && 1 < t.char.length) return t.char
        if (t.which) return String.fromCharCode(t.which)
      }
      return null
    case 'compositionend':
      return m3 && t.locale !== 'ko' ? null : t.data
    default:
      return null
  }
}
var IA = {
  color: !0,
  date: !0,
  datetime: !0,
  'datetime-local': !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
}
function cx(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return t === 'input' ? !!IA[e.type] : t === 'textarea'
}
function w3(e, t, n, r) {
  QC(r),
    (t = yp(t, 'onChange')),
    0 < t.length &&
      ((n = new M1('onChange', 'change', null, n, r)), e.push({ event: n, listeners: t }))
}
var Mu = null,
  tf = null
function DA(e) {
  R3(e, 0)
}
function b0(e) {
  var t = bl(e)
  if (WC(t)) return e
}
function NA(e, t) {
  if (e === 'change') return t
}
var b3 = !1
if (Ps) {
  var Pg
  if (Ps) {
    var Ig = 'oninput' in document
    if (!Ig) {
      var ux = document.createElement('div')
      ux.setAttribute('oninput', 'return;'), (Ig = typeof ux.oninput == 'function')
    }
    Pg = Ig
  } else Pg = !1
  b3 = Pg && (!document.documentMode || 9 < document.documentMode)
}
function fx() {
  Mu && (Mu.detachEvent('onpropertychange', x3), (tf = Mu = null))
}
function x3(e) {
  if (e.propertyName === 'value' && b0(tf)) {
    var t = []
    w3(t, tf, e, A1(e)), e3(DA, t)
  }
}
function MA(e, t, n) {
  e === 'focusin'
    ? (fx(), (Mu = t), (tf = n), Mu.attachEvent('onpropertychange', x3))
    : e === 'focusout' && fx()
}
function jA(e) {
  if (e === 'selectionchange' || e === 'keyup' || e === 'keydown') return b0(tf)
}
function LA(e, t) {
  if (e === 'click') return b0(t)
}
function $A(e, t) {
  if (e === 'input' || e === 'change') return b0(t)
}
function FA(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var Pi = typeof Object.is == 'function' ? Object.is : FA
function nf(e, t) {
  if (Pi(e, t)) return !0
  if (typeof e != 'object' || e === null || typeof t != 'object' || t === null) return !1
  var n = Object.keys(e),
    r = Object.keys(t)
  if (n.length !== r.length) return !1
  for (r = 0; r < n.length; r++) {
    var i = n[r]
    if (!Km.call(t, i) || !Pi(e[i], t[i])) return !1
  }
  return !0
}
function dx(e) {
  for (; e && e.firstChild; ) e = e.firstChild
  return e
}
function hx(e, t) {
  var n = dx(e)
  e = 0
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = e + n.textContent.length), e <= t && r >= t)) return { node: n, offset: t - e }
      e = r
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling
          break e
        }
        n = n.parentNode
      }
      n = void 0
    }
    n = dx(n)
  }
}
function S3(e, t) {
  return e && t
    ? e === t
      ? !0
      : e && e.nodeType === 3
      ? !1
      : t && t.nodeType === 3
      ? S3(e, t.parentNode)
      : 'contains' in e
      ? e.contains(t)
      : e.compareDocumentPosition
      ? !!(e.compareDocumentPosition(t) & 16)
      : !1
    : !1
}
function E3() {
  for (var e = window, t = up(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == 'string'
    } catch {
      n = !1
    }
    if (n) e = t.contentWindow
    else break
    t = up(e.document)
  }
  return t
}
function $1(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return (
    t &&
    ((t === 'input' &&
      (e.type === 'text' ||
        e.type === 'search' ||
        e.type === 'tel' ||
        e.type === 'url' ||
        e.type === 'password')) ||
      t === 'textarea' ||
      e.contentEditable === 'true')
  )
}
function BA(e) {
  var t = E3(),
    n = e.focusedElem,
    r = e.selectionRange
  if (t !== n && n && n.ownerDocument && S3(n.ownerDocument.documentElement, n)) {
    if (r !== null && $1(n)) {
      if (((t = r.start), (e = r.end), e === void 0 && (e = t), 'selectionStart' in n))
        (n.selectionStart = t), (n.selectionEnd = Math.min(e, n.value.length))
      else if (
        ((e = ((t = n.ownerDocument || document) && t.defaultView) || window), e.getSelection)
      ) {
        e = e.getSelection()
        var i = n.textContent.length,
          s = Math.min(r.start, i)
        ;(r = r.end === void 0 ? s : Math.min(r.end, i)),
          !e.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = hx(n, s))
        var o = hx(n, r)
        i &&
          o &&
          (e.rangeCount !== 1 ||
            e.anchorNode !== i.node ||
            e.anchorOffset !== i.offset ||
            e.focusNode !== o.node ||
            e.focusOffset !== o.offset) &&
          ((t = t.createRange()),
          t.setStart(i.node, i.offset),
          e.removeAllRanges(),
          s > r
            ? (e.addRange(t), e.extend(o.node, o.offset))
            : (t.setEnd(o.node, o.offset), e.addRange(t)))
      }
    }
    for (t = [], e = n; (e = e.parentNode); )
      e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop })
    for (typeof n.focus == 'function' && n.focus(), n = 0; n < t.length; n++)
      (e = t[n]), (e.element.scrollLeft = e.left), (e.element.scrollTop = e.top)
  }
}
var UA = Ps && 'documentMode' in document && 11 >= document.documentMode,
  vl = null,
  dy = null,
  ju = null,
  hy = !1
function px(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument
  hy ||
    vl == null ||
    vl !== up(r) ||
    ((r = vl),
    'selectionStart' in r && $1(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = ((r.ownerDocument && r.ownerDocument.defaultView) || window).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (ju && nf(ju, r)) ||
      ((ju = r),
      (r = yp(dy, 'onSelect')),
      0 < r.length &&
        ((t = new M1('onSelect', 'select', null, t, n)),
        e.push({ event: t, listeners: r }),
        (t.target = vl))))
}
function wd(e, t) {
  var n = {}
  return (
    (n[e.toLowerCase()] = t.toLowerCase()),
    (n['Webkit' + e] = 'webkit' + t),
    (n['Moz' + e] = 'moz' + t),
    n
  )
}
var wl = {
    animationend: wd('Animation', 'AnimationEnd'),
    animationiteration: wd('Animation', 'AnimationIteration'),
    animationstart: wd('Animation', 'AnimationStart'),
    transitionend: wd('Transition', 'TransitionEnd'),
  },
  Dg = {},
  C3 = {}
Ps &&
  ((C3 = document.createElement('div').style),
  'AnimationEvent' in window ||
    (delete wl.animationend.animation,
    delete wl.animationiteration.animation,
    delete wl.animationstart.animation),
  'TransitionEvent' in window || delete wl.transitionend.transition)
function x0(e) {
  if (Dg[e]) return Dg[e]
  if (!wl[e]) return e
  var t = wl[e],
    n
  for (n in t) if (t.hasOwnProperty(n) && n in C3) return (Dg[e] = t[n])
  return e
}
var _3 = x0('animationend'),
  O3 = x0('animationiteration'),
  k3 = x0('animationstart'),
  T3 = x0('transitionend'),
  A3 = new Map(),
  gx =
    'abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
      ' '
    )
function Vo(e, t) {
  A3.set(e, t), Ha(t, [e])
}
for (var Ng = 0; Ng < gx.length; Ng++) {
  var Mg = gx[Ng],
    zA = Mg.toLowerCase(),
    WA = Mg[0].toUpperCase() + Mg.slice(1)
  Vo(zA, 'on' + WA)
}
Vo(_3, 'onAnimationEnd')
Vo(O3, 'onAnimationIteration')
Vo(k3, 'onAnimationStart')
Vo('dblclick', 'onDoubleClick')
Vo('focusin', 'onFocus')
Vo('focusout', 'onBlur')
Vo(T3, 'onTransitionEnd')
uc('onMouseEnter', ['mouseout', 'mouseover'])
uc('onMouseLeave', ['mouseout', 'mouseover'])
uc('onPointerEnter', ['pointerout', 'pointerover'])
uc('onPointerLeave', ['pointerout', 'pointerover'])
Ha('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' '))
Ha(
  'onSelect',
  'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(' ')
)
Ha('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste'])
Ha('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' '))
Ha('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' '))
Ha('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' '))
var vu =
    'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
      ' '
    ),
  VA = new Set('cancel close invalid load scroll toggle'.split(' ').concat(vu))
function mx(e, t, n) {
  var r = e.type || 'unknown-event'
  ;(e.currentTarget = n), z4(r, t, void 0, e), (e.currentTarget = null)
}
function R3(e, t) {
  t = (t & 4) !== 0
  for (var n = 0; n < e.length; n++) {
    var r = e[n],
      i = r.event
    r = r.listeners
    e: {
      var s = void 0
      if (t)
        for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o],
            l = a.instance,
            c = a.currentTarget
          if (((a = a.listener), l !== s && i.isPropagationStopped())) break e
          mx(i, a, c), (s = l)
        }
      else
        for (o = 0; o < r.length; o++) {
          if (
            ((a = r[o]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== s && i.isPropagationStopped())
          )
            break e
          mx(i, a, c), (s = l)
        }
    }
  }
  if (dp) throw ((e = ly), (dp = !1), (ly = null), e)
}
function It(e, t) {
  var n = t[vy]
  n === void 0 && (n = t[vy] = new Set())
  var r = e + '__bubble'
  n.has(r) || (P3(t, e, 2, !1), n.add(r))
}
function jg(e, t, n) {
  var r = 0
  t && (r |= 4), P3(n, e, r, t)
}
var bd = '_reactListening' + Math.random().toString(36).slice(2)
function rf(e) {
  if (!e[bd]) {
    ;(e[bd] = !0),
      $C.forEach(function (n) {
        n !== 'selectionchange' && (VA.has(n) || jg(n, !1, e), jg(n, !0, e))
      })
    var t = e.nodeType === 9 ? e : e.ownerDocument
    t === null || t[bd] || ((t[bd] = !0), jg('selectionchange', !1, t))
  }
}
function P3(e, t, n, r) {
  switch (p3(t)) {
    case 1:
      var i = iA
      break
    case 4:
      i = sA
      break
    default:
      i = D1
  }
  ;(n = i.bind(null, t, n, e)),
    (i = void 0),
    !ay || (t !== 'touchstart' && t !== 'touchmove' && t !== 'wheel') || (i = !0),
    r
      ? i !== void 0
        ? e.addEventListener(t, n, { capture: !0, passive: i })
        : e.addEventListener(t, n, !0)
      : i !== void 0
      ? e.addEventListener(t, n, { passive: i })
      : e.addEventListener(t, n, !1)
}
function Lg(e, t, n, r, i) {
  var s = r
  if (!(t & 1) && !(t & 2) && r !== null)
    e: for (;;) {
      if (r === null) return
      var o = r.tag
      if (o === 3 || o === 4) {
        var a = r.stateNode.containerInfo
        if (a === i || (a.nodeType === 8 && a.parentNode === i)) break
        if (o === 4)
          for (o = r.return; o !== null; ) {
            var l = o.tag
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo), l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return
            o = o.return
          }
        for (; a !== null; ) {
          if (((o = da(a)), o === null)) return
          if (((l = o.tag), l === 5 || l === 6)) {
            r = s = o
            continue e
          }
          a = a.parentNode
        }
      }
      r = r.return
    }
  e3(function () {
    var c = s,
      u = A1(n),
      f = []
    e: {
      var d = A3.get(e)
      if (d !== void 0) {
        var p = M1,
          h = e
        switch (e) {
          case 'keypress':
            if (ch(n) === 0) break e
          case 'keydown':
          case 'keyup':
            p = bA
            break
          case 'focusin':
            ;(h = 'focus'), (p = Rg)
            break
          case 'focusout':
            ;(h = 'blur'), (p = Rg)
            break
          case 'beforeblur':
          case 'afterblur':
            p = Rg
            break
          case 'click':
            if (n.button === 2) break e
          case 'auxclick':
          case 'dblclick':
          case 'mousedown':
          case 'mousemove':
          case 'mouseup':
          case 'mouseout':
          case 'mouseover':
          case 'contextmenu':
            p = ix
            break
          case 'drag':
          case 'dragend':
          case 'dragenter':
          case 'dragexit':
          case 'dragleave':
          case 'dragover':
          case 'dragstart':
          case 'drop':
            p = lA
            break
          case 'touchcancel':
          case 'touchend':
          case 'touchmove':
          case 'touchstart':
            p = EA
            break
          case _3:
          case O3:
          case k3:
            p = fA
            break
          case T3:
            p = _A
            break
          case 'scroll':
            p = oA
            break
          case 'wheel':
            p = kA
            break
          case 'copy':
          case 'cut':
          case 'paste':
            p = hA
            break
          case 'gotpointercapture':
          case 'lostpointercapture':
          case 'pointercancel':
          case 'pointerdown':
          case 'pointermove':
          case 'pointerout':
          case 'pointerover':
          case 'pointerup':
            p = ox
        }
        var m = (t & 4) !== 0,
          b = !m && e === 'scroll',
          y = m ? (d !== null ? d + 'Capture' : null) : d
        m = []
        for (var v = c, S; v !== null; ) {
          S = v
          var T = S.stateNode
          if (
            (S.tag === 5 &&
              T !== null &&
              ((S = T), y !== null && ((T = Xu(v, y)), T != null && m.push(sf(v, T, S)))),
            b)
          )
            break
          v = v.return
        }
        0 < m.length && ((d = new p(d, h, null, n, u)), f.push({ event: d, listeners: m }))
      }
    }
    if (!(t & 7)) {
      e: {
        if (
          ((d = e === 'mouseover' || e === 'pointerover'),
          (p = e === 'mouseout' || e === 'pointerout'),
          d && n !== sy && (h = n.relatedTarget || n.fromElement) && (da(h) || h[Is]))
        )
          break e
        if (
          (p || d) &&
          ((d =
            u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : window),
          p
            ? ((h = n.relatedTarget || n.toElement),
              (p = c),
              (h = h ? da(h) : null),
              h !== null && ((b = qa(h)), h !== b || (h.tag !== 5 && h.tag !== 6)) && (h = null))
            : ((p = null), (h = c)),
          p !== h)
        ) {
          if (
            ((m = ix),
            (T = 'onMouseLeave'),
            (y = 'onMouseEnter'),
            (v = 'mouse'),
            (e === 'pointerout' || e === 'pointerover') &&
              ((m = ox), (T = 'onPointerLeave'), (y = 'onPointerEnter'), (v = 'pointer')),
            (b = p == null ? d : bl(p)),
            (S = h == null ? d : bl(h)),
            (d = new m(T, v + 'leave', p, n, u)),
            (d.target = b),
            (d.relatedTarget = S),
            (T = null),
            da(u) === c &&
              ((m = new m(y, v + 'enter', h, n, u)),
              (m.target = S),
              (m.relatedTarget = b),
              (T = m)),
            (b = T),
            p && h)
          )
            t: {
              for (m = p, y = h, v = 0, S = m; S; S = Za(S)) v++
              for (S = 0, T = y; T; T = Za(T)) S++
              for (; 0 < v - S; ) (m = Za(m)), v--
              for (; 0 < S - v; ) (y = Za(y)), S--
              for (; v--; ) {
                if (m === y || (y !== null && m === y.alternate)) break t
                ;(m = Za(m)), (y = Za(y))
              }
              m = null
            }
          else m = null
          p !== null && yx(f, d, p, m, !1), h !== null && b !== null && yx(f, b, h, m, !0)
        }
      }
      e: {
        if (
          ((d = c ? bl(c) : window),
          (p = d.nodeName && d.nodeName.toLowerCase()),
          p === 'select' || (p === 'input' && d.type === 'file'))
        )
          var A = NA
        else if (cx(d))
          if (b3) A = $A
          else {
            A = jA
            var I = MA
          }
        else
          (p = d.nodeName) &&
            p.toLowerCase() === 'input' &&
            (d.type === 'checkbox' || d.type === 'radio') &&
            (A = LA)
        if (A && (A = A(e, c))) {
          w3(f, A, n, u)
          break e
        }
        I && I(e, d, c),
          e === 'focusout' &&
            (I = d._wrapperState) &&
            I.controlled &&
            d.type === 'number' &&
            ey(d, 'number', d.value)
      }
      switch (((I = c ? bl(c) : window), e)) {
        case 'focusin':
          ;(cx(I) || I.contentEditable === 'true') && ((vl = I), (dy = c), (ju = null))
          break
        case 'focusout':
          ju = dy = vl = null
          break
        case 'mousedown':
          hy = !0
          break
        case 'contextmenu':
        case 'mouseup':
        case 'dragend':
          ;(hy = !1), px(f, n, u)
          break
        case 'selectionchange':
          if (UA) break
        case 'keydown':
        case 'keyup':
          px(f, n, u)
      }
      var k
      if (L1)
        e: {
          switch (e) {
            case 'compositionstart':
              var D = 'onCompositionStart'
              break e
            case 'compositionend':
              D = 'onCompositionEnd'
              break e
            case 'compositionupdate':
              D = 'onCompositionUpdate'
              break e
          }
          D = void 0
        }
      else
        yl
          ? y3(e, n) && (D = 'onCompositionEnd')
          : e === 'keydown' && n.keyCode === 229 && (D = 'onCompositionStart')
      D &&
        (m3 &&
          n.locale !== 'ko' &&
          (yl || D !== 'onCompositionStart'
            ? D === 'onCompositionEnd' && yl && (k = g3())
            : ((Eo = u), (N1 = 'value' in Eo ? Eo.value : Eo.textContent), (yl = !0))),
        (I = yp(c, D)),
        0 < I.length &&
          ((D = new sx(D, e, null, n, u)),
          f.push({ event: D, listeners: I }),
          k ? (D.data = k) : ((k = v3(n)), k !== null && (D.data = k)))),
        (k = AA ? RA(e, n) : PA(e, n)) &&
          ((c = yp(c, 'onBeforeInput')),
          0 < c.length &&
            ((u = new sx('onBeforeInput', 'beforeinput', null, n, u)),
            f.push({ event: u, listeners: c }),
            (u.data = k)))
    }
    R3(f, t)
  })
}
function sf(e, t, n) {
  return { instance: e, listener: t, currentTarget: n }
}
function yp(e, t) {
  for (var n = t + 'Capture', r = []; e !== null; ) {
    var i = e,
      s = i.stateNode
    i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = Xu(e, n)),
      s != null && r.unshift(sf(e, s, i)),
      (s = Xu(e, t)),
      s != null && r.push(sf(e, s, i))),
      (e = e.return)
  }
  return r
}
function Za(e) {
  if (e === null) return null
  do e = e.return
  while (e && e.tag !== 5)
  return e || null
}
function yx(e, t, n, r, i) {
  for (var s = t._reactName, o = []; n !== null && n !== r; ) {
    var a = n,
      l = a.alternate,
      c = a.stateNode
    if (l !== null && l === r) break
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      i
        ? ((l = Xu(n, s)), l != null && o.unshift(sf(n, l, a)))
        : i || ((l = Xu(n, s)), l != null && o.push(sf(n, l, a)))),
      (n = n.return)
  }
  o.length !== 0 && e.push({ event: t, listeners: o })
}
var HA = /\r\n?/g,
  qA = /\u0000|\uFFFD/g
function vx(e) {
  return (typeof e == 'string' ? e : '' + e)
    .replace(
      HA,
      `
`
    )
    .replace(qA, '')
}
function xd(e, t, n) {
  if (((t = vx(t)), vx(e) !== t && n)) throw Error(ee(425))
}
function vp() {}
var py = null,
  gy = null
function my(e, t) {
  return (
    e === 'textarea' ||
    e === 'noscript' ||
    typeof t.children == 'string' ||
    typeof t.children == 'number' ||
    (typeof t.dangerouslySetInnerHTML == 'object' &&
      t.dangerouslySetInnerHTML !== null &&
      t.dangerouslySetInnerHTML.__html != null)
  )
}
var yy = typeof setTimeout == 'function' ? setTimeout : void 0,
  KA = typeof clearTimeout == 'function' ? clearTimeout : void 0,
  wx = typeof Promise == 'function' ? Promise : void 0,
  GA =
    typeof queueMicrotask == 'function'
      ? queueMicrotask
      : typeof wx < 'u'
      ? function (e) {
          return wx.resolve(null).then(e).catch(YA)
        }
      : yy
function YA(e) {
  setTimeout(function () {
    throw e
  })
}
function $g(e, t) {
  var n = t,
    r = 0
  do {
    var i = n.nextSibling
    if ((e.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === '/$')) {
        if (r === 0) {
          e.removeChild(i), ef(t)
          return
        }
        r--
      } else (n !== '$' && n !== '$?' && n !== '$!') || r++
    n = i
  } while (n)
  ef(t)
}
function To(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType
    if (t === 1 || t === 3) break
    if (t === 8) {
      if (((t = e.data), t === '$' || t === '$!' || t === '$?')) break
      if (t === '/$') return null
    }
  }
  return e
}
function bx(e) {
  e = e.previousSibling
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data
      if (n === '$' || n === '$!' || n === '$?') {
        if (t === 0) return e
        t--
      } else n === '/$' && t++
    }
    e = e.previousSibling
  }
  return null
}
var Mc = Math.random().toString(36).slice(2),
  Gi = '__reactFiber$' + Mc,
  of = '__reactProps$' + Mc,
  Is = '__reactContainer$' + Mc,
  vy = '__reactEvents$' + Mc,
  QA = '__reactListeners$' + Mc,
  XA = '__reactHandles$' + Mc
function da(e) {
  var t = e[Gi]
  if (t) return t
  for (var n = e.parentNode; n; ) {
    if ((t = n[Is] || n[Gi])) {
      if (((n = t.alternate), t.child !== null || (n !== null && n.child !== null)))
        for (e = bx(e); e !== null; ) {
          if ((n = e[Gi])) return n
          e = bx(e)
        }
      return t
    }
    ;(e = n), (n = e.parentNode)
  }
  return null
}
function Gf(e) {
  return (
    (e = e[Gi] || e[Is]),
    !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  )
}
function bl(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode
  throw Error(ee(33))
}
function S0(e) {
  return e[of] || null
}
var wy = [],
  xl = -1
function Ho(e) {
  return { current: e }
}
function Nt(e) {
  0 > xl || ((e.current = wy[xl]), (wy[xl] = null), xl--)
}
function Rt(e, t) {
  xl++, (wy[xl] = e.current), (e.current = t)
}
var $o = {},
  Fn = Ho($o),
  lr = Ho(!1),
  Na = $o
function fc(e, t) {
  var n = e.type.contextTypes
  if (!n) return $o
  var r = e.stateNode
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
    return r.__reactInternalMemoizedMaskedChildContext
  var i = {},
    s
  for (s in n) i[s] = t[s]
  return (
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = t),
      (e.__reactInternalMemoizedMaskedChildContext = i)),
    i
  )
}
function cr(e) {
  return (e = e.childContextTypes), e != null
}
function wp() {
  Nt(lr), Nt(Fn)
}
function xx(e, t, n) {
  if (Fn.current !== $o) throw Error(ee(168))
  Rt(Fn, t), Rt(lr, n)
}
function I3(e, t, n) {
  var r = e.stateNode
  if (((t = t.childContextTypes), typeof r.getChildContext != 'function')) return n
  r = r.getChildContext()
  for (var i in r) if (!(i in t)) throw Error(ee(108, M4(e) || 'Unknown', i))
  return Wt({}, n, r)
}
function bp(e) {
  return (
    (e = ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || $o),
    (Na = Fn.current),
    Rt(Fn, e),
    Rt(lr, lr.current),
    !0
  )
}
function Sx(e, t, n) {
  var r = e.stateNode
  if (!r) throw Error(ee(169))
  n
    ? ((e = I3(e, t, Na)),
      (r.__reactInternalMemoizedMergedChildContext = e),
      Nt(lr),
      Nt(Fn),
      Rt(Fn, e))
    : Nt(lr),
    Rt(lr, n)
}
var bs = null,
  E0 = !1,
  Fg = !1
function D3(e) {
  bs === null ? (bs = [e]) : bs.push(e)
}
function ZA(e) {
  ;(E0 = !0), D3(e)
}
function qo() {
  if (!Fg && bs !== null) {
    Fg = !0
    var e = 0,
      t = Tt
    try {
      var n = bs
      for (Tt = 1; e < n.length; e++) {
        var r = n[e]
        do r = r(!0)
        while (r !== null)
      }
      ;(bs = null), (E0 = !1)
    } catch (i) {
      throw (bs !== null && (bs = bs.slice(e + 1)), i3(R1, qo), i)
    } finally {
      ;(Tt = t), (Fg = !1)
    }
  }
  return null
}
var Sl = [],
  El = 0,
  xp = null,
  Sp = 0,
  Vr = [],
  Hr = 0,
  Ma = null,
  _s = 1,
  Os = ''
function ta(e, t) {
  ;(Sl[El++] = Sp), (Sl[El++] = xp), (xp = e), (Sp = t)
}
function N3(e, t, n) {
  ;(Vr[Hr++] = _s), (Vr[Hr++] = Os), (Vr[Hr++] = Ma), (Ma = e)
  var r = _s
  e = Os
  var i = 32 - Oi(r) - 1
  ;(r &= ~(1 << i)), (n += 1)
  var s = 32 - Oi(t) + i
  if (30 < s) {
    var o = i - (i % 5)
    ;(s = (r & ((1 << o) - 1)).toString(32)),
      (r >>= o),
      (i -= o),
      (_s = (1 << (32 - Oi(t) + i)) | (n << i) | r),
      (Os = s + e)
  } else (_s = (1 << s) | (n << i) | r), (Os = e)
}
function F1(e) {
  e.return !== null && (ta(e, 1), N3(e, 1, 0))
}
function B1(e) {
  for (; e === xp; ) (xp = Sl[--El]), (Sl[El] = null), (Sp = Sl[--El]), (Sl[El] = null)
  for (; e === Ma; )
    (Ma = Vr[--Hr]),
      (Vr[Hr] = null),
      (Os = Vr[--Hr]),
      (Vr[Hr] = null),
      (_s = Vr[--Hr]),
      (Vr[Hr] = null)
}
var Er = null,
  Sr = null,
  $t = !1,
  bi = null
function M3(e, t) {
  var n = Xr(5, null, null, 0)
  ;(n.elementType = 'DELETED'),
    (n.stateNode = t),
    (n.return = e),
    (t = e.deletions),
    t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)
}
function Ex(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type
      return (
        (t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t),
        t !== null ? ((e.stateNode = t), (Er = e), (Sr = To(t.firstChild)), !0) : !1
      )
    case 6:
      return (
        (t = e.pendingProps === '' || t.nodeType !== 3 ? null : t),
        t !== null ? ((e.stateNode = t), (Er = e), (Sr = null), !0) : !1
      )
    case 13:
      return (
        (t = t.nodeType !== 8 ? null : t),
        t !== null
          ? ((n = Ma !== null ? { id: _s, overflow: Os } : null),
            (e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }),
            (n = Xr(18, null, null, 0)),
            (n.stateNode = t),
            (n.return = e),
            (e.child = n),
            (Er = e),
            (Sr = null),
            !0)
          : !1
      )
    default:
      return !1
  }
}
function by(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function xy(e) {
  if ($t) {
    var t = Sr
    if (t) {
      var n = t
      if (!Ex(e, t)) {
        if (by(e)) throw Error(ee(418))
        t = To(n.nextSibling)
        var r = Er
        t && Ex(e, t) ? M3(r, n) : ((e.flags = (e.flags & -4097) | 2), ($t = !1), (Er = e))
      }
    } else {
      if (by(e)) throw Error(ee(418))
      ;(e.flags = (e.flags & -4097) | 2), ($t = !1), (Er = e)
    }
  }
}
function Cx(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; ) e = e.return
  Er = e
}
function Sd(e) {
  if (e !== Er) return !1
  if (!$t) return Cx(e), ($t = !0), !1
  var t
  if (
    ((t = e.tag !== 3) &&
      !(t = e.tag !== 5) &&
      ((t = e.type), (t = t !== 'head' && t !== 'body' && !my(e.type, e.memoizedProps))),
    t && (t = Sr))
  ) {
    if (by(e)) throw (j3(), Error(ee(418)))
    for (; t; ) M3(e, t), (t = To(t.nextSibling))
  }
  if ((Cx(e), e.tag === 13)) {
    if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e)) throw Error(ee(317))
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var n = e.data
          if (n === '/$') {
            if (t === 0) {
              Sr = To(e.nextSibling)
              break e
            }
            t--
          } else (n !== '$' && n !== '$!' && n !== '$?') || t++
        }
        e = e.nextSibling
      }
      Sr = null
    }
  } else Sr = Er ? To(e.stateNode.nextSibling) : null
  return !0
}
function j3() {
  for (var e = Sr; e; ) e = To(e.nextSibling)
}
function dc() {
  ;(Sr = Er = null), ($t = !1)
}
function U1(e) {
  bi === null ? (bi = [e]) : bi.push(e)
}
var JA = Fs.ReactCurrentBatchConfig
function pi(e, t) {
  if (e && e.defaultProps) {
    ;(t = Wt({}, t)), (e = e.defaultProps)
    for (var n in e) t[n] === void 0 && (t[n] = e[n])
    return t
  }
  return t
}
var Ep = Ho(null),
  Cp = null,
  Cl = null,
  z1 = null
function W1() {
  z1 = Cl = Cp = null
}
function V1(e) {
  var t = Ep.current
  Nt(Ep), (e._currentValue = t)
}
function Sy(e, t, n) {
  for (; e !== null; ) {
    var r = e.alternate
    if (
      ((e.childLanes & t) !== t
        ? ((e.childLanes |= t), r !== null && (r.childLanes |= t))
        : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
      e === n)
    )
      break
    e = e.return
  }
}
function $l(e, t) {
  ;(Cp = e),
    (z1 = Cl = null),
    (e = e.dependencies),
    e !== null && e.firstContext !== null && (e.lanes & t && (or = !0), (e.firstContext = null))
}
function ei(e) {
  var t = e._currentValue
  if (z1 !== e)
    if (((e = { context: e, memoizedValue: t, next: null }), Cl === null)) {
      if (Cp === null) throw Error(ee(308))
      ;(Cl = e), (Cp.dependencies = { lanes: 0, firstContext: e })
    } else Cl = Cl.next = e
  return t
}
var ha = null
function H1(e) {
  ha === null ? (ha = [e]) : ha.push(e)
}
function L3(e, t, n, r) {
  var i = t.interleaved
  return (
    i === null ? ((n.next = n), H1(t)) : ((n.next = i.next), (i.next = n)),
    (t.interleaved = n),
    Ds(e, r)
  )
}
function Ds(e, t) {
  e.lanes |= t
  var n = e.alternate
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; )
    (e.childLanes |= t),
      (n = e.alternate),
      n !== null && (n.childLanes |= t),
      (n = e),
      (e = e.return)
  return n.tag === 3 ? n.stateNode : null
}
var uo = !1
function q1(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  }
}
function $3(e, t) {
  ;(e = e.updateQueue),
    t.updateQueue === e &&
      (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects,
      })
}
function As(e, t) {
  return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null }
}
function Ao(e, t, n) {
  var r = e.updateQueue
  if (r === null) return null
  if (((r = r.shared), mt & 2)) {
    var i = r.pending
    return i === null ? (t.next = t) : ((t.next = i.next), (i.next = t)), (r.pending = t), Ds(e, n)
  }
  return (
    (i = r.interleaved),
    i === null ? ((t.next = t), H1(r)) : ((t.next = i.next), (i.next = t)),
    (r.interleaved = t),
    Ds(e, n)
  )
}
function uh(e, t, n) {
  if (((t = t.updateQueue), t !== null && ((t = t.shared), (n & 4194240) !== 0))) {
    var r = t.lanes
    ;(r &= e.pendingLanes), (n |= r), (t.lanes = n), P1(e, n)
  }
}
function _x(e, t) {
  var n = e.updateQueue,
    r = e.alternate
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      s = null
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var o = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        }
        s === null ? (i = s = o) : (s = s.next = o), (n = n.next)
      } while (n !== null)
      s === null ? (i = s = t) : (s = s.next = t)
    } else i = s = t
    ;(n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (e.updateQueue = n)
    return
  }
  ;(e = n.lastBaseUpdate),
    e === null ? (n.firstBaseUpdate = t) : (e.next = t),
    (n.lastBaseUpdate = t)
}
function _p(e, t, n, r) {
  var i = e.updateQueue
  uo = !1
  var s = i.firstBaseUpdate,
    o = i.lastBaseUpdate,
    a = i.shared.pending
  if (a !== null) {
    i.shared.pending = null
    var l = a,
      c = l.next
    ;(l.next = null), o === null ? (s = c) : (o.next = c), (o = l)
    var u = e.alternate
    u !== null &&
      ((u = u.updateQueue),
      (a = u.lastBaseUpdate),
      a !== o && (a === null ? (u.firstBaseUpdate = c) : (a.next = c), (u.lastBaseUpdate = l)))
  }
  if (s !== null) {
    var f = i.baseState
    ;(o = 0), (u = c = l = null), (a = s)
    do {
      var d = a.lane,
        p = a.eventTime
      if ((r & d) === d) {
        u !== null &&
          (u = u.next =
            {
              eventTime: p,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            })
        e: {
          var h = e,
            m = a
          switch (((d = t), (p = n), m.tag)) {
            case 1:
              if (((h = m.payload), typeof h == 'function')) {
                f = h.call(p, f, d)
                break e
              }
              f = h
              break e
            case 3:
              h.flags = (h.flags & -65537) | 128
            case 0:
              if (((h = m.payload), (d = typeof h == 'function' ? h.call(p, f, d) : h), d == null))
                break e
              f = Wt({}, f, d)
              break e
            case 2:
              uo = !0
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((e.flags |= 64), (d = i.effects), d === null ? (i.effects = [a]) : d.push(a))
      } else
        (p = {
          eventTime: p,
          lane: d,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          u === null ? ((c = u = p), (l = f)) : (u = u.next = p),
          (o |= d)
      if (((a = a.next), a === null)) {
        if (((a = i.shared.pending), a === null)) break
        ;(d = a), (a = d.next), (d.next = null), (i.lastBaseUpdate = d), (i.shared.pending = null)
      }
    } while (1)
    if (
      (u === null && (l = f),
      (i.baseState = l),
      (i.firstBaseUpdate = c),
      (i.lastBaseUpdate = u),
      (t = i.shared.interleaved),
      t !== null)
    ) {
      i = t
      do (o |= i.lane), (i = i.next)
      while (i !== t)
    } else s === null && (i.shared.lanes = 0)
    ;(La |= o), (e.lanes = o), (e.memoizedState = f)
  }
}
function Ox(e, t, n) {
  if (((e = t.effects), (t.effects = null), e !== null))
    for (t = 0; t < e.length; t++) {
      var r = e[t],
        i = r.callback
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != 'function')) throw Error(ee(191, i))
        i.call(r)
      }
    }
}
var F3 = new LC.Component().refs
function Ey(e, t, n, r) {
  ;(t = e.memoizedState),
    (n = n(r, t)),
    (n = n == null ? t : Wt({}, t, n)),
    (e.memoizedState = n),
    e.lanes === 0 && (e.updateQueue.baseState = n)
}
var C0 = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? qa(e) === e : !1
  },
  enqueueSetState: function (e, t, n) {
    e = e._reactInternals
    var r = Kn(),
      i = Po(e),
      s = As(r, i)
    ;(s.payload = t),
      n != null && (s.callback = n),
      (t = Ao(e, s, i)),
      t !== null && (ki(t, e, i, r), uh(t, e, i))
  },
  enqueueReplaceState: function (e, t, n) {
    e = e._reactInternals
    var r = Kn(),
      i = Po(e),
      s = As(r, i)
    ;(s.tag = 1),
      (s.payload = t),
      n != null && (s.callback = n),
      (t = Ao(e, s, i)),
      t !== null && (ki(t, e, i, r), uh(t, e, i))
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals
    var n = Kn(),
      r = Po(e),
      i = As(n, r)
    ;(i.tag = 2),
      t != null && (i.callback = t),
      (t = Ao(e, i, r)),
      t !== null && (ki(t, e, r, n), uh(t, e, r))
  },
}
function kx(e, t, n, r, i, s, o) {
  return (
    (e = e.stateNode),
    typeof e.shouldComponentUpdate == 'function'
      ? e.shouldComponentUpdate(r, s, o)
      : t.prototype && t.prototype.isPureReactComponent
      ? !nf(n, r) || !nf(i, s)
      : !0
  )
}
function B3(e, t, n) {
  var r = !1,
    i = $o,
    s = t.contextType
  return (
    typeof s == 'object' && s !== null
      ? (s = ei(s))
      : ((i = cr(t) ? Na : Fn.current),
        (r = t.contextTypes),
        (s = (r = r != null) ? fc(e, i) : $o)),
    (t = new t(n, s)),
    (e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null),
    (t.updater = C0),
    (e.stateNode = t),
    (t._reactInternals = e),
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = i),
      (e.__reactInternalMemoizedMaskedChildContext = s)),
    t
  )
}
function Tx(e, t, n, r) {
  ;(e = t.state),
    typeof t.componentWillReceiveProps == 'function' && t.componentWillReceiveProps(n, r),
    typeof t.UNSAFE_componentWillReceiveProps == 'function' &&
      t.UNSAFE_componentWillReceiveProps(n, r),
    t.state !== e && C0.enqueueReplaceState(t, t.state, null)
}
function Cy(e, t, n, r) {
  var i = e.stateNode
  ;(i.props = n), (i.state = e.memoizedState), (i.refs = F3), q1(e)
  var s = t.contextType
  typeof s == 'object' && s !== null
    ? (i.context = ei(s))
    : ((s = cr(t) ? Na : Fn.current), (i.context = fc(e, s))),
    (i.state = e.memoizedState),
    (s = t.getDerivedStateFromProps),
    typeof s == 'function' && (Ey(e, t, s, n), (i.state = e.memoizedState)),
    typeof t.getDerivedStateFromProps == 'function' ||
      typeof i.getSnapshotBeforeUpdate == 'function' ||
      (typeof i.UNSAFE_componentWillMount != 'function' &&
        typeof i.componentWillMount != 'function') ||
      ((t = i.state),
      typeof i.componentWillMount == 'function' && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == 'function' && i.UNSAFE_componentWillMount(),
      t !== i.state && C0.enqueueReplaceState(i, i.state, null),
      _p(e, n, i, r),
      (i.state = e.memoizedState)),
    typeof i.componentDidMount == 'function' && (e.flags |= 4194308)
}
function tu(e, t, n) {
  if (((e = n.ref), e !== null && typeof e != 'function' && typeof e != 'object')) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(ee(309))
        var r = n.stateNode
      }
      if (!r) throw Error(ee(147, e))
      var i = r,
        s = '' + e
      return t !== null && t.ref !== null && typeof t.ref == 'function' && t.ref._stringRef === s
        ? t.ref
        : ((t = function (o) {
            var a = i.refs
            a === F3 && (a = i.refs = {}), o === null ? delete a[s] : (a[s] = o)
          }),
          (t._stringRef = s),
          t)
    }
    if (typeof e != 'string') throw Error(ee(284))
    if (!n._owner) throw Error(ee(290, e))
  }
  return e
}
function Ed(e, t) {
  throw (
    ((e = Object.prototype.toString.call(t)),
    Error(
      ee(31, e === '[object Object]' ? 'object with keys {' + Object.keys(t).join(', ') + '}' : e)
    ))
  )
}
function Ax(e) {
  var t = e._init
  return t(e._payload)
}
function U3(e) {
  function t(y, v) {
    if (e) {
      var S = y.deletions
      S === null ? ((y.deletions = [v]), (y.flags |= 16)) : S.push(v)
    }
  }
  function n(y, v) {
    if (!e) return null
    for (; v !== null; ) t(y, v), (v = v.sibling)
    return null
  }
  function r(y, v) {
    for (y = new Map(); v !== null; )
      v.key !== null ? y.set(v.key, v) : y.set(v.index, v), (v = v.sibling)
    return y
  }
  function i(y, v) {
    return (y = Io(y, v)), (y.index = 0), (y.sibling = null), y
  }
  function s(y, v, S) {
    return (
      (y.index = S),
      e
        ? ((S = y.alternate),
          S !== null ? ((S = S.index), S < v ? ((y.flags |= 2), v) : S) : ((y.flags |= 2), v))
        : ((y.flags |= 1048576), v)
    )
  }
  function o(y) {
    return e && y.alternate === null && (y.flags |= 2), y
  }
  function a(y, v, S, T) {
    return v === null || v.tag !== 6
      ? ((v = qg(S, y.mode, T)), (v.return = y), v)
      : ((v = i(v, S)), (v.return = y), v)
  }
  function l(y, v, S, T) {
    var A = S.type
    return A === ml
      ? u(y, v, S.props.children, T, S.key)
      : v !== null &&
        (v.elementType === A ||
          (typeof A == 'object' && A !== null && A.$$typeof === co && Ax(A) === v.type))
      ? ((T = i(v, S.props)), (T.ref = tu(y, v, S)), (T.return = y), T)
      : ((T = mh(S.type, S.key, S.props, null, y.mode, T)),
        (T.ref = tu(y, v, S)),
        (T.return = y),
        T)
  }
  function c(y, v, S, T) {
    return v === null ||
      v.tag !== 4 ||
      v.stateNode.containerInfo !== S.containerInfo ||
      v.stateNode.implementation !== S.implementation
      ? ((v = Kg(S, y.mode, T)), (v.return = y), v)
      : ((v = i(v, S.children || [])), (v.return = y), v)
  }
  function u(y, v, S, T, A) {
    return v === null || v.tag !== 7
      ? ((v = Ta(S, y.mode, T, A)), (v.return = y), v)
      : ((v = i(v, S)), (v.return = y), v)
  }
  function f(y, v, S) {
    if ((typeof v == 'string' && v !== '') || typeof v == 'number')
      return (v = qg('' + v, y.mode, S)), (v.return = y), v
    if (typeof v == 'object' && v !== null) {
      switch (v.$$typeof) {
        case dd:
          return (
            (S = mh(v.type, v.key, v.props, null, y.mode, S)),
            (S.ref = tu(y, null, v)),
            (S.return = y),
            S
          )
        case gl:
          return (v = Kg(v, y.mode, S)), (v.return = y), v
        case co:
          var T = v._init
          return f(y, T(v._payload), S)
      }
      if (mu(v) || Qc(v)) return (v = Ta(v, y.mode, S, null)), (v.return = y), v
      Ed(y, v)
    }
    return null
  }
  function d(y, v, S, T) {
    var A = v !== null ? v.key : null
    if ((typeof S == 'string' && S !== '') || typeof S == 'number')
      return A !== null ? null : a(y, v, '' + S, T)
    if (typeof S == 'object' && S !== null) {
      switch (S.$$typeof) {
        case dd:
          return S.key === A ? l(y, v, S, T) : null
        case gl:
          return S.key === A ? c(y, v, S, T) : null
        case co:
          return (A = S._init), d(y, v, A(S._payload), T)
      }
      if (mu(S) || Qc(S)) return A !== null ? null : u(y, v, S, T, null)
      Ed(y, S)
    }
    return null
  }
  function p(y, v, S, T, A) {
    if ((typeof T == 'string' && T !== '') || typeof T == 'number')
      return (y = y.get(S) || null), a(v, y, '' + T, A)
    if (typeof T == 'object' && T !== null) {
      switch (T.$$typeof) {
        case dd:
          return (y = y.get(T.key === null ? S : T.key) || null), l(v, y, T, A)
        case gl:
          return (y = y.get(T.key === null ? S : T.key) || null), c(v, y, T, A)
        case co:
          var I = T._init
          return p(y, v, S, I(T._payload), A)
      }
      if (mu(T) || Qc(T)) return (y = y.get(S) || null), u(v, y, T, A, null)
      Ed(v, T)
    }
    return null
  }
  function h(y, v, S, T) {
    for (var A = null, I = null, k = v, D = (v = 0), F = null; k !== null && D < S.length; D++) {
      k.index > D ? ((F = k), (k = null)) : (F = k.sibling)
      var V = d(y, k, S[D], T)
      if (V === null) {
        k === null && (k = F)
        break
      }
      e && k && V.alternate === null && t(y, k),
        (v = s(V, v, D)),
        I === null ? (A = V) : (I.sibling = V),
        (I = V),
        (k = F)
    }
    if (D === S.length) return n(y, k), $t && ta(y, D), A
    if (k === null) {
      for (; D < S.length; D++)
        (k = f(y, S[D], T)),
          k !== null && ((v = s(k, v, D)), I === null ? (A = k) : (I.sibling = k), (I = k))
      return $t && ta(y, D), A
    }
    for (k = r(y, k); D < S.length; D++)
      (F = p(k, y, D, S[D], T)),
        F !== null &&
          (e && F.alternate !== null && k.delete(F.key === null ? D : F.key),
          (v = s(F, v, D)),
          I === null ? (A = F) : (I.sibling = F),
          (I = F))
    return (
      e &&
        k.forEach(function (ie) {
          return t(y, ie)
        }),
      $t && ta(y, D),
      A
    )
  }
  function m(y, v, S, T) {
    var A = Qc(S)
    if (typeof A != 'function') throw Error(ee(150))
    if (((S = A.call(S)), S == null)) throw Error(ee(151))
    for (
      var I = (A = null), k = v, D = (v = 0), F = null, V = S.next();
      k !== null && !V.done;
      D++, V = S.next()
    ) {
      k.index > D ? ((F = k), (k = null)) : (F = k.sibling)
      var ie = d(y, k, V.value, T)
      if (ie === null) {
        k === null && (k = F)
        break
      }
      e && k && ie.alternate === null && t(y, k),
        (v = s(ie, v, D)),
        I === null ? (A = ie) : (I.sibling = ie),
        (I = ie),
        (k = F)
    }
    if (V.done) return n(y, k), $t && ta(y, D), A
    if (k === null) {
      for (; !V.done; D++, V = S.next())
        (V = f(y, V.value, T)),
          V !== null && ((v = s(V, v, D)), I === null ? (A = V) : (I.sibling = V), (I = V))
      return $t && ta(y, D), A
    }
    for (k = r(y, k); !V.done; D++, V = S.next())
      (V = p(k, y, D, V.value, T)),
        V !== null &&
          (e && V.alternate !== null && k.delete(V.key === null ? D : V.key),
          (v = s(V, v, D)),
          I === null ? (A = V) : (I.sibling = V),
          (I = V))
    return (
      e &&
        k.forEach(function (de) {
          return t(y, de)
        }),
      $t && ta(y, D),
      A
    )
  }
  function b(y, v, S, T) {
    if (
      (typeof S == 'object' &&
        S !== null &&
        S.type === ml &&
        S.key === null &&
        (S = S.props.children),
      typeof S == 'object' && S !== null)
    ) {
      switch (S.$$typeof) {
        case dd:
          e: {
            for (var A = S.key, I = v; I !== null; ) {
              if (I.key === A) {
                if (((A = S.type), A === ml)) {
                  if (I.tag === 7) {
                    n(y, I.sibling), (v = i(I, S.props.children)), (v.return = y), (y = v)
                    break e
                  }
                } else if (
                  I.elementType === A ||
                  (typeof A == 'object' && A !== null && A.$$typeof === co && Ax(A) === I.type)
                ) {
                  n(y, I.sibling),
                    (v = i(I, S.props)),
                    (v.ref = tu(y, I, S)),
                    (v.return = y),
                    (y = v)
                  break e
                }
                n(y, I)
                break
              } else t(y, I)
              I = I.sibling
            }
            S.type === ml
              ? ((v = Ta(S.props.children, y.mode, T, S.key)), (v.return = y), (y = v))
              : ((T = mh(S.type, S.key, S.props, null, y.mode, T)),
                (T.ref = tu(y, v, S)),
                (T.return = y),
                (y = T))
          }
          return o(y)
        case gl:
          e: {
            for (I = S.key; v !== null; ) {
              if (v.key === I)
                if (
                  v.tag === 4 &&
                  v.stateNode.containerInfo === S.containerInfo &&
                  v.stateNode.implementation === S.implementation
                ) {
                  n(y, v.sibling), (v = i(v, S.children || [])), (v.return = y), (y = v)
                  break e
                } else {
                  n(y, v)
                  break
                }
              else t(y, v)
              v = v.sibling
            }
            ;(v = Kg(S, y.mode, T)), (v.return = y), (y = v)
          }
          return o(y)
        case co:
          return (I = S._init), b(y, v, I(S._payload), T)
      }
      if (mu(S)) return h(y, v, S, T)
      if (Qc(S)) return m(y, v, S, T)
      Ed(y, S)
    }
    return (typeof S == 'string' && S !== '') || typeof S == 'number'
      ? ((S = '' + S),
        v !== null && v.tag === 6
          ? (n(y, v.sibling), (v = i(v, S)), (v.return = y), (y = v))
          : (n(y, v), (v = qg(S, y.mode, T)), (v.return = y), (y = v)),
        o(y))
      : n(y, v)
  }
  return b
}
var hc = U3(!0),
  z3 = U3(!1),
  Yf = {},
  es = Ho(Yf),
  af = Ho(Yf),
  lf = Ho(Yf)
function pa(e) {
  if (e === Yf) throw Error(ee(174))
  return e
}
function K1(e, t) {
  switch ((Rt(lf, t), Rt(af, e), Rt(es, Yf), (e = t.nodeType), e)) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : ny(null, '')
      break
    default:
      ;(e = e === 8 ? t.parentNode : t),
        (t = e.namespaceURI || null),
        (e = e.tagName),
        (t = ny(t, e))
  }
  Nt(es), Rt(es, t)
}
function pc() {
  Nt(es), Nt(af), Nt(lf)
}
function W3(e) {
  pa(lf.current)
  var t = pa(es.current),
    n = ny(t, e.type)
  t !== n && (Rt(af, e), Rt(es, n))
}
function G1(e) {
  af.current === e && (Nt(es), Nt(af))
}
var Ut = Ho(0)
function Op(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState
      if (n !== null && ((n = n.dehydrated), n === null || n.data === '$?' || n.data === '$!'))
        return t
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t
    } else if (t.child !== null) {
      ;(t.child.return = t), (t = t.child)
      continue
    }
    if (t === e) break
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null
      t = t.return
    }
    ;(t.sibling.return = t.return), (t = t.sibling)
  }
  return null
}
var Bg = []
function Y1() {
  for (var e = 0; e < Bg.length; e++) Bg[e]._workInProgressVersionPrimary = null
  Bg.length = 0
}
var fh = Fs.ReactCurrentDispatcher,
  Ug = Fs.ReactCurrentBatchConfig,
  ja = 0,
  zt = null,
  dn = null,
  wn = null,
  kp = !1,
  Lu = !1,
  cf = 0,
  eR = 0
function In() {
  throw Error(ee(321))
}
function Q1(e, t) {
  if (t === null) return !1
  for (var n = 0; n < t.length && n < e.length; n++) if (!Pi(e[n], t[n])) return !1
  return !0
}
function X1(e, t, n, r, i, s) {
  if (
    ((ja = s),
    (zt = t),
    (t.memoizedState = null),
    (t.updateQueue = null),
    (t.lanes = 0),
    (fh.current = e === null || e.memoizedState === null ? iR : sR),
    (e = n(r, i)),
    Lu)
  ) {
    s = 0
    do {
      if (((Lu = !1), (cf = 0), 25 <= s)) throw Error(ee(301))
      ;(s += 1), (wn = dn = null), (t.updateQueue = null), (fh.current = oR), (e = n(r, i))
    } while (Lu)
  }
  if (
    ((fh.current = Tp),
    (t = dn !== null && dn.next !== null),
    (ja = 0),
    (wn = dn = zt = null),
    (kp = !1),
    t)
  )
    throw Error(ee(300))
  return e
}
function Z1() {
  var e = cf !== 0
  return (cf = 0), e
}
function Ui() {
  var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
  return wn === null ? (zt.memoizedState = wn = e) : (wn = wn.next = e), wn
}
function ti() {
  if (dn === null) {
    var e = zt.alternate
    e = e !== null ? e.memoizedState : null
  } else e = dn.next
  var t = wn === null ? zt.memoizedState : wn.next
  if (t !== null) (wn = t), (dn = e)
  else {
    if (e === null) throw Error(ee(310))
    ;(dn = e),
      (e = {
        memoizedState: dn.memoizedState,
        baseState: dn.baseState,
        baseQueue: dn.baseQueue,
        queue: dn.queue,
        next: null,
      }),
      wn === null ? (zt.memoizedState = wn = e) : (wn = wn.next = e)
  }
  return wn
}
function uf(e, t) {
  return typeof t == 'function' ? t(e) : t
}
function zg(e) {
  var t = ti(),
    n = t.queue
  if (n === null) throw Error(ee(311))
  n.lastRenderedReducer = e
  var r = dn,
    i = r.baseQueue,
    s = n.pending
  if (s !== null) {
    if (i !== null) {
      var o = i.next
      ;(i.next = s.next), (s.next = o)
    }
    ;(r.baseQueue = i = s), (n.pending = null)
  }
  if (i !== null) {
    ;(s = i.next), (r = r.baseState)
    var a = (o = null),
      l = null,
      c = s
    do {
      var u = c.lane
      if ((ja & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (r = c.hasEagerState ? c.eagerState : e(r, c.action))
      else {
        var f = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        }
        l === null ? ((a = l = f), (o = r)) : (l = l.next = f), (zt.lanes |= u), (La |= u)
      }
      c = c.next
    } while (c !== null && c !== s)
    l === null ? (o = r) : (l.next = a),
      Pi(r, t.memoizedState) || (or = !0),
      (t.memoizedState = r),
      (t.baseState = o),
      (t.baseQueue = l),
      (n.lastRenderedState = r)
  }
  if (((e = n.interleaved), e !== null)) {
    i = e
    do (s = i.lane), (zt.lanes |= s), (La |= s), (i = i.next)
    while (i !== e)
  } else i === null && (n.lanes = 0)
  return [t.memoizedState, n.dispatch]
}
function Wg(e) {
  var t = ti(),
    n = t.queue
  if (n === null) throw Error(ee(311))
  n.lastRenderedReducer = e
  var r = n.dispatch,
    i = n.pending,
    s = t.memoizedState
  if (i !== null) {
    n.pending = null
    var o = (i = i.next)
    do (s = e(s, o.action)), (o = o.next)
    while (o !== i)
    Pi(s, t.memoizedState) || (or = !0),
      (t.memoizedState = s),
      t.baseQueue === null && (t.baseState = s),
      (n.lastRenderedState = s)
  }
  return [s, r]
}
function V3() {}
function H3(e, t) {
  var n = zt,
    r = ti(),
    i = t(),
    s = !Pi(r.memoizedState, i)
  if (
    (s && ((r.memoizedState = i), (or = !0)),
    (r = r.queue),
    J1(G3.bind(null, n, r, e), [e]),
    r.getSnapshot !== t || s || (wn !== null && wn.memoizedState.tag & 1))
  ) {
    if (((n.flags |= 2048), ff(9, K3.bind(null, n, r, i, t), void 0, null), Sn === null))
      throw Error(ee(349))
    ja & 30 || q3(n, t, i)
  }
  return i
}
function q3(e, t, n) {
  ;(e.flags |= 16384),
    (e = { getSnapshot: t, value: n }),
    (t = zt.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }), (zt.updateQueue = t), (t.stores = [e]))
      : ((n = t.stores), n === null ? (t.stores = [e]) : n.push(e))
}
function K3(e, t, n, r) {
  ;(t.value = n), (t.getSnapshot = r), Y3(t) && Q3(e)
}
function G3(e, t, n) {
  return n(function () {
    Y3(t) && Q3(e)
  })
}
function Y3(e) {
  var t = e.getSnapshot
  e = e.value
  try {
    var n = t()
    return !Pi(e, n)
  } catch {
    return !0
  }
}
function Q3(e) {
  var t = Ds(e, 1)
  t !== null && ki(t, e, 1, -1)
}
function Rx(e) {
  var t = Ui()
  return (
    typeof e == 'function' && (e = e()),
    (t.memoizedState = t.baseState = e),
    (e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: uf,
      lastRenderedState: e,
    }),
    (t.queue = e),
    (e = e.dispatch = rR.bind(null, zt, e)),
    [t.memoizedState, e]
  )
}
function ff(e, t, n, r) {
  return (
    (e = { tag: e, create: t, destroy: n, deps: r, next: null }),
    (t = zt.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (zt.updateQueue = t),
        (t.lastEffect = e.next = e))
      : ((n = t.lastEffect),
        n === null
          ? (t.lastEffect = e.next = e)
          : ((r = n.next), (n.next = e), (e.next = r), (t.lastEffect = e))),
    e
  )
}
function X3() {
  return ti().memoizedState
}
function dh(e, t, n, r) {
  var i = Ui()
  ;(zt.flags |= e), (i.memoizedState = ff(1 | t, n, void 0, r === void 0 ? null : r))
}
function _0(e, t, n, r) {
  var i = ti()
  r = r === void 0 ? null : r
  var s = void 0
  if (dn !== null) {
    var o = dn.memoizedState
    if (((s = o.destroy), r !== null && Q1(r, o.deps))) {
      i.memoizedState = ff(t, n, s, r)
      return
    }
  }
  ;(zt.flags |= e), (i.memoizedState = ff(1 | t, n, s, r))
}
function Px(e, t) {
  return dh(8390656, 8, e, t)
}
function J1(e, t) {
  return _0(2048, 8, e, t)
}
function Z3(e, t) {
  return _0(4, 2, e, t)
}
function J3(e, t) {
  return _0(4, 4, e, t)
}
function e5(e, t) {
  if (typeof t == 'function')
    return (
      (e = e()),
      t(e),
      function () {
        t(null)
      }
    )
  if (t != null)
    return (
      (e = e()),
      (t.current = e),
      function () {
        t.current = null
      }
    )
}
function t5(e, t, n) {
  return (n = n != null ? n.concat([e]) : null), _0(4, 4, e5.bind(null, t, e), n)
}
function ew() {}
function n5(e, t) {
  var n = ti()
  t = t === void 0 ? null : t
  var r = n.memoizedState
  return r !== null && t !== null && Q1(t, r[1]) ? r[0] : ((n.memoizedState = [e, t]), e)
}
function r5(e, t) {
  var n = ti()
  t = t === void 0 ? null : t
  var r = n.memoizedState
  return r !== null && t !== null && Q1(t, r[1]) ? r[0] : ((e = e()), (n.memoizedState = [e, t]), e)
}
function i5(e, t, n) {
  return ja & 21
    ? (Pi(n, t) || ((n = a3()), (zt.lanes |= n), (La |= n), (e.baseState = !0)), t)
    : (e.baseState && ((e.baseState = !1), (or = !0)), (e.memoizedState = n))
}
function tR(e, t) {
  var n = Tt
  ;(Tt = n !== 0 && 4 > n ? n : 4), e(!0)
  var r = Ug.transition
  Ug.transition = {}
  try {
    e(!1), t()
  } finally {
    ;(Tt = n), (Ug.transition = r)
  }
}
function s5() {
  return ti().memoizedState
}
function nR(e, t, n) {
  var r = Po(e)
  if (((n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }), o5(e)))
    a5(t, n)
  else if (((n = L3(e, t, n, r)), n !== null)) {
    var i = Kn()
    ki(n, e, r, i), l5(n, t, r)
  }
}
function rR(e, t, n) {
  var r = Po(e),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }
  if (o5(e)) a5(t, i)
  else {
    var s = e.alternate
    if (e.lanes === 0 && (s === null || s.lanes === 0) && ((s = t.lastRenderedReducer), s !== null))
      try {
        var o = t.lastRenderedState,
          a = s(o, n)
        if (((i.hasEagerState = !0), (i.eagerState = a), Pi(a, o))) {
          var l = t.interleaved
          l === null ? ((i.next = i), H1(t)) : ((i.next = l.next), (l.next = i)),
            (t.interleaved = i)
          return
        }
      } catch {
      } finally {
      }
    ;(n = L3(e, t, i, r)), n !== null && ((i = Kn()), ki(n, e, r, i), l5(n, t, r))
  }
}
function o5(e) {
  var t = e.alternate
  return e === zt || (t !== null && t === zt)
}
function a5(e, t) {
  Lu = kp = !0
  var n = e.pending
  n === null ? (t.next = t) : ((t.next = n.next), (n.next = t)), (e.pending = t)
}
function l5(e, t, n) {
  if (n & 4194240) {
    var r = t.lanes
    ;(r &= e.pendingLanes), (n |= r), (t.lanes = n), P1(e, n)
  }
}
var Tp = {
    readContext: ei,
    useCallback: In,
    useContext: In,
    useEffect: In,
    useImperativeHandle: In,
    useInsertionEffect: In,
    useLayoutEffect: In,
    useMemo: In,
    useReducer: In,
    useRef: In,
    useState: In,
    useDebugValue: In,
    useDeferredValue: In,
    useTransition: In,
    useMutableSource: In,
    useSyncExternalStore: In,
    useId: In,
    unstable_isNewReconciler: !1,
  },
  iR = {
    readContext: ei,
    useCallback: function (e, t) {
      return (Ui().memoizedState = [e, t === void 0 ? null : t]), e
    },
    useContext: ei,
    useEffect: Px,
    useImperativeHandle: function (e, t, n) {
      return (n = n != null ? n.concat([e]) : null), dh(4194308, 4, e5.bind(null, t, e), n)
    },
    useLayoutEffect: function (e, t) {
      return dh(4194308, 4, e, t)
    },
    useInsertionEffect: function (e, t) {
      return dh(4, 2, e, t)
    },
    useMemo: function (e, t) {
      var n = Ui()
      return (t = t === void 0 ? null : t), (e = e()), (n.memoizedState = [e, t]), e
    },
    useReducer: function (e, t, n) {
      var r = Ui()
      return (
        (t = n !== void 0 ? n(t) : t),
        (r.memoizedState = r.baseState = t),
        (e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t,
        }),
        (r.queue = e),
        (e = e.dispatch = nR.bind(null, zt, e)),
        [r.memoizedState, e]
      )
    },
    useRef: function (e) {
      var t = Ui()
      return (e = { current: e }), (t.memoizedState = e)
    },
    useState: Rx,
    useDebugValue: ew,
    useDeferredValue: function (e) {
      return (Ui().memoizedState = e)
    },
    useTransition: function () {
      var e = Rx(!1),
        t = e[0]
      return (e = tR.bind(null, e[1])), (Ui().memoizedState = e), [t, e]
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, n) {
      var r = zt,
        i = Ui()
      if ($t) {
        if (n === void 0) throw Error(ee(407))
        n = n()
      } else {
        if (((n = t()), Sn === null)) throw Error(ee(349))
        ja & 30 || q3(r, t, n)
      }
      i.memoizedState = n
      var s = { value: n, getSnapshot: t }
      return (
        (i.queue = s),
        Px(G3.bind(null, r, s, e), [e]),
        (r.flags |= 2048),
        ff(9, K3.bind(null, r, s, n, t), void 0, null),
        n
      )
    },
    useId: function () {
      var e = Ui(),
        t = Sn.identifierPrefix
      if ($t) {
        var n = Os,
          r = _s
        ;(n = (r & ~(1 << (32 - Oi(r) - 1))).toString(32) + n),
          (t = ':' + t + 'R' + n),
          (n = cf++),
          0 < n && (t += 'H' + n.toString(32)),
          (t += ':')
      } else (n = eR++), (t = ':' + t + 'r' + n.toString(32) + ':')
      return (e.memoizedState = t)
    },
    unstable_isNewReconciler: !1,
  },
  sR = {
    readContext: ei,
    useCallback: n5,
    useContext: ei,
    useEffect: J1,
    useImperativeHandle: t5,
    useInsertionEffect: Z3,
    useLayoutEffect: J3,
    useMemo: r5,
    useReducer: zg,
    useRef: X3,
    useState: function () {
      return zg(uf)
    },
    useDebugValue: ew,
    useDeferredValue: function (e) {
      var t = ti()
      return i5(t, dn.memoizedState, e)
    },
    useTransition: function () {
      var e = zg(uf)[0],
        t = ti().memoizedState
      return [e, t]
    },
    useMutableSource: V3,
    useSyncExternalStore: H3,
    useId: s5,
    unstable_isNewReconciler: !1,
  },
  oR = {
    readContext: ei,
    useCallback: n5,
    useContext: ei,
    useEffect: J1,
    useImperativeHandle: t5,
    useInsertionEffect: Z3,
    useLayoutEffect: J3,
    useMemo: r5,
    useReducer: Wg,
    useRef: X3,
    useState: function () {
      return Wg(uf)
    },
    useDebugValue: ew,
    useDeferredValue: function (e) {
      var t = ti()
      return dn === null ? (t.memoizedState = e) : i5(t, dn.memoizedState, e)
    },
    useTransition: function () {
      var e = Wg(uf)[0],
        t = ti().memoizedState
      return [e, t]
    },
    useMutableSource: V3,
    useSyncExternalStore: H3,
    useId: s5,
    unstable_isNewReconciler: !1,
  }
function gc(e, t) {
  try {
    var n = '',
      r = t
    do (n += N4(r)), (r = r.return)
    while (r)
    var i = n
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack
  }
  return { value: e, source: t, stack: i, digest: null }
}
function Vg(e, t, n) {
  return { value: e, source: null, stack: n ?? null, digest: t ?? null }
}
function _y(e, t) {
  try {
    console.error(t.value)
  } catch (n) {
    setTimeout(function () {
      throw n
    })
  }
}
var aR = typeof WeakMap == 'function' ? WeakMap : Map
function c5(e, t, n) {
  ;(n = As(-1, n)), (n.tag = 3), (n.payload = { element: null })
  var r = t.value
  return (
    (n.callback = function () {
      Rp || ((Rp = !0), (My = r)), _y(e, t)
    }),
    n
  )
}
function u5(e, t, n) {
  ;(n = As(-1, n)), (n.tag = 3)
  var r = e.type.getDerivedStateFromError
  if (typeof r == 'function') {
    var i = t.value
    ;(n.payload = function () {
      return r(i)
    }),
      (n.callback = function () {
        _y(e, t)
      })
  }
  var s = e.stateNode
  return (
    s !== null &&
      typeof s.componentDidCatch == 'function' &&
      (n.callback = function () {
        _y(e, t), typeof r != 'function' && (Ro === null ? (Ro = new Set([this])) : Ro.add(this))
        var o = t.stack
        this.componentDidCatch(t.value, { componentStack: o !== null ? o : '' })
      }),
    n
  )
}
function Ix(e, t, n) {
  var r = e.pingCache
  if (r === null) {
    r = e.pingCache = new aR()
    var i = new Set()
    r.set(t, i)
  } else (i = r.get(t)), i === void 0 && ((i = new Set()), r.set(t, i))
  i.has(n) || (i.add(n), (e = xR.bind(null, e, t, n)), t.then(e, e))
}
function Dx(e) {
  do {
    var t
    if (
      ((t = e.tag === 13) && ((t = e.memoizedState), (t = t !== null ? t.dehydrated !== null : !0)),
      t)
    )
      return e
    e = e.return
  } while (e !== null)
  return null
}
function Nx(e, t, n, r, i) {
  return e.mode & 1
    ? ((e.flags |= 65536), (e.lanes = i), e)
    : (e === t
        ? (e.flags |= 65536)
        : ((e.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null ? (n.tag = 17) : ((t = As(-1, 1)), (t.tag = 2), Ao(n, t, 1))),
          (n.lanes |= 1)),
      e)
}
var lR = Fs.ReactCurrentOwner,
  or = !1
function qn(e, t, n, r) {
  t.child = e === null ? z3(t, null, n, r) : hc(t, e.child, n, r)
}
function Mx(e, t, n, r, i) {
  n = n.render
  var s = t.ref
  return (
    $l(t, i),
    (r = X1(e, t, n, r, s, i)),
    (n = Z1()),
    e !== null && !or
      ? ((t.updateQueue = e.updateQueue), (t.flags &= -2053), (e.lanes &= ~i), Ns(e, t, i))
      : ($t && n && F1(t), (t.flags |= 1), qn(e, t, r, i), t.child)
  )
}
function jx(e, t, n, r, i) {
  if (e === null) {
    var s = n.type
    return typeof s == 'function' &&
      !lw(s) &&
      s.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((t.tag = 15), (t.type = s), f5(e, t, s, r, i))
      : ((e = mh(n.type, null, r, t, t.mode, i)), (e.ref = t.ref), (e.return = t), (t.child = e))
  }
  if (((s = e.child), !(e.lanes & i))) {
    var o = s.memoizedProps
    if (((n = n.compare), (n = n !== null ? n : nf), n(o, r) && e.ref === t.ref)) return Ns(e, t, i)
  }
  return (t.flags |= 1), (e = Io(s, r)), (e.ref = t.ref), (e.return = t), (t.child = e)
}
function f5(e, t, n, r, i) {
  if (e !== null) {
    var s = e.memoizedProps
    if (nf(s, r) && e.ref === t.ref)
      if (((or = !1), (t.pendingProps = r = s), (e.lanes & i) !== 0)) e.flags & 131072 && (or = !0)
      else return (t.lanes = e.lanes), Ns(e, t, i)
  }
  return Oy(e, t, n, r, i)
}
function d5(e, t, n) {
  var r = t.pendingProps,
    i = r.children,
    s = e !== null ? e.memoizedState : null
  if (r.mode === 'hidden')
    if (!(t.mode & 1))
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Rt(Ol, vr),
        (vr |= n)
    else {
      if (!(n & 1073741824))
        return (
          (e = s !== null ? s.baseLanes | n : n),
          (t.lanes = t.childLanes = 1073741824),
          (t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }),
          (t.updateQueue = null),
          Rt(Ol, vr),
          (vr |= e),
          null
        )
      ;(t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : n),
        Rt(Ol, vr),
        (vr |= r)
    }
  else
    s !== null ? ((r = s.baseLanes | n), (t.memoizedState = null)) : (r = n), Rt(Ol, vr), (vr |= r)
  return qn(e, t, i, n), t.child
}
function h5(e, t) {
  var n = t.ref
  ;((e === null && n !== null) || (e !== null && e.ref !== n)) &&
    ((t.flags |= 512), (t.flags |= 2097152))
}
function Oy(e, t, n, r, i) {
  var s = cr(n) ? Na : Fn.current
  return (
    (s = fc(t, s)),
    $l(t, i),
    (n = X1(e, t, n, r, s, i)),
    (r = Z1()),
    e !== null && !or
      ? ((t.updateQueue = e.updateQueue), (t.flags &= -2053), (e.lanes &= ~i), Ns(e, t, i))
      : ($t && r && F1(t), (t.flags |= 1), qn(e, t, n, i), t.child)
  )
}
function Lx(e, t, n, r, i) {
  if (cr(n)) {
    var s = !0
    bp(t)
  } else s = !1
  if (($l(t, i), t.stateNode === null)) hh(e, t), B3(t, n, r), Cy(t, n, r, i), (r = !0)
  else if (e === null) {
    var o = t.stateNode,
      a = t.memoizedProps
    o.props = a
    var l = o.context,
      c = n.contextType
    typeof c == 'object' && c !== null
      ? (c = ei(c))
      : ((c = cr(n) ? Na : Fn.current), (c = fc(t, c)))
    var u = n.getDerivedStateFromProps,
      f = typeof u == 'function' || typeof o.getSnapshotBeforeUpdate == 'function'
    f ||
      (typeof o.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof o.componentWillReceiveProps != 'function') ||
      ((a !== r || l !== c) && Tx(t, o, r, c)),
      (uo = !1)
    var d = t.memoizedState
    ;(o.state = d),
      _p(t, r, o, i),
      (l = t.memoizedState),
      a !== r || d !== l || lr.current || uo
        ? (typeof u == 'function' && (Ey(t, n, u, r), (l = t.memoizedState)),
          (a = uo || kx(t, n, a, r, d, l, c))
            ? (f ||
                (typeof o.UNSAFE_componentWillMount != 'function' &&
                  typeof o.componentWillMount != 'function') ||
                (typeof o.componentWillMount == 'function' && o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == 'function' && o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == 'function' && (t.flags |= 4194308))
            : (typeof o.componentDidMount == 'function' && (t.flags |= 4194308),
              (t.memoizedProps = r),
              (t.memoizedState = l)),
          (o.props = r),
          (o.state = l),
          (o.context = c),
          (r = a))
        : (typeof o.componentDidMount == 'function' && (t.flags |= 4194308), (r = !1))
  } else {
    ;(o = t.stateNode),
      $3(e, t),
      (a = t.memoizedProps),
      (c = t.type === t.elementType ? a : pi(t.type, a)),
      (o.props = c),
      (f = t.pendingProps),
      (d = o.context),
      (l = n.contextType),
      typeof l == 'object' && l !== null
        ? (l = ei(l))
        : ((l = cr(n) ? Na : Fn.current), (l = fc(t, l)))
    var p = n.getDerivedStateFromProps
    ;(u = typeof p == 'function' || typeof o.getSnapshotBeforeUpdate == 'function') ||
      (typeof o.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof o.componentWillReceiveProps != 'function') ||
      ((a !== f || d !== l) && Tx(t, o, r, l)),
      (uo = !1),
      (d = t.memoizedState),
      (o.state = d),
      _p(t, r, o, i)
    var h = t.memoizedState
    a !== f || d !== h || lr.current || uo
      ? (typeof p == 'function' && (Ey(t, n, p, r), (h = t.memoizedState)),
        (c = uo || kx(t, n, c, r, d, h, l) || !1)
          ? (u ||
              (typeof o.UNSAFE_componentWillUpdate != 'function' &&
                typeof o.componentWillUpdate != 'function') ||
              (typeof o.componentWillUpdate == 'function' && o.componentWillUpdate(r, h, l),
              typeof o.UNSAFE_componentWillUpdate == 'function' &&
                o.UNSAFE_componentWillUpdate(r, h, l)),
            typeof o.componentDidUpdate == 'function' && (t.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == 'function' && (t.flags |= 1024))
          : (typeof o.componentDidUpdate != 'function' ||
              (a === e.memoizedProps && d === e.memoizedState) ||
              (t.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != 'function' ||
              (a === e.memoizedProps && d === e.memoizedState) ||
              (t.flags |= 1024),
            (t.memoizedProps = r),
            (t.memoizedState = h)),
        (o.props = r),
        (o.state = h),
        (o.context = l),
        (r = c))
      : (typeof o.componentDidUpdate != 'function' ||
          (a === e.memoizedProps && d === e.memoizedState) ||
          (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != 'function' ||
          (a === e.memoizedProps && d === e.memoizedState) ||
          (t.flags |= 1024),
        (r = !1))
  }
  return ky(e, t, n, r, s, i)
}
function ky(e, t, n, r, i, s) {
  h5(e, t)
  var o = (t.flags & 128) !== 0
  if (!r && !o) return i && Sx(t, n, !1), Ns(e, t, s)
  ;(r = t.stateNode), (lR.current = t)
  var a = o && typeof n.getDerivedStateFromError != 'function' ? null : r.render()
  return (
    (t.flags |= 1),
    e !== null && o
      ? ((t.child = hc(t, e.child, null, s)), (t.child = hc(t, null, a, s)))
      : qn(e, t, a, s),
    (t.memoizedState = r.state),
    i && Sx(t, n, !0),
    t.child
  )
}
function p5(e) {
  var t = e.stateNode
  t.pendingContext
    ? xx(e, t.pendingContext, t.pendingContext !== t.context)
    : t.context && xx(e, t.context, !1),
    K1(e, t.containerInfo)
}
function $x(e, t, n, r, i) {
  return dc(), U1(i), (t.flags |= 256), qn(e, t, n, r), t.child
}
var Ty = { dehydrated: null, treeContext: null, retryLane: 0 }
function Ay(e) {
  return { baseLanes: e, cachePool: null, transitions: null }
}
function g5(e, t, n) {
  var r = t.pendingProps,
    i = Ut.current,
    s = !1,
    o = (t.flags & 128) !== 0,
    a
  if (
    ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0),
    a ? ((s = !0), (t.flags &= -129)) : (e === null || e.memoizedState !== null) && (i |= 1),
    Rt(Ut, i & 1),
    e === null)
  )
    return (
      xy(t),
      (e = t.memoizedState),
      e !== null && ((e = e.dehydrated), e !== null)
        ? (t.mode & 1 ? (e.data === '$!' ? (t.lanes = 8) : (t.lanes = 1073741824)) : (t.lanes = 1),
          null)
        : ((o = r.children),
          (e = r.fallback),
          s
            ? ((r = t.mode),
              (s = t.child),
              (o = { mode: 'hidden', children: o }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = T0(o, r, 0, null)),
              (e = Ta(e, r, n, null)),
              (s.return = t),
              (e.return = t),
              (s.sibling = e),
              (t.child = s),
              (t.child.memoizedState = Ay(n)),
              (t.memoizedState = Ty),
              e)
            : tw(t, o))
    )
  if (((i = e.memoizedState), i !== null && ((a = i.dehydrated), a !== null)))
    return cR(e, t, o, r, a, i, n)
  if (s) {
    ;(s = r.fallback), (o = t.mode), (i = e.child), (a = i.sibling)
    var l = { mode: 'hidden', children: r.children }
    return (
      !(o & 1) && t.child !== i
        ? ((r = t.child), (r.childLanes = 0), (r.pendingProps = l), (t.deletions = null))
        : ((r = Io(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      a !== null ? (s = Io(a, s)) : ((s = Ta(s, o, n, null)), (s.flags |= 2)),
      (s.return = t),
      (r.return = t),
      (r.sibling = s),
      (t.child = r),
      (r = s),
      (s = t.child),
      (o = e.child.memoizedState),
      (o =
        o === null
          ? Ay(n)
          : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }),
      (s.memoizedState = o),
      (s.childLanes = e.childLanes & ~n),
      (t.memoizedState = Ty),
      r
    )
  }
  return (
    (s = e.child),
    (e = s.sibling),
    (r = Io(s, { mode: 'visible', children: r.children })),
    !(t.mode & 1) && (r.lanes = n),
    (r.return = t),
    (r.sibling = null),
    e !== null &&
      ((n = t.deletions), n === null ? ((t.deletions = [e]), (t.flags |= 16)) : n.push(e)),
    (t.child = r),
    (t.memoizedState = null),
    r
  )
}
function tw(e, t) {
  return (t = T0({ mode: 'visible', children: t }, e.mode, 0, null)), (t.return = e), (e.child = t)
}
function Cd(e, t, n, r) {
  return (
    r !== null && U1(r),
    hc(t, e.child, null, n),
    (e = tw(t, t.pendingProps.children)),
    (e.flags |= 2),
    (t.memoizedState = null),
    e
  )
}
function cR(e, t, n, r, i, s, o) {
  if (n)
    return t.flags & 256
      ? ((t.flags &= -257), (r = Vg(Error(ee(422)))), Cd(e, t, o, r))
      : t.memoizedState !== null
      ? ((t.child = e.child), (t.flags |= 128), null)
      : ((s = r.fallback),
        (i = t.mode),
        (r = T0({ mode: 'visible', children: r.children }, i, 0, null)),
        (s = Ta(s, i, o, null)),
        (s.flags |= 2),
        (r.return = t),
        (s.return = t),
        (r.sibling = s),
        (t.child = r),
        t.mode & 1 && hc(t, e.child, null, o),
        (t.child.memoizedState = Ay(o)),
        (t.memoizedState = Ty),
        s)
  if (!(t.mode & 1)) return Cd(e, t, o, null)
  if (i.data === '$!') {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst
    return (r = a), (s = Error(ee(419))), (r = Vg(s, r, void 0)), Cd(e, t, o, r)
  }
  if (((a = (o & e.childLanes) !== 0), or || a)) {
    if (((r = Sn), r !== null)) {
      switch (o & -o) {
        case 4:
          i = 2
          break
        case 16:
          i = 8
          break
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32
          break
        case 536870912:
          i = 268435456
          break
        default:
          i = 0
      }
      ;(i = i & (r.suspendedLanes | o) ? 0 : i),
        i !== 0 && i !== s.retryLane && ((s.retryLane = i), Ds(e, i), ki(r, e, i, -1))
    }
    return aw(), (r = Vg(Error(ee(421)))), Cd(e, t, o, r)
  }
  return i.data === '$?'
    ? ((t.flags |= 128), (t.child = e.child), (t = SR.bind(null, e)), (i._reactRetry = t), null)
    : ((e = s.treeContext),
      (Sr = To(i.nextSibling)),
      (Er = t),
      ($t = !0),
      (bi = null),
      e !== null &&
        ((Vr[Hr++] = _s),
        (Vr[Hr++] = Os),
        (Vr[Hr++] = Ma),
        (_s = e.id),
        (Os = e.overflow),
        (Ma = t)),
      (t = tw(t, r.children)),
      (t.flags |= 4096),
      t)
}
function Fx(e, t, n) {
  e.lanes |= t
  var r = e.alternate
  r !== null && (r.lanes |= t), Sy(e.return, t, n)
}
function Hg(e, t, n, r, i) {
  var s = e.memoizedState
  s === null
    ? (e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((s.isBackwards = t),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = n),
      (s.tailMode = i))
}
function m5(e, t, n) {
  var r = t.pendingProps,
    i = r.revealOrder,
    s = r.tail
  if ((qn(e, t, r.children, n), (r = Ut.current), r & 2)) (r = (r & 1) | 2), (t.flags |= 128)
  else {
    if (e !== null && e.flags & 128)
      e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && Fx(e, n, t)
        else if (e.tag === 19) Fx(e, n, t)
        else if (e.child !== null) {
          ;(e.child.return = e), (e = e.child)
          continue
        }
        if (e === t) break e
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e
          e = e.return
        }
        ;(e.sibling.return = e.return), (e = e.sibling)
      }
    r &= 1
  }
  if ((Rt(Ut, r), !(t.mode & 1))) t.memoizedState = null
  else
    switch (i) {
      case 'forwards':
        for (n = t.child, i = null; n !== null; )
          (e = n.alternate), e !== null && Op(e) === null && (i = n), (n = n.sibling)
        ;(n = i),
          n === null ? ((i = t.child), (t.child = null)) : ((i = n.sibling), (n.sibling = null)),
          Hg(t, !1, i, n, s)
        break
      case 'backwards':
        for (n = null, i = t.child, t.child = null; i !== null; ) {
          if (((e = i.alternate), e !== null && Op(e) === null)) {
            t.child = i
            break
          }
          ;(e = i.sibling), (i.sibling = n), (n = i), (i = e)
        }
        Hg(t, !0, n, null, s)
        break
      case 'together':
        Hg(t, !1, null, null, void 0)
        break
      default:
        t.memoizedState = null
    }
  return t.child
}
function hh(e, t) {
  !(t.mode & 1) && e !== null && ((e.alternate = null), (t.alternate = null), (t.flags |= 2))
}
function Ns(e, t, n) {
  if ((e !== null && (t.dependencies = e.dependencies), (La |= t.lanes), !(n & t.childLanes)))
    return null
  if (e !== null && t.child !== e.child) throw Error(ee(153))
  if (t.child !== null) {
    for (e = t.child, n = Io(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null; )
      (e = e.sibling), (n = n.sibling = Io(e, e.pendingProps)), (n.return = t)
    n.sibling = null
  }
  return t.child
}
function uR(e, t, n) {
  switch (t.tag) {
    case 3:
      p5(t), dc()
      break
    case 5:
      W3(t)
      break
    case 1:
      cr(t.type) && bp(t)
      break
    case 4:
      K1(t, t.stateNode.containerInfo)
      break
    case 10:
      var r = t.type._context,
        i = t.memoizedProps.value
      Rt(Ep, r._currentValue), (r._currentValue = i)
      break
    case 13:
      if (((r = t.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (Rt(Ut, Ut.current & 1), (t.flags |= 128), null)
          : n & t.child.childLanes
          ? g5(e, t, n)
          : (Rt(Ut, Ut.current & 1), (e = Ns(e, t, n)), e !== null ? e.sibling : null)
      Rt(Ut, Ut.current & 1)
      break
    case 19:
      if (((r = (n & t.childLanes) !== 0), e.flags & 128)) {
        if (r) return m5(e, t, n)
        t.flags |= 128
      }
      if (
        ((i = t.memoizedState),
        i !== null && ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        Rt(Ut, Ut.current),
        r)
      )
        break
      return null
    case 22:
    case 23:
      return (t.lanes = 0), d5(e, t, n)
  }
  return Ns(e, t, n)
}
var y5, Ry, v5, w5
y5 = function (e, t) {
  for (var n = t.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode)
    else if (n.tag !== 4 && n.child !== null) {
      ;(n.child.return = n), (n = n.child)
      continue
    }
    if (n === t) break
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === t) return
      n = n.return
    }
    ;(n.sibling.return = n.return), (n = n.sibling)
  }
}
Ry = function () {}
v5 = function (e, t, n, r) {
  var i = e.memoizedProps
  if (i !== r) {
    ;(e = t.stateNode), pa(es.current)
    var s = null
    switch (n) {
      case 'input':
        ;(i = Zm(e, i)), (r = Zm(e, r)), (s = [])
        break
      case 'select':
        ;(i = Wt({}, i, { value: void 0 })), (r = Wt({}, r, { value: void 0 })), (s = [])
        break
      case 'textarea':
        ;(i = ty(e, i)), (r = ty(e, r)), (s = [])
        break
      default:
        typeof i.onClick != 'function' && typeof r.onClick == 'function' && (e.onclick = vp)
    }
    ry(n, r)
    var o
    n = null
    for (c in i)
      if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
        if (c === 'style') {
          var a = i[c]
          for (o in a) a.hasOwnProperty(o) && (n || (n = {}), (n[o] = ''))
        } else
          c !== 'dangerouslySetInnerHTML' &&
            c !== 'children' &&
            c !== 'suppressContentEditableWarning' &&
            c !== 'suppressHydrationWarning' &&
            c !== 'autoFocus' &&
            (Yu.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null))
    for (c in r) {
      var l = r[c]
      if (
        ((a = i != null ? i[c] : void 0),
        r.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === 'style')
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) || (l && l.hasOwnProperty(o)) || (n || (n = {}), (n[o] = ''))
            for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), (n[o] = l[o]))
          } else n || (s || (s = []), s.push(c, n)), (n = l)
        else
          c === 'dangerouslySetInnerHTML'
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(c, l))
            : c === 'children'
            ? (typeof l != 'string' && typeof l != 'number') || (s = s || []).push(c, '' + l)
            : c !== 'suppressContentEditableWarning' &&
              c !== 'suppressHydrationWarning' &&
              (Yu.hasOwnProperty(c)
                ? (l != null && c === 'onScroll' && It('scroll', e), s || a === l || (s = []))
                : (s = s || []).push(c, l))
    }
    n && (s = s || []).push('style', n)
    var c = s
    ;(t.updateQueue = c) && (t.flags |= 4)
  }
}
w5 = function (e, t, n, r) {
  n !== r && (t.flags |= 4)
}
function nu(e, t) {
  if (!$t)
    switch (e.tailMode) {
      case 'hidden':
        t = e.tail
        for (var n = null; t !== null; ) t.alternate !== null && (n = t), (t = t.sibling)
        n === null ? (e.tail = null) : (n.sibling = null)
        break
      case 'collapsed':
        n = e.tail
        for (var r = null; n !== null; ) n.alternate !== null && (r = n), (n = n.sibling)
        r === null
          ? t || e.tail === null
            ? (e.tail = null)
            : (e.tail.sibling = null)
          : (r.sibling = null)
    }
}
function Dn(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    n = 0,
    r = 0
  if (t)
    for (var i = e.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = e),
        (i = i.sibling)
  else
    for (i = e.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = e),
        (i = i.sibling)
  return (e.subtreeFlags |= r), (e.childLanes = n), t
}
function fR(e, t, n) {
  var r = t.pendingProps
  switch ((B1(t), t.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Dn(t), null
    case 1:
      return cr(t.type) && wp(), Dn(t), null
    case 3:
      return (
        (r = t.stateNode),
        pc(),
        Nt(lr),
        Nt(Fn),
        Y1(),
        r.pendingContext && ((r.context = r.pendingContext), (r.pendingContext = null)),
        (e === null || e.child === null) &&
          (Sd(t)
            ? (t.flags |= 4)
            : e === null ||
              (e.memoizedState.isDehydrated && !(t.flags & 256)) ||
              ((t.flags |= 1024), bi !== null && ($y(bi), (bi = null)))),
        Ry(e, t),
        Dn(t),
        null
      )
    case 5:
      G1(t)
      var i = pa(lf.current)
      if (((n = t.type), e !== null && t.stateNode != null))
        v5(e, t, n, r, i), e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152))
      else {
        if (!r) {
          if (t.stateNode === null) throw Error(ee(166))
          return Dn(t), null
        }
        if (((e = pa(es.current)), Sd(t))) {
          ;(r = t.stateNode), (n = t.type)
          var s = t.memoizedProps
          switch (((r[Gi] = t), (r[of] = s), (e = (t.mode & 1) !== 0), n)) {
            case 'dialog':
              It('cancel', r), It('close', r)
              break
            case 'iframe':
            case 'object':
            case 'embed':
              It('load', r)
              break
            case 'video':
            case 'audio':
              for (i = 0; i < vu.length; i++) It(vu[i], r)
              break
            case 'source':
              It('error', r)
              break
            case 'img':
            case 'image':
            case 'link':
              It('error', r), It('load', r)
              break
            case 'details':
              It('toggle', r)
              break
            case 'input':
              Gb(r, s), It('invalid', r)
              break
            case 'select':
              ;(r._wrapperState = { wasMultiple: !!s.multiple }), It('invalid', r)
              break
            case 'textarea':
              Qb(r, s), It('invalid', r)
          }
          ry(n, s), (i = null)
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o]
              o === 'children'
                ? typeof a == 'string'
                  ? r.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 && xd(r.textContent, a, e),
                    (i = ['children', a]))
                  : typeof a == 'number' &&
                    r.textContent !== '' + a &&
                    (s.suppressHydrationWarning !== !0 && xd(r.textContent, a, e),
                    (i = ['children', '' + a]))
                : Yu.hasOwnProperty(o) && a != null && o === 'onScroll' && It('scroll', r)
            }
          switch (n) {
            case 'input':
              hd(r), Yb(r, s, !0)
              break
            case 'textarea':
              hd(r), Xb(r)
              break
            case 'select':
            case 'option':
              break
            default:
              typeof s.onClick == 'function' && (r.onclick = vp)
          }
          ;(r = i), (t.updateQueue = r), r !== null && (t.flags |= 4)
        } else {
          ;(o = i.nodeType === 9 ? i : i.ownerDocument),
            e === 'http://www.w3.org/1999/xhtml' && (e = qC(n)),
            e === 'http://www.w3.org/1999/xhtml'
              ? n === 'script'
                ? ((e = o.createElement('div')),
                  (e.innerHTML = '<script></script>'),
                  (e = e.removeChild(e.firstChild)))
                : typeof r.is == 'string'
                ? (e = o.createElement(n, { is: r.is }))
                : ((e = o.createElement(n)),
                  n === 'select' &&
                    ((o = e), r.multiple ? (o.multiple = !0) : r.size && (o.size = r.size)))
              : (e = o.createElementNS(e, n)),
            (e[Gi] = t),
            (e[of] = r),
            y5(e, t, !1, !1),
            (t.stateNode = e)
          e: {
            switch (((o = iy(n, r)), n)) {
              case 'dialog':
                It('cancel', e), It('close', e), (i = r)
                break
              case 'iframe':
              case 'object':
              case 'embed':
                It('load', e), (i = r)
                break
              case 'video':
              case 'audio':
                for (i = 0; i < vu.length; i++) It(vu[i], e)
                i = r
                break
              case 'source':
                It('error', e), (i = r)
                break
              case 'img':
              case 'image':
              case 'link':
                It('error', e), It('load', e), (i = r)
                break
              case 'details':
                It('toggle', e), (i = r)
                break
              case 'input':
                Gb(e, r), (i = Zm(e, r)), It('invalid', e)
                break
              case 'option':
                i = r
                break
              case 'select':
                ;(e._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = Wt({}, r, { value: void 0 })),
                  It('invalid', e)
                break
              case 'textarea':
                Qb(e, r), (i = ty(e, r)), It('invalid', e)
                break
              default:
                i = r
            }
            ry(n, i), (a = i)
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s]
                s === 'style'
                  ? YC(e, l)
                  : s === 'dangerouslySetInnerHTML'
                  ? ((l = l ? l.__html : void 0), l != null && KC(e, l))
                  : s === 'children'
                  ? typeof l == 'string'
                    ? (n !== 'textarea' || l !== '') && Qu(e, l)
                    : typeof l == 'number' && Qu(e, '' + l)
                  : s !== 'suppressContentEditableWarning' &&
                    s !== 'suppressHydrationWarning' &&
                    s !== 'autoFocus' &&
                    (Yu.hasOwnProperty(s)
                      ? l != null && s === 'onScroll' && It('scroll', e)
                      : l != null && _1(e, s, l, o))
              }
            switch (n) {
              case 'input':
                hd(e), Yb(e, r, !1)
                break
              case 'textarea':
                hd(e), Xb(e)
                break
              case 'option':
                r.value != null && e.setAttribute('value', '' + Lo(r.value))
                break
              case 'select':
                ;(e.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? Nl(e, !!r.multiple, s, !1)
                    : r.defaultValue != null && Nl(e, !!r.multiple, r.defaultValue, !0)
                break
              default:
                typeof i.onClick == 'function' && (e.onclick = vp)
            }
            switch (n) {
              case 'button':
              case 'input':
              case 'select':
              case 'textarea':
                r = !!r.autoFocus
                break e
              case 'img':
                r = !0
                break e
              default:
                r = !1
            }
          }
          r && (t.flags |= 4)
        }
        t.ref !== null && ((t.flags |= 512), (t.flags |= 2097152))
      }
      return Dn(t), null
    case 6:
      if (e && t.stateNode != null) w5(e, t, e.memoizedProps, r)
      else {
        if (typeof r != 'string' && t.stateNode === null) throw Error(ee(166))
        if (((n = pa(lf.current)), pa(es.current), Sd(t))) {
          if (
            ((r = t.stateNode),
            (n = t.memoizedProps),
            (r[Gi] = t),
            (s = r.nodeValue !== n) && ((e = Er), e !== null))
          )
            switch (e.tag) {
              case 3:
                xd(r.nodeValue, n, (e.mode & 1) !== 0)
                break
              case 5:
                e.memoizedProps.suppressHydrationWarning !== !0 &&
                  xd(r.nodeValue, n, (e.mode & 1) !== 0)
            }
          s && (t.flags |= 4)
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[Gi] = t),
            (t.stateNode = r)
      }
      return Dn(t), null
    case 13:
      if (
        (Nt(Ut),
        (r = t.memoizedState),
        e === null || (e.memoizedState !== null && e.memoizedState.dehydrated !== null))
      ) {
        if ($t && Sr !== null && t.mode & 1 && !(t.flags & 128))
          j3(), dc(), (t.flags |= 98560), (s = !1)
        else if (((s = Sd(t)), r !== null && r.dehydrated !== null)) {
          if (e === null) {
            if (!s) throw Error(ee(318))
            if (((s = t.memoizedState), (s = s !== null ? s.dehydrated : null), !s))
              throw Error(ee(317))
            s[Gi] = t
          } else dc(), !(t.flags & 128) && (t.memoizedState = null), (t.flags |= 4)
          Dn(t), (s = !1)
        } else bi !== null && ($y(bi), (bi = null)), (s = !0)
        if (!s) return t.flags & 65536 ? t : null
      }
      return t.flags & 128
        ? ((t.lanes = n), t)
        : ((r = r !== null),
          r !== (e !== null && e.memoizedState !== null) &&
            r &&
            ((t.child.flags |= 8192),
            t.mode & 1 && (e === null || Ut.current & 1 ? pn === 0 && (pn = 3) : aw())),
          t.updateQueue !== null && (t.flags |= 4),
          Dn(t),
          null)
    case 4:
      return pc(), Ry(e, t), e === null && rf(t.stateNode.containerInfo), Dn(t), null
    case 10:
      return V1(t.type._context), Dn(t), null
    case 17:
      return cr(t.type) && wp(), Dn(t), null
    case 19:
      if ((Nt(Ut), (s = t.memoizedState), s === null)) return Dn(t), null
      if (((r = (t.flags & 128) !== 0), (o = s.rendering), o === null))
        if (r) nu(s, !1)
        else {
          if (pn !== 0 || (e !== null && e.flags & 128))
            for (e = t.child; e !== null; ) {
              if (((o = Op(e)), o !== null)) {
                for (
                  t.flags |= 128,
                    nu(s, !1),
                    r = o.updateQueue,
                    r !== null && ((t.updateQueue = r), (t.flags |= 4)),
                    t.subtreeFlags = 0,
                    r = n,
                    n = t.child;
                  n !== null;

                )
                  (s = n),
                    (e = r),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = e),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (e = o.dependencies),
                        (s.dependencies =
                          e === null ? null : { lanes: e.lanes, firstContext: e.firstContext })),
                    (n = n.sibling)
                return Rt(Ut, (Ut.current & 1) | 2), t.child
              }
              e = e.sibling
            }
          s.tail !== null &&
            Jt() > mc &&
            ((t.flags |= 128), (r = !0), nu(s, !1), (t.lanes = 4194304))
        }
      else {
        if (!r)
          if (((e = Op(o)), e !== null)) {
            if (
              ((t.flags |= 128),
              (r = !0),
              (n = e.updateQueue),
              n !== null && ((t.updateQueue = n), (t.flags |= 4)),
              nu(s, !0),
              s.tail === null && s.tailMode === 'hidden' && !o.alternate && !$t)
            )
              return Dn(t), null
          } else
            2 * Jt() - s.renderingStartTime > mc &&
              n !== 1073741824 &&
              ((t.flags |= 128), (r = !0), nu(s, !1), (t.lanes = 4194304))
        s.isBackwards
          ? ((o.sibling = t.child), (t.child = o))
          : ((n = s.last), n !== null ? (n.sibling = o) : (t.child = o), (s.last = o))
      }
      return s.tail !== null
        ? ((t = s.tail),
          (s.rendering = t),
          (s.tail = t.sibling),
          (s.renderingStartTime = Jt()),
          (t.sibling = null),
          (n = Ut.current),
          Rt(Ut, r ? (n & 1) | 2 : n & 1),
          t)
        : (Dn(t), null)
    case 22:
    case 23:
      return (
        ow(),
        (r = t.memoizedState !== null),
        e !== null && (e.memoizedState !== null) !== r && (t.flags |= 8192),
        r && t.mode & 1
          ? vr & 1073741824 && (Dn(t), t.subtreeFlags & 6 && (t.flags |= 8192))
          : Dn(t),
        null
      )
    case 24:
      return null
    case 25:
      return null
  }
  throw Error(ee(156, t.tag))
}
function dR(e, t) {
  switch ((B1(t), t.tag)) {
    case 1:
      return (
        cr(t.type) && wp(), (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 3:
      return (
        pc(),
        Nt(lr),
        Nt(Fn),
        Y1(),
        (e = t.flags),
        e & 65536 && !(e & 128) ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 5:
      return G1(t), null
    case 13:
      if ((Nt(Ut), (e = t.memoizedState), e !== null && e.dehydrated !== null)) {
        if (t.alternate === null) throw Error(ee(340))
        dc()
      }
      return (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
    case 19:
      return Nt(Ut), null
    case 4:
      return pc(), null
    case 10:
      return V1(t.type._context), null
    case 22:
    case 23:
      return ow(), null
    case 24:
      return null
    default:
      return null
  }
}
var _d = !1,
  Ln = !1,
  hR = typeof WeakSet == 'function' ? WeakSet : Set,
  be = null
function _l(e, t) {
  var n = e.ref
  if (n !== null)
    if (typeof n == 'function')
      try {
        n(null)
      } catch (r) {
        Qt(e, t, r)
      }
    else n.current = null
}
function Py(e, t, n) {
  try {
    n()
  } catch (r) {
    Qt(e, t, r)
  }
}
var Bx = !1
function pR(e, t) {
  if (((py = gp), (e = E3()), $1(e))) {
    if ('selectionStart' in e) var n = { start: e.selectionStart, end: e.selectionEnd }
    else
      e: {
        n = ((n = e.ownerDocument) && n.defaultView) || window
        var r = n.getSelection && n.getSelection()
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode
          var i = r.anchorOffset,
            s = r.focusNode
          r = r.focusOffset
          try {
            n.nodeType, s.nodeType
          } catch {
            n = null
            break e
          }
          var o = 0,
            a = -1,
            l = -1,
            c = 0,
            u = 0,
            f = e,
            d = null
          t: for (;;) {
            for (
              var p;
              f !== n || (i !== 0 && f.nodeType !== 3) || (a = o + i),
                f !== s || (r !== 0 && f.nodeType !== 3) || (l = o + r),
                f.nodeType === 3 && (o += f.nodeValue.length),
                (p = f.firstChild) !== null;

            )
              (d = f), (f = p)
            for (;;) {
              if (f === e) break t
              if (
                (d === n && ++c === i && (a = o),
                d === s && ++u === r && (l = o),
                (p = f.nextSibling) !== null)
              )
                break
              ;(f = d), (d = f.parentNode)
            }
            f = p
          }
          n = a === -1 || l === -1 ? null : { start: a, end: l }
        } else n = null
      }
    n = n || { start: 0, end: 0 }
  } else n = null
  for (gy = { focusedElem: e, selectionRange: n }, gp = !1, be = t; be !== null; )
    if (((t = be), (e = t.child), (t.subtreeFlags & 1028) !== 0 && e !== null))
      (e.return = t), (be = e)
    else
      for (; be !== null; ) {
        t = be
        try {
          var h = t.alternate
          if (t.flags & 1024)
            switch (t.tag) {
              case 0:
              case 11:
              case 15:
                break
              case 1:
                if (h !== null) {
                  var m = h.memoizedProps,
                    b = h.memoizedState,
                    y = t.stateNode,
                    v = y.getSnapshotBeforeUpdate(t.elementType === t.type ? m : pi(t.type, m), b)
                  y.__reactInternalSnapshotBeforeUpdate = v
                }
                break
              case 3:
                var S = t.stateNode.containerInfo
                S.nodeType === 1
                  ? (S.textContent = '')
                  : S.nodeType === 9 && S.documentElement && S.removeChild(S.documentElement)
                break
              case 5:
              case 6:
              case 4:
              case 17:
                break
              default:
                throw Error(ee(163))
            }
        } catch (T) {
          Qt(t, t.return, T)
        }
        if (((e = t.sibling), e !== null)) {
          ;(e.return = t.return), (be = e)
          break
        }
        be = t.return
      }
  return (h = Bx), (Bx = !1), h
}
function $u(e, t, n) {
  var r = t.updateQueue
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next)
    do {
      if ((i.tag & e) === e) {
        var s = i.destroy
        ;(i.destroy = void 0), s !== void 0 && Py(t, n, s)
      }
      i = i.next
    } while (i !== r)
  }
}
function O0(e, t) {
  if (((t = t.updateQueue), (t = t !== null ? t.lastEffect : null), t !== null)) {
    var n = (t = t.next)
    do {
      if ((n.tag & e) === e) {
        var r = n.create
        n.destroy = r()
      }
      n = n.next
    } while (n !== t)
  }
}
function Iy(e) {
  var t = e.ref
  if (t !== null) {
    var n = e.stateNode
    switch (e.tag) {
      case 5:
        e = n
        break
      default:
        e = n
    }
    typeof t == 'function' ? t(e) : (t.current = e)
  }
}
function b5(e) {
  var t = e.alternate
  t !== null && ((e.alternate = null), b5(t)),
    (e.child = null),
    (e.deletions = null),
    (e.sibling = null),
    e.tag === 5 &&
      ((t = e.stateNode),
      t !== null && (delete t[Gi], delete t[of], delete t[vy], delete t[QA], delete t[XA])),
    (e.stateNode = null),
    (e.return = null),
    (e.dependencies = null),
    (e.memoizedProps = null),
    (e.memoizedState = null),
    (e.pendingProps = null),
    (e.stateNode = null),
    (e.updateQueue = null)
}
function x5(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function Ux(e) {
  e: for (;;) {
    for (; e.sibling === null; ) {
      if (e.return === null || x5(e.return)) return null
      e = e.return
    }
    for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e
      ;(e.child.return = e), (e = e.child)
    }
    if (!(e.flags & 2)) return e.stateNode
  }
}
function Dy(e, t, n) {
  var r = e.tag
  if (r === 5 || r === 6)
    (e = e.stateNode),
      t
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(e, t)
          : n.insertBefore(e, t)
        : (n.nodeType === 8
            ? ((t = n.parentNode), t.insertBefore(e, n))
            : ((t = n), t.appendChild(e)),
          (n = n._reactRootContainer),
          n != null || t.onclick !== null || (t.onclick = vp))
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Dy(e, t, n), e = e.sibling; e !== null; ) Dy(e, t, n), (e = e.sibling)
}
function Ny(e, t, n) {
  var r = e.tag
  if (r === 5 || r === 6) (e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e)
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Ny(e, t, n), e = e.sibling; e !== null; ) Ny(e, t, n), (e = e.sibling)
}
var _n = null,
  yi = !1
function qs(e, t, n) {
  for (n = n.child; n !== null; ) S5(e, t, n), (n = n.sibling)
}
function S5(e, t, n) {
  if (Ji && typeof Ji.onCommitFiberUnmount == 'function')
    try {
      Ji.onCommitFiberUnmount(v0, n)
    } catch {}
  switch (n.tag) {
    case 5:
      Ln || _l(n, t)
    case 6:
      var r = _n,
        i = yi
      ;(_n = null),
        qs(e, t, n),
        (_n = r),
        (yi = i),
        _n !== null &&
          (yi
            ? ((e = _n),
              (n = n.stateNode),
              e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n))
            : _n.removeChild(n.stateNode))
      break
    case 18:
      _n !== null &&
        (yi
          ? ((e = _n),
            (n = n.stateNode),
            e.nodeType === 8 ? $g(e.parentNode, n) : e.nodeType === 1 && $g(e, n),
            ef(e))
          : $g(_n, n.stateNode))
      break
    case 4:
      ;(r = _n),
        (i = yi),
        (_n = n.stateNode.containerInfo),
        (yi = !0),
        qs(e, t, n),
        (_n = r),
        (yi = i)
      break
    case 0:
    case 11:
    case 14:
    case 15:
      if (!Ln && ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))) {
        i = r = r.next
        do {
          var s = i,
            o = s.destroy
          ;(s = s.tag), o !== void 0 && (s & 2 || s & 4) && Py(n, t, o), (i = i.next)
        } while (i !== r)
      }
      qs(e, t, n)
      break
    case 1:
      if (!Ln && (_l(n, t), (r = n.stateNode), typeof r.componentWillUnmount == 'function'))
        try {
          ;(r.props = n.memoizedProps), (r.state = n.memoizedState), r.componentWillUnmount()
        } catch (a) {
          Qt(n, t, a)
        }
      qs(e, t, n)
      break
    case 21:
      qs(e, t, n)
      break
    case 22:
      n.mode & 1
        ? ((Ln = (r = Ln) || n.memoizedState !== null), qs(e, t, n), (Ln = r))
        : qs(e, t, n)
      break
    default:
      qs(e, t, n)
  }
}
function zx(e) {
  var t = e.updateQueue
  if (t !== null) {
    e.updateQueue = null
    var n = e.stateNode
    n === null && (n = e.stateNode = new hR()),
      t.forEach(function (r) {
        var i = ER.bind(null, e, r)
        n.has(r) || (n.add(r), r.then(i, i))
      })
  }
}
function fi(e, t) {
  var n = t.deletions
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r]
      try {
        var s = e,
          o = t,
          a = o
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              ;(_n = a.stateNode), (yi = !1)
              break e
            case 3:
              ;(_n = a.stateNode.containerInfo), (yi = !0)
              break e
            case 4:
              ;(_n = a.stateNode.containerInfo), (yi = !0)
              break e
          }
          a = a.return
        }
        if (_n === null) throw Error(ee(160))
        S5(s, o, i), (_n = null), (yi = !1)
        var l = i.alternate
        l !== null && (l.return = null), (i.return = null)
      } catch (c) {
        Qt(i, t, c)
      }
    }
  if (t.subtreeFlags & 12854) for (t = t.child; t !== null; ) E5(t, e), (t = t.sibling)
}
function E5(e, t) {
  var n = e.alternate,
    r = e.flags
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((fi(t, e), Fi(e), r & 4)) {
        try {
          $u(3, e, e.return), O0(3, e)
        } catch (m) {
          Qt(e, e.return, m)
        }
        try {
          $u(5, e, e.return)
        } catch (m) {
          Qt(e, e.return, m)
        }
      }
      break
    case 1:
      fi(t, e), Fi(e), r & 512 && n !== null && _l(n, n.return)
      break
    case 5:
      if ((fi(t, e), Fi(e), r & 512 && n !== null && _l(n, n.return), e.flags & 32)) {
        var i = e.stateNode
        try {
          Qu(i, '')
        } catch (m) {
          Qt(e, e.return, m)
        }
      }
      if (r & 4 && ((i = e.stateNode), i != null)) {
        var s = e.memoizedProps,
          o = n !== null ? n.memoizedProps : s,
          a = e.type,
          l = e.updateQueue
        if (((e.updateQueue = null), l !== null))
          try {
            a === 'input' && s.type === 'radio' && s.name != null && VC(i, s), iy(a, o)
            var c = iy(a, s)
            for (o = 0; o < l.length; o += 2) {
              var u = l[o],
                f = l[o + 1]
              u === 'style'
                ? YC(i, f)
                : u === 'dangerouslySetInnerHTML'
                ? KC(i, f)
                : u === 'children'
                ? Qu(i, f)
                : _1(i, u, f, c)
            }
            switch (a) {
              case 'input':
                Jm(i, s)
                break
              case 'textarea':
                HC(i, s)
                break
              case 'select':
                var d = i._wrapperState.wasMultiple
                i._wrapperState.wasMultiple = !!s.multiple
                var p = s.value
                p != null
                  ? Nl(i, !!s.multiple, p, !1)
                  : d !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Nl(i, !!s.multiple, s.defaultValue, !0)
                      : Nl(i, !!s.multiple, s.multiple ? [] : '', !1))
            }
            i[of] = s
          } catch (m) {
            Qt(e, e.return, m)
          }
      }
      break
    case 6:
      if ((fi(t, e), Fi(e), r & 4)) {
        if (e.stateNode === null) throw Error(ee(162))
        ;(i = e.stateNode), (s = e.memoizedProps)
        try {
          i.nodeValue = s
        } catch (m) {
          Qt(e, e.return, m)
        }
      }
      break
    case 3:
      if ((fi(t, e), Fi(e), r & 4 && n !== null && n.memoizedState.isDehydrated))
        try {
          ef(t.containerInfo)
        } catch (m) {
          Qt(e, e.return, m)
        }
      break
    case 4:
      fi(t, e), Fi(e)
      break
    case 13:
      fi(t, e),
        Fi(e),
        (i = e.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s || (i.alternate !== null && i.alternate.memoizedState !== null) || (iw = Jt())),
        r & 4 && zx(e)
      break
    case 22:
      if (
        ((u = n !== null && n.memoizedState !== null),
        e.mode & 1 ? ((Ln = (c = Ln) || u), fi(t, e), (Ln = c)) : fi(t, e),
        Fi(e),
        r & 8192)
      ) {
        if (((c = e.memoizedState !== null), (e.stateNode.isHidden = c) && !u && e.mode & 1))
          for (be = e, u = e.child; u !== null; ) {
            for (f = be = u; be !== null; ) {
              switch (((d = be), (p = d.child), d.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  $u(4, d, d.return)
                  break
                case 1:
                  _l(d, d.return)
                  var h = d.stateNode
                  if (typeof h.componentWillUnmount == 'function') {
                    ;(r = d), (n = d.return)
                    try {
                      ;(t = r),
                        (h.props = t.memoizedProps),
                        (h.state = t.memoizedState),
                        h.componentWillUnmount()
                    } catch (m) {
                      Qt(r, n, m)
                    }
                  }
                  break
                case 5:
                  _l(d, d.return)
                  break
                case 22:
                  if (d.memoizedState !== null) {
                    Vx(f)
                    continue
                  }
              }
              p !== null ? ((p.return = d), (be = p)) : Vx(f)
            }
            u = u.sibling
          }
        e: for (u = null, f = e; ; ) {
          if (f.tag === 5) {
            if (u === null) {
              u = f
              try {
                ;(i = f.stateNode),
                  c
                    ? ((s = i.style),
                      typeof s.setProperty == 'function'
                        ? s.setProperty('display', 'none', 'important')
                        : (s.display = 'none'))
                    : ((a = f.stateNode),
                      (l = f.memoizedProps.style),
                      (o = l != null && l.hasOwnProperty('display') ? l.display : null),
                      (a.style.display = GC('display', o)))
              } catch (m) {
                Qt(e, e.return, m)
              }
            }
          } else if (f.tag === 6) {
            if (u === null)
              try {
                f.stateNode.nodeValue = c ? '' : f.memoizedProps
              } catch (m) {
                Qt(e, e.return, m)
              }
          } else if (
            ((f.tag !== 22 && f.tag !== 23) || f.memoizedState === null || f === e) &&
            f.child !== null
          ) {
            ;(f.child.return = f), (f = f.child)
            continue
          }
          if (f === e) break e
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === e) break e
            u === f && (u = null), (f = f.return)
          }
          u === f && (u = null), (f.sibling.return = f.return), (f = f.sibling)
        }
      }
      break
    case 19:
      fi(t, e), Fi(e), r & 4 && zx(e)
      break
    case 21:
      break
    default:
      fi(t, e), Fi(e)
  }
}
function Fi(e) {
  var t = e.flags
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null; ) {
          if (x5(n)) {
            var r = n
            break e
          }
          n = n.return
        }
        throw Error(ee(160))
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode
          r.flags & 32 && (Qu(i, ''), (r.flags &= -33))
          var s = Ux(e)
          Ny(e, s, i)
          break
        case 3:
        case 4:
          var o = r.stateNode.containerInfo,
            a = Ux(e)
          Dy(e, a, o)
          break
        default:
          throw Error(ee(161))
      }
    } catch (l) {
      Qt(e, e.return, l)
    }
    e.flags &= -3
  }
  t & 4096 && (e.flags &= -4097)
}
function gR(e, t, n) {
  ;(be = e), C5(e)
}
function C5(e, t, n) {
  for (var r = (e.mode & 1) !== 0; be !== null; ) {
    var i = be,
      s = i.child
    if (i.tag === 22 && r) {
      var o = i.memoizedState !== null || _d
      if (!o) {
        var a = i.alternate,
          l = (a !== null && a.memoizedState !== null) || Ln
        a = _d
        var c = Ln
        if (((_d = o), (Ln = l) && !c))
          for (be = i; be !== null; )
            (o = be),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? Hx(i)
                : l !== null
                ? ((l.return = o), (be = l))
                : Hx(i)
        for (; s !== null; ) (be = s), C5(s), (s = s.sibling)
        ;(be = i), (_d = a), (Ln = c)
      }
      Wx(e)
    } else i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (be = s)) : Wx(e)
  }
}
function Wx(e) {
  for (; be !== null; ) {
    var t = be
    if (t.flags & 8772) {
      var n = t.alternate
      try {
        if (t.flags & 8772)
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              Ln || O0(5, t)
              break
            case 1:
              var r = t.stateNode
              if (t.flags & 4 && !Ln)
                if (n === null) r.componentDidMount()
                else {
                  var i = t.elementType === t.type ? n.memoizedProps : pi(t.type, n.memoizedProps)
                  r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                }
              var s = t.updateQueue
              s !== null && Ox(t, s, r)
              break
            case 3:
              var o = t.updateQueue
              if (o !== null) {
                if (((n = null), t.child !== null))
                  switch (t.child.tag) {
                    case 5:
                      n = t.child.stateNode
                      break
                    case 1:
                      n = t.child.stateNode
                  }
                Ox(t, o, n)
              }
              break
            case 5:
              var a = t.stateNode
              if (n === null && t.flags & 4) {
                n = a
                var l = t.memoizedProps
                switch (t.type) {
                  case 'button':
                  case 'input':
                  case 'select':
                  case 'textarea':
                    l.autoFocus && n.focus()
                    break
                  case 'img':
                    l.src && (n.src = l.src)
                }
              }
              break
            case 6:
              break
            case 4:
              break
            case 12:
              break
            case 13:
              if (t.memoizedState === null) {
                var c = t.alternate
                if (c !== null) {
                  var u = c.memoizedState
                  if (u !== null) {
                    var f = u.dehydrated
                    f !== null && ef(f)
                  }
                }
              }
              break
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break
            default:
              throw Error(ee(163))
          }
        Ln || (t.flags & 512 && Iy(t))
      } catch (d) {
        Qt(t, t.return, d)
      }
    }
    if (t === e) {
      be = null
      break
    }
    if (((n = t.sibling), n !== null)) {
      ;(n.return = t.return), (be = n)
      break
    }
    be = t.return
  }
}
function Vx(e) {
  for (; be !== null; ) {
    var t = be
    if (t === e) {
      be = null
      break
    }
    var n = t.sibling
    if (n !== null) {
      ;(n.return = t.return), (be = n)
      break
    }
    be = t.return
  }
}
function Hx(e) {
  for (; be !== null; ) {
    var t = be
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return
          try {
            O0(4, t)
          } catch (l) {
            Qt(t, n, l)
          }
          break
        case 1:
          var r = t.stateNode
          if (typeof r.componentDidMount == 'function') {
            var i = t.return
            try {
              r.componentDidMount()
            } catch (l) {
              Qt(t, i, l)
            }
          }
          var s = t.return
          try {
            Iy(t)
          } catch (l) {
            Qt(t, s, l)
          }
          break
        case 5:
          var o = t.return
          try {
            Iy(t)
          } catch (l) {
            Qt(t, o, l)
          }
      }
    } catch (l) {
      Qt(t, t.return, l)
    }
    if (t === e) {
      be = null
      break
    }
    var a = t.sibling
    if (a !== null) {
      ;(a.return = t.return), (be = a)
      break
    }
    be = t.return
  }
}
var mR = Math.ceil,
  Ap = Fs.ReactCurrentDispatcher,
  nw = Fs.ReactCurrentOwner,
  Zr = Fs.ReactCurrentBatchConfig,
  mt = 0,
  Sn = null,
  rn = null,
  On = 0,
  vr = 0,
  Ol = Ho(0),
  pn = 0,
  df = null,
  La = 0,
  k0 = 0,
  rw = 0,
  Fu = null,
  sr = null,
  iw = 0,
  mc = 1 / 0,
  ys = null,
  Rp = !1,
  My = null,
  Ro = null,
  Od = !1,
  Co = null,
  Pp = 0,
  Bu = 0,
  jy = null,
  ph = -1,
  gh = 0
function Kn() {
  return mt & 6 ? Jt() : ph !== -1 ? ph : (ph = Jt())
}
function Po(e) {
  return e.mode & 1
    ? mt & 2 && On !== 0
      ? On & -On
      : JA.transition !== null
      ? (gh === 0 && (gh = a3()), gh)
      : ((e = Tt), e !== 0 || ((e = window.event), (e = e === void 0 ? 16 : p3(e.type))), e)
    : 1
}
function ki(e, t, n, r) {
  if (50 < Bu) throw ((Bu = 0), (jy = null), Error(ee(185)))
  qf(e, n, r),
    (!(mt & 2) || e !== Sn) &&
      (e === Sn && (!(mt & 2) && (k0 |= n), pn === 4 && po(e, On)),
      ur(e, r),
      n === 1 && mt === 0 && !(t.mode & 1) && ((mc = Jt() + 500), E0 && qo()))
}
function ur(e, t) {
  var n = e.callbackNode
  J4(e, t)
  var r = pp(e, e === Sn ? On : 0)
  if (r === 0) n !== null && ex(n), (e.callbackNode = null), (e.callbackPriority = 0)
  else if (((t = r & -r), e.callbackPriority !== t)) {
    if ((n != null && ex(n), t === 1))
      e.tag === 0 ? ZA(qx.bind(null, e)) : D3(qx.bind(null, e)),
        GA(function () {
          !(mt & 6) && qo()
        }),
        (n = null)
    else {
      switch (l3(r)) {
        case 1:
          n = R1
          break
        case 4:
          n = s3
          break
        case 16:
          n = hp
          break
        case 536870912:
          n = o3
          break
        default:
          n = hp
      }
      n = I5(n, _5.bind(null, e))
    }
    ;(e.callbackPriority = t), (e.callbackNode = n)
  }
}
function _5(e, t) {
  if (((ph = -1), (gh = 0), mt & 6)) throw Error(ee(327))
  var n = e.callbackNode
  if (Fl() && e.callbackNode !== n) return null
  var r = pp(e, e === Sn ? On : 0)
  if (r === 0) return null
  if (r & 30 || r & e.expiredLanes || t) t = Ip(e, r)
  else {
    t = r
    var i = mt
    mt |= 2
    var s = k5()
    ;(Sn !== e || On !== t) && ((ys = null), (mc = Jt() + 500), ka(e, t))
    do
      try {
        wR()
        break
      } catch (a) {
        O5(e, a)
      }
    while (1)
    W1(), (Ap.current = s), (mt = i), rn !== null ? (t = 0) : ((Sn = null), (On = 0), (t = pn))
  }
  if (t !== 0) {
    if ((t === 2 && ((i = cy(e)), i !== 0 && ((r = i), (t = Ly(e, i)))), t === 1))
      throw ((n = df), ka(e, 0), po(e, r), ur(e, Jt()), n)
    if (t === 6) po(e, r)
    else {
      if (
        ((i = e.current.alternate),
        !(r & 30) &&
          !yR(i) &&
          ((t = Ip(e, r)), t === 2 && ((s = cy(e)), s !== 0 && ((r = s), (t = Ly(e, s)))), t === 1))
      )
        throw ((n = df), ka(e, 0), po(e, r), ur(e, Jt()), n)
      switch (((e.finishedWork = i), (e.finishedLanes = r), t)) {
        case 0:
        case 1:
          throw Error(ee(345))
        case 2:
          na(e, sr, ys)
          break
        case 3:
          if ((po(e, r), (r & 130023424) === r && ((t = iw + 500 - Jt()), 10 < t))) {
            if (pp(e, 0) !== 0) break
            if (((i = e.suspendedLanes), (i & r) !== r)) {
              Kn(), (e.pingedLanes |= e.suspendedLanes & i)
              break
            }
            e.timeoutHandle = yy(na.bind(null, e, sr, ys), t)
            break
          }
          na(e, sr, ys)
          break
        case 4:
          if ((po(e, r), (r & 4194240) === r)) break
          for (t = e.eventTimes, i = -1; 0 < r; ) {
            var o = 31 - Oi(r)
            ;(s = 1 << o), (o = t[o]), o > i && (i = o), (r &= ~s)
          }
          if (
            ((r = i),
            (r = Jt() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * mR(r / 1960)) - r),
            10 < r)
          ) {
            e.timeoutHandle = yy(na.bind(null, e, sr, ys), r)
            break
          }
          na(e, sr, ys)
          break
        case 5:
          na(e, sr, ys)
          break
        default:
          throw Error(ee(329))
      }
    }
  }
  return ur(e, Jt()), e.callbackNode === n ? _5.bind(null, e) : null
}
function Ly(e, t) {
  var n = Fu
  return (
    e.current.memoizedState.isDehydrated && (ka(e, t).flags |= 256),
    (e = Ip(e, t)),
    e !== 2 && ((t = sr), (sr = n), t !== null && $y(t)),
    e
  )
}
function $y(e) {
  sr === null ? (sr = e) : sr.push.apply(sr, e)
}
function yR(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var n = t.updateQueue
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            s = i.getSnapshot
          i = i.value
          try {
            if (!Pi(s(), i)) return !1
          } catch {
            return !1
          }
        }
    }
    if (((n = t.child), t.subtreeFlags & 16384 && n !== null)) (n.return = t), (t = n)
    else {
      if (t === e) break
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0
        t = t.return
      }
      ;(t.sibling.return = t.return), (t = t.sibling)
    }
  }
  return !0
}
function po(e, t) {
  for (
    t &= ~rw, t &= ~k0, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes;
    0 < t;

  ) {
    var n = 31 - Oi(t),
      r = 1 << n
    ;(e[n] = -1), (t &= ~r)
  }
}
function qx(e) {
  if (mt & 6) throw Error(ee(327))
  Fl()
  var t = pp(e, 0)
  if (!(t & 1)) return ur(e, Jt()), null
  var n = Ip(e, t)
  if (e.tag !== 0 && n === 2) {
    var r = cy(e)
    r !== 0 && ((t = r), (n = Ly(e, r)))
  }
  if (n === 1) throw ((n = df), ka(e, 0), po(e, t), ur(e, Jt()), n)
  if (n === 6) throw Error(ee(345))
  return (
    (e.finishedWork = e.current.alternate), (e.finishedLanes = t), na(e, sr, ys), ur(e, Jt()), null
  )
}
function sw(e, t) {
  var n = mt
  mt |= 1
  try {
    return e(t)
  } finally {
    ;(mt = n), mt === 0 && ((mc = Jt() + 500), E0 && qo())
  }
}
function $a(e) {
  Co !== null && Co.tag === 0 && !(mt & 6) && Fl()
  var t = mt
  mt |= 1
  var n = Zr.transition,
    r = Tt
  try {
    if (((Zr.transition = null), (Tt = 1), e)) return e()
  } finally {
    ;(Tt = r), (Zr.transition = n), (mt = t), !(mt & 6) && qo()
  }
}
function ow() {
  ;(vr = Ol.current), Nt(Ol)
}
function ka(e, t) {
  ;(e.finishedWork = null), (e.finishedLanes = 0)
  var n = e.timeoutHandle
  if ((n !== -1 && ((e.timeoutHandle = -1), KA(n)), rn !== null))
    for (n = rn.return; n !== null; ) {
      var r = n
      switch ((B1(r), r.tag)) {
        case 1:
          ;(r = r.type.childContextTypes), r != null && wp()
          break
        case 3:
          pc(), Nt(lr), Nt(Fn), Y1()
          break
        case 5:
          G1(r)
          break
        case 4:
          pc()
          break
        case 13:
          Nt(Ut)
          break
        case 19:
          Nt(Ut)
          break
        case 10:
          V1(r.type._context)
          break
        case 22:
        case 23:
          ow()
      }
      n = n.return
    }
  if (
    ((Sn = e),
    (rn = e = Io(e.current, null)),
    (On = vr = t),
    (pn = 0),
    (df = null),
    (rw = k0 = La = 0),
    (sr = Fu = null),
    ha !== null)
  ) {
    for (t = 0; t < ha.length; t++)
      if (((n = ha[t]), (r = n.interleaved), r !== null)) {
        n.interleaved = null
        var i = r.next,
          s = n.pending
        if (s !== null) {
          var o = s.next
          ;(s.next = i), (r.next = o)
        }
        n.pending = r
      }
    ha = null
  }
  return e
}
function O5(e, t) {
  do {
    var n = rn
    try {
      if ((W1(), (fh.current = Tp), kp)) {
        for (var r = zt.memoizedState; r !== null; ) {
          var i = r.queue
          i !== null && (i.pending = null), (r = r.next)
        }
        kp = !1
      }
      if (
        ((ja = 0),
        (wn = dn = zt = null),
        (Lu = !1),
        (cf = 0),
        (nw.current = null),
        n === null || n.return === null)
      ) {
        ;(pn = 1), (df = t), (rn = null)
        break
      }
      e: {
        var s = e,
          o = n.return,
          a = n,
          l = t
        if (
          ((t = On),
          (a.flags |= 32768),
          l !== null && typeof l == 'object' && typeof l.then == 'function')
        ) {
          var c = l,
            u = a,
            f = u.tag
          if (!(u.mode & 1) && (f === 0 || f === 11 || f === 15)) {
            var d = u.alternate
            d
              ? ((u.updateQueue = d.updateQueue),
                (u.memoizedState = d.memoizedState),
                (u.lanes = d.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null))
          }
          var p = Dx(o)
          if (p !== null) {
            ;(p.flags &= -257), Nx(p, o, a, s, t), p.mode & 1 && Ix(s, c, t), (t = p), (l = c)
            var h = t.updateQueue
            if (h === null) {
              var m = new Set()
              m.add(l), (t.updateQueue = m)
            } else h.add(l)
            break e
          } else {
            if (!(t & 1)) {
              Ix(s, c, t), aw()
              break e
            }
            l = Error(ee(426))
          }
        } else if ($t && a.mode & 1) {
          var b = Dx(o)
          if (b !== null) {
            !(b.flags & 65536) && (b.flags |= 256), Nx(b, o, a, s, t), U1(gc(l, a))
            break e
          }
        }
        ;(s = l = gc(l, a)), pn !== 4 && (pn = 2), Fu === null ? (Fu = [s]) : Fu.push(s), (s = o)
        do {
          switch (s.tag) {
            case 3:
              ;(s.flags |= 65536), (t &= -t), (s.lanes |= t)
              var y = c5(s, l, t)
              _x(s, y)
              break e
            case 1:
              a = l
              var v = s.type,
                S = s.stateNode
              if (
                !(s.flags & 128) &&
                (typeof v.getDerivedStateFromError == 'function' ||
                  (S !== null &&
                    typeof S.componentDidCatch == 'function' &&
                    (Ro === null || !Ro.has(S))))
              ) {
                ;(s.flags |= 65536), (t &= -t), (s.lanes |= t)
                var T = u5(s, a, t)
                _x(s, T)
                break e
              }
          }
          s = s.return
        } while (s !== null)
      }
      A5(n)
    } catch (A) {
      ;(t = A), rn === n && n !== null && (rn = n = n.return)
      continue
    }
    break
  } while (1)
}
function k5() {
  var e = Ap.current
  return (Ap.current = Tp), e === null ? Tp : e
}
function aw() {
  ;(pn === 0 || pn === 3 || pn === 2) && (pn = 4),
    Sn === null || (!(La & 268435455) && !(k0 & 268435455)) || po(Sn, On)
}
function Ip(e, t) {
  var n = mt
  mt |= 2
  var r = k5()
  ;(Sn !== e || On !== t) && ((ys = null), ka(e, t))
  do
    try {
      vR()
      break
    } catch (i) {
      O5(e, i)
    }
  while (1)
  if ((W1(), (mt = n), (Ap.current = r), rn !== null)) throw Error(ee(261))
  return (Sn = null), (On = 0), pn
}
function vR() {
  for (; rn !== null; ) T5(rn)
}
function wR() {
  for (; rn !== null && !V4(); ) T5(rn)
}
function T5(e) {
  var t = P5(e.alternate, e, vr)
  ;(e.memoizedProps = e.pendingProps), t === null ? A5(e) : (rn = t), (nw.current = null)
}
function A5(e) {
  var t = e
  do {
    var n = t.alternate
    if (((e = t.return), t.flags & 32768)) {
      if (((n = dR(n, t)), n !== null)) {
        ;(n.flags &= 32767), (rn = n)
        return
      }
      if (e !== null) (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null)
      else {
        ;(pn = 6), (rn = null)
        return
      }
    } else if (((n = fR(n, t, vr)), n !== null)) {
      rn = n
      return
    }
    if (((t = t.sibling), t !== null)) {
      rn = t
      return
    }
    rn = t = e
  } while (t !== null)
  pn === 0 && (pn = 5)
}
function na(e, t, n) {
  var r = Tt,
    i = Zr.transition
  try {
    ;(Zr.transition = null), (Tt = 1), bR(e, t, n, r)
  } finally {
    ;(Zr.transition = i), (Tt = r)
  }
  return null
}
function bR(e, t, n, r) {
  do Fl()
  while (Co !== null)
  if (mt & 6) throw Error(ee(327))
  n = e.finishedWork
  var i = e.finishedLanes
  if (n === null) return null
  if (((e.finishedWork = null), (e.finishedLanes = 0), n === e.current)) throw Error(ee(177))
  ;(e.callbackNode = null), (e.callbackPriority = 0)
  var s = n.lanes | n.childLanes
  if (
    (eA(e, s),
    e === Sn && ((rn = Sn = null), (On = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Od ||
      ((Od = !0),
      I5(hp, function () {
        return Fl(), null
      })),
    (s = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || s)
  ) {
    ;(s = Zr.transition), (Zr.transition = null)
    var o = Tt
    Tt = 1
    var a = mt
    ;(mt |= 4),
      (nw.current = null),
      pR(e, n),
      E5(n, e),
      BA(gy),
      (gp = !!py),
      (gy = py = null),
      (e.current = n),
      gR(n),
      H4(),
      (mt = a),
      (Tt = o),
      (Zr.transition = s)
  } else e.current = n
  if (
    (Od && ((Od = !1), (Co = e), (Pp = i)),
    (s = e.pendingLanes),
    s === 0 && (Ro = null),
    G4(n.stateNode),
    ur(e, Jt()),
    t !== null)
  )
    for (r = e.onRecoverableError, n = 0; n < t.length; n++)
      (i = t[n]), r(i.value, { componentStack: i.stack, digest: i.digest })
  if (Rp) throw ((Rp = !1), (e = My), (My = null), e)
  return (
    Pp & 1 && e.tag !== 0 && Fl(),
    (s = e.pendingLanes),
    s & 1 ? (e === jy ? Bu++ : ((Bu = 0), (jy = e))) : (Bu = 0),
    qo(),
    null
  )
}
function Fl() {
  if (Co !== null) {
    var e = l3(Pp),
      t = Zr.transition,
      n = Tt
    try {
      if (((Zr.transition = null), (Tt = 16 > e ? 16 : e), Co === null)) var r = !1
      else {
        if (((e = Co), (Co = null), (Pp = 0), mt & 6)) throw Error(ee(331))
        var i = mt
        for (mt |= 4, be = e.current; be !== null; ) {
          var s = be,
            o = s.child
          if (be.flags & 16) {
            var a = s.deletions
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l]
                for (be = c; be !== null; ) {
                  var u = be
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      $u(8, u, s)
                  }
                  var f = u.child
                  if (f !== null) (f.return = u), (be = f)
                  else
                    for (; be !== null; ) {
                      u = be
                      var d = u.sibling,
                        p = u.return
                      if ((b5(u), u === c)) {
                        be = null
                        break
                      }
                      if (d !== null) {
                        ;(d.return = p), (be = d)
                        break
                      }
                      be = p
                    }
                }
              }
              var h = s.alternate
              if (h !== null) {
                var m = h.child
                if (m !== null) {
                  h.child = null
                  do {
                    var b = m.sibling
                    ;(m.sibling = null), (m = b)
                  } while (m !== null)
                }
              }
              be = s
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (be = o)
          else
            e: for (; be !== null; ) {
              if (((s = be), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    $u(9, s, s.return)
                }
              var y = s.sibling
              if (y !== null) {
                ;(y.return = s.return), (be = y)
                break e
              }
              be = s.return
            }
        }
        var v = e.current
        for (be = v; be !== null; ) {
          o = be
          var S = o.child
          if (o.subtreeFlags & 2064 && S !== null) (S.return = o), (be = S)
          else
            e: for (o = v; be !== null; ) {
              if (((a = be), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      O0(9, a)
                  }
                } catch (A) {
                  Qt(a, a.return, A)
                }
              if (a === o) {
                be = null
                break e
              }
              var T = a.sibling
              if (T !== null) {
                ;(T.return = a.return), (be = T)
                break e
              }
              be = a.return
            }
        }
        if (((mt = i), qo(), Ji && typeof Ji.onPostCommitFiberRoot == 'function'))
          try {
            Ji.onPostCommitFiberRoot(v0, e)
          } catch {}
        r = !0
      }
      return r
    } finally {
      ;(Tt = n), (Zr.transition = t)
    }
  }
  return !1
}
function Kx(e, t, n) {
  ;(t = gc(n, t)),
    (t = c5(e, t, 1)),
    (e = Ao(e, t, 1)),
    (t = Kn()),
    e !== null && (qf(e, 1, t), ur(e, t))
}
function Qt(e, t, n) {
  if (e.tag === 3) Kx(e, e, n)
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        Kx(t, e, n)
        break
      } else if (t.tag === 1) {
        var r = t.stateNode
        if (
          typeof t.type.getDerivedStateFromError == 'function' ||
          (typeof r.componentDidCatch == 'function' && (Ro === null || !Ro.has(r)))
        ) {
          ;(e = gc(n, e)),
            (e = u5(t, e, 1)),
            (t = Ao(t, e, 1)),
            (e = Kn()),
            t !== null && (qf(t, 1, e), ur(t, e))
          break
        }
      }
      t = t.return
    }
}
function xR(e, t, n) {
  var r = e.pingCache
  r !== null && r.delete(t),
    (t = Kn()),
    (e.pingedLanes |= e.suspendedLanes & n),
    Sn === e &&
      (On & n) === n &&
      (pn === 4 || (pn === 3 && (On & 130023424) === On && 500 > Jt() - iw) ? ka(e, 0) : (rw |= n)),
    ur(e, t)
}
function R5(e, t) {
  t === 0 && (e.mode & 1 ? ((t = md), (md <<= 1), !(md & 130023424) && (md = 4194304)) : (t = 1))
  var n = Kn()
  ;(e = Ds(e, t)), e !== null && (qf(e, t, n), ur(e, n))
}
function SR(e) {
  var t = e.memoizedState,
    n = 0
  t !== null && (n = t.retryLane), R5(e, n)
}
function ER(e, t) {
  var n = 0
  switch (e.tag) {
    case 13:
      var r = e.stateNode,
        i = e.memoizedState
      i !== null && (n = i.retryLane)
      break
    case 19:
      r = e.stateNode
      break
    default:
      throw Error(ee(314))
  }
  r !== null && r.delete(t), R5(e, n)
}
var P5
P5 = function (e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || lr.current) or = !0
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return (or = !1), uR(e, t, n)
      or = !!(e.flags & 131072)
    }
  else (or = !1), $t && t.flags & 1048576 && N3(t, Sp, t.index)
  switch (((t.lanes = 0), t.tag)) {
    case 2:
      var r = t.type
      hh(e, t), (e = t.pendingProps)
      var i = fc(t, Fn.current)
      $l(t, n), (i = X1(null, t, r, e, i, n))
      var s = Z1()
      return (
        (t.flags |= 1),
        typeof i == 'object' && i !== null && typeof i.render == 'function' && i.$$typeof === void 0
          ? ((t.tag = 1),
            (t.memoizedState = null),
            (t.updateQueue = null),
            cr(r) ? ((s = !0), bp(t)) : (s = !1),
            (t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null),
            q1(t),
            (i.updater = C0),
            (t.stateNode = i),
            (i._reactInternals = t),
            Cy(t, r, e, n),
            (t = ky(null, t, r, !0, s, n)))
          : ((t.tag = 0), $t && s && F1(t), qn(null, t, i, n), (t = t.child)),
        t
      )
    case 16:
      r = t.elementType
      e: {
        switch (
          (hh(e, t),
          (e = t.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (t.type = r),
          (i = t.tag = _R(r)),
          (e = pi(r, e)),
          i)
        ) {
          case 0:
            t = Oy(null, t, r, e, n)
            break e
          case 1:
            t = Lx(null, t, r, e, n)
            break e
          case 11:
            t = Mx(null, t, r, e, n)
            break e
          case 14:
            t = jx(null, t, r, pi(r.type, e), n)
            break e
        }
        throw Error(ee(306, r, ''))
      }
      return t
    case 0:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : pi(r, i)),
        Oy(e, t, r, i, n)
      )
    case 1:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : pi(r, i)),
        Lx(e, t, r, i, n)
      )
    case 3:
      e: {
        if ((p5(t), e === null)) throw Error(ee(387))
        ;(r = t.pendingProps), (s = t.memoizedState), (i = s.element), $3(e, t), _p(t, r, null, n)
        var o = t.memoizedState
        if (((r = o.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (t.updateQueue.baseState = s),
            (t.memoizedState = s),
            t.flags & 256)
          ) {
            ;(i = gc(Error(ee(423)), t)), (t = $x(e, t, r, n, i))
            break e
          } else if (r !== i) {
            ;(i = gc(Error(ee(424)), t)), (t = $x(e, t, r, n, i))
            break e
          } else
            for (
              Sr = To(t.stateNode.containerInfo.firstChild),
                Er = t,
                $t = !0,
                bi = null,
                n = z3(t, null, r, n),
                t.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling)
        else {
          if ((dc(), r === i)) {
            t = Ns(e, t, n)
            break e
          }
          qn(e, t, r, n)
        }
        t = t.child
      }
      return t
    case 5:
      return (
        W3(t),
        e === null && xy(t),
        (r = t.type),
        (i = t.pendingProps),
        (s = e !== null ? e.memoizedProps : null),
        (o = i.children),
        my(r, i) ? (o = null) : s !== null && my(r, s) && (t.flags |= 32),
        h5(e, t),
        qn(e, t, o, n),
        t.child
      )
    case 6:
      return e === null && xy(t), null
    case 13:
      return g5(e, t, n)
    case 4:
      return (
        K1(t, t.stateNode.containerInfo),
        (r = t.pendingProps),
        e === null ? (t.child = hc(t, null, r, n)) : qn(e, t, r, n),
        t.child
      )
    case 11:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : pi(r, i)),
        Mx(e, t, r, i, n)
      )
    case 7:
      return qn(e, t, t.pendingProps, n), t.child
    case 8:
      return qn(e, t, t.pendingProps.children, n), t.child
    case 12:
      return qn(e, t, t.pendingProps.children, n), t.child
    case 10:
      e: {
        if (
          ((r = t.type._context),
          (i = t.pendingProps),
          (s = t.memoizedProps),
          (o = i.value),
          Rt(Ep, r._currentValue),
          (r._currentValue = o),
          s !== null)
        )
          if (Pi(s.value, o)) {
            if (s.children === i.children && !lr.current) {
              t = Ns(e, t, n)
              break e
            }
          } else
            for (s = t.child, s !== null && (s.return = t); s !== null; ) {
              var a = s.dependencies
              if (a !== null) {
                o = s.child
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (s.tag === 1) {
                      ;(l = As(-1, n & -n)), (l.tag = 2)
                      var c = s.updateQueue
                      if (c !== null) {
                        c = c.shared
                        var u = c.pending
                        u === null ? (l.next = l) : ((l.next = u.next), (u.next = l)),
                          (c.pending = l)
                      }
                    }
                    ;(s.lanes |= n),
                      (l = s.alternate),
                      l !== null && (l.lanes |= n),
                      Sy(s.return, n, t),
                      (a.lanes |= n)
                    break
                  }
                  l = l.next
                }
              } else if (s.tag === 10) o = s.type === t.type ? null : s.child
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(ee(341))
                ;(o.lanes |= n),
                  (a = o.alternate),
                  a !== null && (a.lanes |= n),
                  Sy(o, n, t),
                  (o = s.sibling)
              } else o = s.child
              if (o !== null) o.return = s
              else
                for (o = s; o !== null; ) {
                  if (o === t) {
                    o = null
                    break
                  }
                  if (((s = o.sibling), s !== null)) {
                    ;(s.return = o.return), (o = s)
                    break
                  }
                  o = o.return
                }
              s = o
            }
        qn(e, t, i.children, n), (t = t.child)
      }
      return t
    case 9:
      return (
        (i = t.type),
        (r = t.pendingProps.children),
        $l(t, n),
        (i = ei(i)),
        (r = r(i)),
        (t.flags |= 1),
        qn(e, t, r, n),
        t.child
      )
    case 14:
      return (r = t.type), (i = pi(r, t.pendingProps)), (i = pi(r.type, i)), jx(e, t, r, i, n)
    case 15:
      return f5(e, t, t.type, t.pendingProps, n)
    case 17:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : pi(r, i)),
        hh(e, t),
        (t.tag = 1),
        cr(r) ? ((e = !0), bp(t)) : (e = !1),
        $l(t, n),
        B3(t, r, i),
        Cy(t, r, i, n),
        ky(null, t, r, !0, e, n)
      )
    case 19:
      return m5(e, t, n)
    case 22:
      return d5(e, t, n)
  }
  throw Error(ee(156, t.tag))
}
function I5(e, t) {
  return i3(e, t)
}
function CR(e, t, n, r) {
  ;(this.tag = e),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = t),
    (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null)
}
function Xr(e, t, n, r) {
  return new CR(e, t, n, r)
}
function lw(e) {
  return (e = e.prototype), !(!e || !e.isReactComponent)
}
function _R(e) {
  if (typeof e == 'function') return lw(e) ? 1 : 0
  if (e != null) {
    if (((e = e.$$typeof), e === k1)) return 11
    if (e === T1) return 14
  }
  return 2
}
function Io(e, t) {
  var n = e.alternate
  return (
    n === null
      ? ((n = Xr(e.tag, t, e.key, e.mode)),
        (n.elementType = e.elementType),
        (n.type = e.type),
        (n.stateNode = e.stateNode),
        (n.alternate = e),
        (e.alternate = n))
      : ((n.pendingProps = t),
        (n.type = e.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = e.flags & 14680064),
    (n.childLanes = e.childLanes),
    (n.lanes = e.lanes),
    (n.child = e.child),
    (n.memoizedProps = e.memoizedProps),
    (n.memoizedState = e.memoizedState),
    (n.updateQueue = e.updateQueue),
    (t = e.dependencies),
    (n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }),
    (n.sibling = e.sibling),
    (n.index = e.index),
    (n.ref = e.ref),
    n
  )
}
function mh(e, t, n, r, i, s) {
  var o = 2
  if (((r = e), typeof e == 'function')) lw(e) && (o = 1)
  else if (typeof e == 'string') o = 5
  else
    e: switch (e) {
      case ml:
        return Ta(n.children, i, s, t)
      case O1:
        ;(o = 8), (i |= 8)
        break
      case Gm:
        return (e = Xr(12, n, t, i | 2)), (e.elementType = Gm), (e.lanes = s), e
      case Ym:
        return (e = Xr(13, n, t, i)), (e.elementType = Ym), (e.lanes = s), e
      case Qm:
        return (e = Xr(19, n, t, i)), (e.elementType = Qm), (e.lanes = s), e
      case UC:
        return T0(n, i, s, t)
      default:
        if (typeof e == 'object' && e !== null)
          switch (e.$$typeof) {
            case FC:
              o = 10
              break e
            case BC:
              o = 9
              break e
            case k1:
              o = 11
              break e
            case T1:
              o = 14
              break e
            case co:
              ;(o = 16), (r = null)
              break e
          }
        throw Error(ee(130, e == null ? e : typeof e, ''))
    }
  return (t = Xr(o, n, t, i)), (t.elementType = e), (t.type = r), (t.lanes = s), t
}
function Ta(e, t, n, r) {
  return (e = Xr(7, e, r, t)), (e.lanes = n), e
}
function T0(e, t, n, r) {
  return (
    (e = Xr(22, e, r, t)), (e.elementType = UC), (e.lanes = n), (e.stateNode = { isHidden: !1 }), e
  )
}
function qg(e, t, n) {
  return (e = Xr(6, e, null, t)), (e.lanes = n), e
}
function Kg(e, t, n) {
  return (
    (t = Xr(4, e.children !== null ? e.children : [], e.key, t)),
    (t.lanes = n),
    (t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation,
    }),
    t
  )
}
function OR(e, t, n, r, i) {
  ;(this.tag = t),
    (this.containerInfo = e),
    (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = kg(0)),
    (this.expirationTimes = kg(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = kg(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null)
}
function cw(e, t, n, r, i, s, o, a, l) {
  return (
    (e = new OR(e, t, n, a, l)),
    t === 1 ? ((t = 1), s === !0 && (t |= 8)) : (t = 0),
    (s = Xr(3, null, null, t)),
    (e.current = s),
    (s.stateNode = e),
    (s.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    q1(s),
    e
  )
}
function kR(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
  return {
    $$typeof: gl,
    key: r == null ? null : '' + r,
    children: e,
    containerInfo: t,
    implementation: n,
  }
}
function D5(e) {
  if (!e) return $o
  e = e._reactInternals
  e: {
    if (qa(e) !== e || e.tag !== 1) throw Error(ee(170))
    var t = e
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context
          break e
        case 1:
          if (cr(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext
            break e
          }
      }
      t = t.return
    } while (t !== null)
    throw Error(ee(171))
  }
  if (e.tag === 1) {
    var n = e.type
    if (cr(n)) return I3(e, n, t)
  }
  return t
}
function N5(e, t, n, r, i, s, o, a, l) {
  return (
    (e = cw(n, r, !0, e, i, s, o, a, l)),
    (e.context = D5(null)),
    (n = e.current),
    (r = Kn()),
    (i = Po(n)),
    (s = As(r, i)),
    (s.callback = t ?? null),
    Ao(n, s, i),
    (e.current.lanes = i),
    qf(e, i, r),
    ur(e, r),
    e
  )
}
function A0(e, t, n, r) {
  var i = t.current,
    s = Kn(),
    o = Po(i)
  return (
    (n = D5(n)),
    t.context === null ? (t.context = n) : (t.pendingContext = n),
    (t = As(s, o)),
    (t.payload = { element: e }),
    (r = r === void 0 ? null : r),
    r !== null && (t.callback = r),
    (e = Ao(i, t, o)),
    e !== null && (ki(e, i, o, s), uh(e, i, o)),
    o
  )
}
function Dp(e) {
  if (((e = e.current), !e.child)) return null
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode
    default:
      return e.child.stateNode
  }
}
function Gx(e, t) {
  if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
    var n = e.retryLane
    e.retryLane = n !== 0 && n < t ? n : t
  }
}
function uw(e, t) {
  Gx(e, t), (e = e.alternate) && Gx(e, t)
}
function TR() {
  return null
}
var M5 =
  typeof reportError == 'function'
    ? reportError
    : function (e) {
        console.error(e)
      }
function fw(e) {
  this._internalRoot = e
}
R0.prototype.render = fw.prototype.render = function (e) {
  var t = this._internalRoot
  if (t === null) throw Error(ee(409))
  A0(e, t, null, null)
}
R0.prototype.unmount = fw.prototype.unmount = function () {
  var e = this._internalRoot
  if (e !== null) {
    this._internalRoot = null
    var t = e.containerInfo
    $a(function () {
      A0(null, e, null, null)
    }),
      (t[Is] = null)
  }
}
function R0(e) {
  this._internalRoot = e
}
R0.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = f3()
    e = { blockedOn: null, target: e, priority: t }
    for (var n = 0; n < ho.length && t !== 0 && t < ho[n].priority; n++);
    ho.splice(n, 0, e), n === 0 && h3(e)
  }
}
function dw(e) {
  return !(!e || (e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11))
}
function P0(e) {
  return !(
    !e ||
    (e.nodeType !== 1 &&
      e.nodeType !== 9 &&
      e.nodeType !== 11 &&
      (e.nodeType !== 8 || e.nodeValue !== ' react-mount-point-unstable '))
  )
}
function Yx() {}
function AR(e, t, n, r, i) {
  if (i) {
    if (typeof r == 'function') {
      var s = r
      r = function () {
        var c = Dp(o)
        s.call(c)
      }
    }
    var o = N5(t, r, e, 0, null, !1, !1, '', Yx)
    return (
      (e._reactRootContainer = o),
      (e[Is] = o.current),
      rf(e.nodeType === 8 ? e.parentNode : e),
      $a(),
      o
    )
  }
  for (; (i = e.lastChild); ) e.removeChild(i)
  if (typeof r == 'function') {
    var a = r
    r = function () {
      var c = Dp(l)
      a.call(c)
    }
  }
  var l = cw(e, 0, !1, null, null, !1, !1, '', Yx)
  return (
    (e._reactRootContainer = l),
    (e[Is] = l.current),
    rf(e.nodeType === 8 ? e.parentNode : e),
    $a(function () {
      A0(t, l, n, r)
    }),
    l
  )
}
function I0(e, t, n, r, i) {
  var s = n._reactRootContainer
  if (s) {
    var o = s
    if (typeof i == 'function') {
      var a = i
      i = function () {
        var l = Dp(o)
        a.call(l)
      }
    }
    A0(t, o, e, i)
  } else o = AR(n, t, e, i, r)
  return Dp(o)
}
c3 = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode
      if (t.current.memoizedState.isDehydrated) {
        var n = yu(t.pendingLanes)
        n !== 0 && (P1(t, n | 1), ur(t, Jt()), !(mt & 6) && ((mc = Jt() + 500), qo()))
      }
      break
    case 13:
      $a(function () {
        var r = Ds(e, 1)
        if (r !== null) {
          var i = Kn()
          ki(r, e, 1, i)
        }
      }),
        uw(e, 1)
  }
}
I1 = function (e) {
  if (e.tag === 13) {
    var t = Ds(e, 134217728)
    if (t !== null) {
      var n = Kn()
      ki(t, e, 134217728, n)
    }
    uw(e, 134217728)
  }
}
u3 = function (e) {
  if (e.tag === 13) {
    var t = Po(e),
      n = Ds(e, t)
    if (n !== null) {
      var r = Kn()
      ki(n, e, t, r)
    }
    uw(e, t)
  }
}
f3 = function () {
  return Tt
}
d3 = function (e, t) {
  var n = Tt
  try {
    return (Tt = e), t()
  } finally {
    Tt = n
  }
}
oy = function (e, t, n) {
  switch (t) {
    case 'input':
      if ((Jm(e, n), (t = n.name), n.type === 'radio' && t != null)) {
        for (n = e; n.parentNode; ) n = n.parentNode
        for (
          n = n.querySelectorAll('input[name=' + JSON.stringify('' + t) + '][type="radio"]'), t = 0;
          t < n.length;
          t++
        ) {
          var r = n[t]
          if (r !== e && r.form === e.form) {
            var i = S0(r)
            if (!i) throw Error(ee(90))
            WC(r), Jm(r, i)
          }
        }
      }
      break
    case 'textarea':
      HC(e, n)
      break
    case 'select':
      ;(t = n.value), t != null && Nl(e, !!n.multiple, t, !1)
  }
}
ZC = sw
JC = $a
var RR = { usingClientEntryPoint: !1, Events: [Gf, bl, S0, QC, XC, sw] },
  ru = {
    findFiberByHostInstance: da,
    bundleType: 0,
    version: '18.2.0',
    rendererPackageName: 'react-dom',
  },
  PR = {
    bundleType: ru.bundleType,
    version: ru.version,
    rendererPackageName: ru.rendererPackageName,
    rendererConfig: ru.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Fs.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return (e = n3(e)), e === null ? null : e.stateNode
    },
    findFiberByHostInstance: ru.findFiberByHostInstance || TR,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: '18.2.0-next-9e3b772b8-20220608',
  }
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
  var kd = __REACT_DEVTOOLS_GLOBAL_HOOK__
  if (!kd.isDisabled && kd.supportsFiber)
    try {
      ;(v0 = kd.inject(PR)), (Ji = kd)
    } catch {}
}
Rr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = RR
Rr.createPortal = function (e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  if (!dw(t)) throw Error(ee(200))
  return kR(e, t, null, n)
}
Rr.createRoot = function (e, t) {
  if (!dw(e)) throw Error(ee(299))
  var n = !1,
    r = '',
    i = M5
  return (
    t != null &&
      (t.unstable_strictMode === !0 && (n = !0),
      t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (i = t.onRecoverableError)),
    (t = cw(e, 1, !1, null, null, n, !1, r, i)),
    (e[Is] = t.current),
    rf(e.nodeType === 8 ? e.parentNode : e),
    new fw(t)
  )
}
Rr.findDOMNode = function (e) {
  if (e == null) return null
  if (e.nodeType === 1) return e
  var t = e._reactInternals
  if (t === void 0)
    throw typeof e.render == 'function'
      ? Error(ee(188))
      : ((e = Object.keys(e).join(',')), Error(ee(268, e)))
  return (e = n3(t)), (e = e === null ? null : e.stateNode), e
}
Rr.flushSync = function (e) {
  return $a(e)
}
Rr.hydrate = function (e, t, n) {
  if (!P0(t)) throw Error(ee(200))
  return I0(null, e, t, !0, n)
}
Rr.hydrateRoot = function (e, t, n) {
  if (!dw(e)) throw Error(ee(405))
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    s = '',
    o = M5
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (o = n.onRecoverableError)),
    (t = N5(t, null, e, 1, n ?? null, i, !1, s, o)),
    (e[Is] = t.current),
    rf(e),
    r)
  )
    for (e = 0; e < r.length; e++)
      (n = r[e]),
        (i = n._getVersion),
        (i = i(n._source)),
        t.mutableSourceEagerHydrationData == null
          ? (t.mutableSourceEagerHydrationData = [n, i])
          : t.mutableSourceEagerHydrationData.push(n, i)
  return new R0(t)
}
Rr.render = function (e, t, n) {
  if (!P0(t)) throw Error(ee(200))
  return I0(null, e, t, !1, n)
}
Rr.unmountComponentAtNode = function (e) {
  if (!P0(e)) throw Error(ee(40))
  return e._reactRootContainer
    ? ($a(function () {
        I0(null, null, e, !1, function () {
          ;(e._reactRootContainer = null), (e[Is] = null)
        })
      }),
      !0)
    : !1
}
Rr.unstable_batchedUpdates = sw
Rr.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
  if (!P0(n)) throw Error(ee(200))
  if (e == null || e._reactInternals === void 0) throw Error(ee(38))
  return I0(e, t, n, !1, r)
}
Rr.version = '18.2.0-next-9e3b772b8-20220608'
function j5() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(j5)
    } catch (e) {
      console.error(e)
    }
}
j5(), (NC.exports = Rr)
var jc = NC.exports
const L5 = Ic(jc),
  IR = EC({ __proto__: null, default: L5 }, [jc])
var Qx = jc
;(qm.createRoot = Qx.createRoot), (qm.hydrateRoot = Qx.hydrateRoot)
var DR = {}
/**
 * @license React
 * use-sync-external-store-with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Qf = w
function NR(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var MR = typeof Object.is == 'function' ? Object.is : NR,
  jR = Qf.useSyncExternalStore,
  LR = Qf.useRef,
  $R = Qf.useEffect,
  FR = Qf.useMemo,
  BR = Qf.useDebugValue
DR.useSyncExternalStoreWithSelector = function (e, t, n, r, i) {
  var s = LR(null)
  if (s.current === null) {
    var o = { hasValue: !1, value: null }
    s.current = o
  } else o = s.current
  s = FR(
    function () {
      function l(p) {
        if (!c) {
          if (((c = !0), (u = p), (p = r(p)), i !== void 0 && o.hasValue)) {
            var h = o.value
            if (i(h, p)) return (f = h)
          }
          return (f = p)
        }
        if (((h = f), MR(u, p))) return h
        var m = r(p)
        return i !== void 0 && i(h, m) ? h : ((u = p), (f = m))
      }
      var c = !1,
        u,
        f,
        d = n === void 0 ? null : n
      return [
        function () {
          return l(t())
        },
        d === null
          ? void 0
          : function () {
              return l(d())
            },
      ]
    },
    [t, n, r, i]
  )
  var a = jR(e, s[0], s[1])
  return (
    $R(
      function () {
        ;(o.hasValue = !0), (o.value = a)
      },
      [a]
    ),
    BR(a),
    a
  )
}
var Xi = 'default' in cp ? fn : cp,
  Xx = Symbol.for('react-redux-context'),
  Zx = typeof globalThis < 'u' ? globalThis : {}
function UR() {
  if (!Xi.createContext) return {}
  const e = Zx[Xx] ?? (Zx[Xx] = new Map())
  let t = e.get(Xi.createContext)
  return t || ((t = Xi.createContext(null)), e.set(Xi.createContext, t)), t
}
var yc = UR()
function $5(e = yc) {
  return function () {
    return Xi.useContext(e)
  }
}
var zR = $5()
function WR(e) {
  e()
}
function VR() {
  let e = null,
    t = null
  return {
    clear() {
      ;(e = null), (t = null)
    },
    notify() {
      WR(() => {
        let n = e
        for (; n; ) n.callback(), (n = n.next)
      })
    },
    get() {
      const n = []
      let r = e
      for (; r; ) n.push(r), (r = r.next)
      return n
    },
    subscribe(n) {
      let r = !0
      const i = (t = { callback: n, next: null, prev: t })
      return (
        i.prev ? (i.prev.next = i) : (e = i),
        function () {
          !r ||
            e === null ||
            ((r = !1),
            i.next ? (i.next.prev = i.prev) : (t = i.prev),
            i.prev ? (i.prev.next = i.next) : (e = i.next))
        }
      )
    },
  }
}
var Jx = { notify() {}, get: () => [] }
function HR(e, t) {
  let n,
    r = Jx,
    i = 0,
    s = !1
  function o(m) {
    u()
    const b = r.subscribe(m)
    let y = !1
    return () => {
      y || ((y = !0), b(), f())
    }
  }
  function a() {
    r.notify()
  }
  function l() {
    h.onStateChange && h.onStateChange()
  }
  function c() {
    return s
  }
  function u() {
    i++, n || ((n = t ? t.addNestedSub(l) : e.subscribe(l)), (r = VR()))
  }
  function f() {
    i--, n && i === 0 && (n(), (n = void 0), r.clear(), (r = Jx))
  }
  function d() {
    s || ((s = !0), u())
  }
  function p() {
    s && ((s = !1), f())
  }
  const h = {
    addNestedSub: o,
    notifyNestedSubs: a,
    handleChangeWrapper: l,
    isSubscribed: c,
    trySubscribe: d,
    tryUnsubscribe: p,
    getListeners: () => r,
  }
  return h
}
var qR =
    typeof window < 'u' &&
    typeof window.document < 'u' &&
    typeof window.document.createElement < 'u',
  KR = typeof navigator < 'u' && navigator.product === 'ReactNative',
  GR = qR || KR ? Xi.useLayoutEffect : Xi.useEffect
function YR({
  store: e,
  context: t,
  children: n,
  serverState: r,
  stabilityCheck: i = 'once',
  identityFunctionCheck: s = 'once',
}) {
  const o = Xi.useMemo(() => {
      const c = HR(e)
      return {
        store: e,
        subscription: c,
        getServerState: r ? () => r : void 0,
        stabilityCheck: i,
        identityFunctionCheck: s,
      }
    }, [e, r, i, s]),
    a = Xi.useMemo(() => e.getState(), [e])
  GR(() => {
    const { subscription: c } = o
    return (
      (c.onStateChange = c.notifyNestedSubs),
      c.trySubscribe(),
      a !== e.getState() && c.notifyNestedSubs(),
      () => {
        c.tryUnsubscribe(), (c.onStateChange = void 0)
      }
    )
  }, [o, a])
  const l = t || yc
  return Xi.createElement(l.Provider, { value: o }, n)
}
var QR = YR
function F5(e = yc) {
  const t = e === yc ? zR : $5(e),
    n = () => {
      const { store: r } = t()
      return r
    }
  return Object.assign(n, { withTypes: () => n }), n
}
var XR = F5()
function ZR(e = yc) {
  const t = e === yc ? XR : F5(e),
    n = () => t().dispatch
  return Object.assign(n, { withTypes: () => n }), n
}
var JR = ZR()
/**
 * @remix-run/router v1.16.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Bt() {
  return (
    (Bt = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Bt.apply(this, arguments)
  )
}
var Zt
;(function (e) {
  ;(e.Pop = 'POP'), (e.Push = 'PUSH'), (e.Replace = 'REPLACE')
})(Zt || (Zt = {}))
const e2 = 'popstate'
function eP(e) {
  e === void 0 && (e = {})
  function t(r, i) {
    let { pathname: s, search: o, hash: a } = r.location
    return hf(
      '',
      { pathname: s, search: o, hash: a },
      (i.state && i.state.usr) || null,
      (i.state && i.state.key) || 'default'
    )
  }
  function n(r, i) {
    return typeof i == 'string' ? i : Xf(i)
  }
  return nP(t, n, null, e)
}
function ot(e, t) {
  if (e === !1 || e === null || typeof e > 'u') throw new Error(t)
}
function vc(e, t) {
  if (!e) {
    typeof console < 'u' && console.warn(t)
    try {
      throw new Error(t)
    } catch {}
  }
}
function tP() {
  return Math.random().toString(36).substr(2, 8)
}
function t2(e, t) {
  return { usr: e.state, key: e.key, idx: t }
}
function hf(e, t, n, r) {
  return (
    n === void 0 && (n = null),
    Bt(
      { pathname: typeof e == 'string' ? e : e.pathname, search: '', hash: '' },
      typeof t == 'string' ? Bs(t) : t,
      { state: n, key: (t && t.key) || r || tP() }
    )
  )
}
function Xf(e) {
  let { pathname: t = '/', search: n = '', hash: r = '' } = e
  return (
    n && n !== '?' && (t += n.charAt(0) === '?' ? n : '?' + n),
    r && r !== '#' && (t += r.charAt(0) === '#' ? r : '#' + r),
    t
  )
}
function Bs(e) {
  let t = {}
  if (e) {
    let n = e.indexOf('#')
    n >= 0 && ((t.hash = e.substr(n)), (e = e.substr(0, n)))
    let r = e.indexOf('?')
    r >= 0 && ((t.search = e.substr(r)), (e = e.substr(0, r))), e && (t.pathname = e)
  }
  return t
}
function nP(e, t, n, r) {
  r === void 0 && (r = {})
  let { window: i = document.defaultView, v5Compat: s = !1 } = r,
    o = i.history,
    a = Zt.Pop,
    l = null,
    c = u()
  c == null && ((c = 0), o.replaceState(Bt({}, o.state, { idx: c }), ''))
  function u() {
    return (o.state || { idx: null }).idx
  }
  function f() {
    a = Zt.Pop
    let b = u(),
      y = b == null ? null : b - c
    ;(c = b), l && l({ action: a, location: m.location, delta: y })
  }
  function d(b, y) {
    a = Zt.Push
    let v = hf(m.location, b, y)
    n && n(v, b), (c = u() + 1)
    let S = t2(v, c),
      T = m.createHref(v)
    try {
      o.pushState(S, '', T)
    } catch (A) {
      if (A instanceof DOMException && A.name === 'DataCloneError') throw A
      i.location.assign(T)
    }
    s && l && l({ action: a, location: m.location, delta: 1 })
  }
  function p(b, y) {
    a = Zt.Replace
    let v = hf(m.location, b, y)
    n && n(v, b), (c = u())
    let S = t2(v, c),
      T = m.createHref(v)
    o.replaceState(S, '', T), s && l && l({ action: a, location: m.location, delta: 0 })
  }
  function h(b) {
    let y = i.location.origin !== 'null' ? i.location.origin : i.location.href,
      v = typeof b == 'string' ? b : Xf(b)
    return (
      (v = v.replace(/ $/, '%20')),
      ot(y, 'No window.location.(origin|href) available to create URL for href: ' + v),
      new URL(v, y)
    )
  }
  let m = {
    get action() {
      return a
    },
    get location() {
      return e(i, o)
    },
    listen(b) {
      if (l) throw new Error('A history only accepts one active listener')
      return (
        i.addEventListener(e2, f),
        (l = b),
        () => {
          i.removeEventListener(e2, f), (l = null)
        }
      )
    },
    createHref(b) {
      return t(i, b)
    },
    createURL: h,
    encodeLocation(b) {
      let y = h(b)
      return { pathname: y.pathname, search: y.search, hash: y.hash }
    },
    push: d,
    replace: p,
    go(b) {
      return o.go(b)
    },
  }
  return m
}
var jt
;(function (e) {
  ;(e.data = 'data'), (e.deferred = 'deferred'), (e.redirect = 'redirect'), (e.error = 'error')
})(jt || (jt = {}))
const rP = new Set(['lazy', 'caseSensitive', 'path', 'id', 'index', 'children'])
function iP(e) {
  return e.index === !0
}
function Fy(e, t, n, r) {
  return (
    n === void 0 && (n = []),
    r === void 0 && (r = {}),
    e.map((i, s) => {
      let o = [...n, s],
        a = typeof i.id == 'string' ? i.id : o.join('-')
      if (
        (ot(i.index !== !0 || !i.children, 'Cannot specify children on an index route'),
        ot(
          !r[a],
          'Found a route id collision on id "' +
            a +
            `".  Route id's must be globally unique within Data Router usages`
        ),
        iP(i))
      ) {
        let l = Bt({}, i, t(i), { id: a })
        return (r[a] = l), l
      } else {
        let l = Bt({}, i, t(i), { id: a, children: void 0 })
        return (r[a] = l), i.children && (l.children = Fy(i.children, t, o, r)), l
      }
    })
  )
}
function kl(e, t, n) {
  n === void 0 && (n = '/')
  let r = typeof t == 'string' ? Bs(t) : t,
    i = Zf(r.pathname || '/', n)
  if (i == null) return null
  let s = B5(e)
  oP(s)
  let o = null
  for (let a = 0; o == null && a < s.length; ++a) {
    let l = vP(i)
    o = gP(s[a], l)
  }
  return o
}
function sP(e, t) {
  let { route: n, pathname: r, params: i } = e
  return { id: n.id, pathname: r, params: i, data: t[n.id], handle: n.handle }
}
function B5(e, t, n, r) {
  t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = '')
  let i = (s, o, a) => {
    let l = {
      relativePath: a === void 0 ? s.path || '' : a,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: o,
      route: s,
    }
    l.relativePath.startsWith('/') &&
      (ot(
        l.relativePath.startsWith(r),
        'Absolute route path "' +
          l.relativePath +
          '" nested under path ' +
          ('"' + r + '" is not valid. An absolute child route path ') +
          'must start with the combined path of all its parent routes.'
      ),
      (l.relativePath = l.relativePath.slice(r.length)))
    let c = Do([r, l.relativePath]),
      u = n.concat(l)
    s.children &&
      s.children.length > 0 &&
      (ot(
        s.index !== !0,
        'Index routes must not have child routes. Please remove ' +
          ('all child routes from route path "' + c + '".')
      ),
      B5(s.children, t, u, c)),
      !(s.path == null && !s.index) && t.push({ path: c, score: hP(c, s.index), routesMeta: u })
  }
  return (
    e.forEach((s, o) => {
      var a
      if (s.path === '' || !((a = s.path) != null && a.includes('?'))) i(s, o)
      else for (let l of U5(s.path)) i(s, o, l)
    }),
    t
  )
}
function U5(e) {
  let t = e.split('/')
  if (t.length === 0) return []
  let [n, ...r] = t,
    i = n.endsWith('?'),
    s = n.replace(/\?$/, '')
  if (r.length === 0) return i ? [s, ''] : [s]
  let o = U5(r.join('/')),
    a = []
  return (
    a.push(...o.map((l) => (l === '' ? s : [s, l].join('/')))),
    i && a.push(...o),
    a.map((l) => (e.startsWith('/') && l === '' ? '/' : l))
  )
}
function oP(e) {
  e.sort((t, n) =>
    t.score !== n.score
      ? n.score - t.score
      : pP(
          t.routesMeta.map((r) => r.childrenIndex),
          n.routesMeta.map((r) => r.childrenIndex)
        )
  )
}
const aP = /^:[\w-]+$/,
  lP = 3,
  cP = 2,
  uP = 1,
  fP = 10,
  dP = -2,
  n2 = (e) => e === '*'
function hP(e, t) {
  let n = e.split('/'),
    r = n.length
  return (
    n.some(n2) && (r += dP),
    t && (r += cP),
    n.filter((i) => !n2(i)).reduce((i, s) => i + (aP.test(s) ? lP : s === '' ? uP : fP), r)
  )
}
function pP(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i])
    ? e[e.length - 1] - t[t.length - 1]
    : 0
}
function gP(e, t) {
  let { routesMeta: n } = e,
    r = {},
    i = '/',
    s = []
  for (let o = 0; o < n.length; ++o) {
    let a = n[o],
      l = o === n.length - 1,
      c = i === '/' ? t : t.slice(i.length) || '/',
      u = mP({ path: a.relativePath, caseSensitive: a.caseSensitive, end: l }, c)
    if (!u) return null
    Object.assign(r, u.params)
    let f = a.route
    s.push({
      params: r,
      pathname: Do([i, u.pathname]),
      pathnameBase: xP(Do([i, u.pathnameBase])),
      route: f,
    }),
      u.pathnameBase !== '/' && (i = Do([i, u.pathnameBase]))
  }
  return s
}
function mP(e, t) {
  typeof e == 'string' && (e = { path: e, caseSensitive: !1, end: !0 })
  let [n, r] = yP(e.path, e.caseSensitive, e.end),
    i = t.match(n)
  if (!i) return null
  let s = i[0],
    o = s.replace(/(.)\/+$/, '$1'),
    a = i.slice(1)
  return {
    params: r.reduce((c, u, f) => {
      let { paramName: d, isOptional: p } = u
      if (d === '*') {
        let m = a[f] || ''
        o = s.slice(0, s.length - m.length).replace(/(.)\/+$/, '$1')
      }
      const h = a[f]
      return p && !h ? (c[d] = void 0) : (c[d] = (h || '').replace(/%2F/g, '/')), c
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: e,
  }
}
function yP(e, t, n) {
  t === void 0 && (t = !1),
    n === void 0 && (n = !0),
    vc(
      e === '*' || !e.endsWith('*') || e.endsWith('/*'),
      'Route path "' +
        e +
        '" will be treated as if it were ' +
        ('"' + e.replace(/\*$/, '/*') + '" because the `*` character must ') +
        'always follow a `/` in the pattern. To get rid of this warning, ' +
        ('please change the route path to "' + e.replace(/\*$/, '/*') + '".')
    )
  let r = [],
    i =
      '^' +
      e
        .replace(/\/*\*?$/, '')
        .replace(/^\/*/, '/')
        .replace(/[\\.*+^${}|()[\]]/g, '\\$&')
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (o, a, l) => (
            r.push({ paramName: a, isOptional: l != null }), l ? '/?([^\\/]+)?' : '/([^\\/]+)'
          )
        )
  return (
    e.endsWith('*')
      ? (r.push({ paramName: '*' }), (i += e === '*' || e === '/*' ? '(.*)$' : '(?:\\/(.+)|\\/*)$'))
      : n
      ? (i += '\\/*$')
      : e !== '' && e !== '/' && (i += '(?:(?=\\/|$))'),
    [new RegExp(i, t ? void 0 : 'i'), r]
  )
}
function vP(e) {
  try {
    return e
      .split('/')
      .map((t) => decodeURIComponent(t).replace(/\//g, '%2F'))
      .join('/')
  } catch (t) {
    return (
      vc(
        !1,
        'The URL path "' +
          e +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ('encoding (' + t + ').')
      ),
      e
    )
  }
}
function Zf(e, t) {
  if (t === '/') return e
  if (!e.toLowerCase().startsWith(t.toLowerCase())) return null
  let n = t.endsWith('/') ? t.length - 1 : t.length,
    r = e.charAt(n)
  return r && r !== '/' ? null : e.slice(n) || '/'
}
function wP(e, t) {
  t === void 0 && (t = '/')
  let { pathname: n, search: r = '', hash: i = '' } = typeof e == 'string' ? Bs(e) : e
  return { pathname: n ? (n.startsWith('/') ? n : bP(n, t)) : t, search: SP(r), hash: EP(i) }
}
function bP(e, t) {
  let n = t.replace(/\/+$/, '').split('/')
  return (
    e.split('/').forEach((i) => {
      i === '..' ? n.length > 1 && n.pop() : i !== '.' && n.push(i)
    }),
    n.length > 1 ? n.join('/') : '/'
  )
}
function Gg(e, t, n, r) {
  return (
    "Cannot include a '" +
    e +
    "' character in a manually specified " +
    ('`to.' + t + '` field [' + JSON.stringify(r) + '].  Please separate it out to the ') +
    ('`to.' + n + '` field. Alternatively you may provide the full path as ') +
    'a string in <Link to="..."> and the router will parse it for you.'
  )
}
function z5(e) {
  return e.filter((t, n) => n === 0 || (t.route.path && t.route.path.length > 0))
}
function W5(e, t) {
  let n = z5(e)
  return t
    ? n.map((r, i) => (i === e.length - 1 ? r.pathname : r.pathnameBase))
    : n.map((r) => r.pathnameBase)
}
function V5(e, t, n, r) {
  r === void 0 && (r = !1)
  let i
  typeof e == 'string'
    ? (i = Bs(e))
    : ((i = Bt({}, e)),
      ot(!i.pathname || !i.pathname.includes('?'), Gg('?', 'pathname', 'search', i)),
      ot(!i.pathname || !i.pathname.includes('#'), Gg('#', 'pathname', 'hash', i)),
      ot(!i.search || !i.search.includes('#'), Gg('#', 'search', 'hash', i)))
  let s = e === '' || i.pathname === '',
    o = s ? '/' : i.pathname,
    a
  if (o == null) a = n
  else {
    let f = t.length - 1
    if (!r && o.startsWith('..')) {
      let d = o.split('/')
      for (; d[0] === '..'; ) d.shift(), (f -= 1)
      i.pathname = d.join('/')
    }
    a = f >= 0 ? t[f] : '/'
  }
  let l = wP(i, a),
    c = o && o !== '/' && o.endsWith('/'),
    u = (s || o === '.') && n.endsWith('/')
  return !l.pathname.endsWith('/') && (c || u) && (l.pathname += '/'), l
}
const Do = (e) => e.join('/').replace(/\/\/+/g, '/'),
  xP = (e) => e.replace(/\/+$/, '').replace(/^\/*/, '/'),
  SP = (e) => (!e || e === '?' ? '' : e.startsWith('?') ? e : '?' + e),
  EP = (e) => (!e || e === '#' ? '' : e.startsWith('#') ? e : '#' + e)
class hw {
  constructor(t, n, r, i) {
    i === void 0 && (i = !1),
      (this.status = t),
      (this.statusText = n || ''),
      (this.internal = i),
      r instanceof Error ? ((this.data = r.toString()), (this.error = r)) : (this.data = r)
  }
}
function pw(e) {
  return (
    e != null &&
    typeof e.status == 'number' &&
    typeof e.statusText == 'string' &&
    typeof e.internal == 'boolean' &&
    'data' in e
  )
}
const H5 = ['post', 'put', 'patch', 'delete'],
  CP = new Set(H5),
  _P = ['get', ...H5],
  OP = new Set(_P),
  kP = new Set([301, 302, 303, 307, 308]),
  TP = new Set([307, 308]),
  Yg = {
    state: 'idle',
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
  },
  AP = {
    state: 'idle',
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
  },
  iu = { state: 'unblocked', proceed: void 0, reset: void 0, location: void 0 },
  gw = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  RP = (e) => ({ hasErrorBoundary: !!e.hasErrorBoundary }),
  q5 = 'remix-router-transitions'
function PP(e) {
  const t = e.window ? e.window : typeof window < 'u' ? window : void 0,
    n = typeof t < 'u' && typeof t.document < 'u' && typeof t.document.createElement < 'u',
    r = !n
  ot(e.routes.length > 0, 'You must provide a non-empty routes array to createRouter')
  let i
  if (e.mapRouteProperties) i = e.mapRouteProperties
  else if (e.detectErrorBoundary) {
    let j = e.detectErrorBoundary
    i = ($) => ({ hasErrorBoundary: j($) })
  } else i = RP
  let s = {},
    o = Fy(e.routes, i, void 0, s),
    a,
    l = e.basename || '/',
    c = e.unstable_dataStrategy || MP,
    u = Bt(
      {
        v7_fetcherPersist: !1,
        v7_normalizeFormMethod: !1,
        v7_partialHydration: !1,
        v7_prependBasename: !1,
        v7_relativeSplatPath: !1,
        unstable_skipActionErrorRevalidation: !1,
      },
      e.future
    ),
    f = null,
    d = new Set(),
    p = null,
    h = null,
    m = null,
    b = e.hydrationData != null,
    y = kl(o, e.history.location, l),
    v = null
  if (y == null) {
    let j = Ur(404, { pathname: e.history.location.pathname }),
      { matches: $, route: W } = d2(o)
    ;(y = $), (v = { [W.id]: j })
  }
  let S,
    T = y.some((j) => j.route.lazy),
    A = y.some((j) => j.route.loader)
  if (T) S = !1
  else if (!A) S = !0
  else if (u.v7_partialHydration) {
    let j = e.hydrationData ? e.hydrationData.loaderData : null,
      $ = e.hydrationData ? e.hydrationData.errors : null,
      W = (te) =>
        te.route.loader
          ? typeof te.route.loader == 'function' && te.route.loader.hydrate === !0
            ? !1
            : (j && j[te.route.id] !== void 0) || ($ && $[te.route.id] !== void 0)
          : !0
    if ($) {
      let te = y.findIndex((ne) => $[ne.route.id] !== void 0)
      S = y.slice(0, te + 1).every(W)
    } else S = y.every(W)
  } else S = e.hydrationData != null
  let I,
    k = {
      historyAction: e.history.action,
      location: e.history.location,
      matches: y,
      initialized: S,
      navigation: Yg,
      restoreScrollPosition: e.hydrationData != null ? !1 : null,
      preventScrollReset: !1,
      revalidation: 'idle',
      loaderData: (e.hydrationData && e.hydrationData.loaderData) || {},
      actionData: (e.hydrationData && e.hydrationData.actionData) || null,
      errors: (e.hydrationData && e.hydrationData.errors) || v,
      fetchers: new Map(),
      blockers: new Map(),
    },
    D = Zt.Pop,
    F = !1,
    V,
    ie = !1,
    de = new Map(),
    xe = null,
    we = !1,
    Pe = !1,
    We = [],
    Me = [],
    K = new Map(),
    H = 0,
    oe = -1,
    Ae = new Map(),
    Ie = new Set(),
    fe = new Map(),
    _e = new Map(),
    re = new Set(),
    Z = new Map(),
    it = new Map(),
    wt = !1
  function Ze() {
    if (
      ((f = e.history.listen((j) => {
        let { action: $, location: W, delta: te } = j
        if (wt) {
          wt = !1
          return
        }
        vc(
          it.size === 0 || te != null,
          'You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.'
        )
        let ne = Lr({ currentLocation: k.location, nextLocation: W, historyAction: $ })
        if (ne && te != null) {
          ;(wt = !0),
            e.history.go(te * -1),
            ci(ne, {
              state: 'blocked',
              location: W,
              proceed() {
                ci(ne, { state: 'proceeding', proceed: void 0, reset: void 0, location: W }),
                  e.history.go(te)
              },
              reset() {
                let Te = new Map(k.blockers)
                Te.set(ne, iu), bt({ blockers: Te })
              },
            })
          return
        }
        return Tn($, W)
      })),
      n)
    ) {
      KP(t, de)
      let j = () => GP(t, de)
      t.addEventListener('pagehide', j), (xe = () => t.removeEventListener('pagehide', j))
    }
    return k.initialized || Tn(Zt.Pop, k.location, { initialHydration: !0 }), I
  }
  function _t() {
    f && f(),
      xe && xe(),
      d.clear(),
      V && V.abort(),
      k.fetchers.forEach((j, $) => Mr($)),
      k.blockers.forEach((j, $) => $i($))
  }
  function gn(j) {
    return d.add(j), () => d.delete(j)
  }
  function bt(j, $) {
    $ === void 0 && ($ = {}), (k = Bt({}, k, j))
    let W = [],
      te = []
    u.v7_fetcherPersist &&
      k.fetchers.forEach((ne, Te) => {
        ne.state === 'idle' && (re.has(Te) ? te.push(Te) : W.push(Te))
      }),
      [...d].forEach((ne) =>
        ne(k, {
          deletedFetchers: te,
          unstable_viewTransitionOpts: $.viewTransitionOpts,
          unstable_flushSync: $.flushSync === !0,
        })
      ),
      u.v7_fetcherPersist && (W.forEach((ne) => k.fetchers.delete(ne)), te.forEach((ne) => Mr(ne)))
  }
  function Jn(j, $, W) {
    var te, ne
    let { flushSync: Te } = W === void 0 ? {} : W,
      le =
        k.actionData != null &&
        k.navigation.formMethod != null &&
        vi(k.navigation.formMethod) &&
        k.navigation.state === 'loading' &&
        ((te = j.state) == null ? void 0 : te._isRedirect) !== !0,
      se
    $.actionData
      ? Object.keys($.actionData).length > 0
        ? (se = $.actionData)
        : (se = null)
      : le
      ? (se = k.actionData)
      : (se = null)
    let x = $.loaderData ? u2(k.loaderData, $.loaderData, $.matches || [], $.errors) : k.loaderData,
      C = k.blockers
    C.size > 0 && ((C = new Map(C)), C.forEach((O, N) => C.set(N, iu)))
    let _ =
      F === !0 ||
      (k.navigation.formMethod != null &&
        vi(k.navigation.formMethod) &&
        ((ne = j.state) == null ? void 0 : ne._isRedirect) !== !0)
    a && ((o = a), (a = void 0)),
      we ||
        D === Zt.Pop ||
        (D === Zt.Push
          ? e.history.push(j, j.state)
          : D === Zt.Replace && e.history.replace(j, j.state))
    let g
    if (D === Zt.Pop) {
      let O = de.get(k.location.pathname)
      O && O.has(j.pathname)
        ? (g = { currentLocation: k.location, nextLocation: j })
        : de.has(j.pathname) && (g = { currentLocation: j, nextLocation: k.location })
    } else if (ie) {
      let O = de.get(k.location.pathname)
      O ? O.add(j.pathname) : ((O = new Set([j.pathname])), de.set(k.location.pathname, O)),
        (g = { currentLocation: k.location, nextLocation: j })
    }
    bt(
      Bt({}, $, {
        actionData: se,
        loaderData: x,
        historyAction: D,
        location: j,
        initialized: !0,
        navigation: Yg,
        revalidation: 'idle',
        restoreScrollPosition: cs(j, $.matches || k.matches),
        preventScrollReset: _,
        blockers: C,
      }),
      { viewTransitionOpts: g, flushSync: Te === !0 }
    ),
      (D = Zt.Pop),
      (F = !1),
      (ie = !1),
      (we = !1),
      (Pe = !1),
      (We = []),
      (Me = [])
  }
  async function hr(j, $) {
    if (typeof j == 'number') {
      e.history.go(j)
      return
    }
    let W = By(
        k.location,
        k.matches,
        l,
        u.v7_prependBasename,
        j,
        u.v7_relativeSplatPath,
        $ == null ? void 0 : $.fromRouteId,
        $ == null ? void 0 : $.relative
      ),
      { path: te, submission: ne, error: Te } = r2(u.v7_normalizeFormMethod, !1, W, $),
      le = k.location,
      se = hf(k.location, te, $ && $.state)
    se = Bt({}, se, e.history.encodeLocation(se))
    let x = $ && $.replace != null ? $.replace : void 0,
      C = Zt.Push
    x === !0
      ? (C = Zt.Replace)
      : x === !1 ||
        (ne != null &&
          vi(ne.formMethod) &&
          ne.formAction === k.location.pathname + k.location.search &&
          (C = Zt.Replace))
    let _ = $ && 'preventScrollReset' in $ ? $.preventScrollReset === !0 : void 0,
      g = ($ && $.unstable_flushSync) === !0,
      O = Lr({ currentLocation: le, nextLocation: se, historyAction: C })
    if (O) {
      ci(O, {
        state: 'blocked',
        location: se,
        proceed() {
          ci(O, { state: 'proceeding', proceed: void 0, reset: void 0, location: se }), hr(j, $)
        },
        reset() {
          let N = new Map(k.blockers)
          N.set(O, iu), bt({ blockers: N })
        },
      })
      return
    }
    return await Tn(C, se, {
      submission: ne,
      pendingError: Te,
      preventScrollReset: _,
      replace: $ && $.replace,
      enableViewTransition: $ && $.unstable_viewTransition,
      flushSync: g,
    })
  }
  function si() {
    if ((Nr(), bt({ revalidation: 'loading' }), k.navigation.state !== 'submitting')) {
      if (k.navigation.state === 'idle') {
        Tn(k.historyAction, k.location, { startUninterruptedRevalidation: !0 })
        return
      }
      Tn(D || k.historyAction, k.navigation.location, { overrideNavigation: k.navigation })
    }
  }
  async function Tn(j, $, W) {
    V && V.abort(),
      (V = null),
      (D = j),
      (we = (W && W.startUninterruptedRevalidation) === !0),
      Xo(k.location, k.matches),
      (F = (W && W.preventScrollReset) === !0),
      (ie = (W && W.enableViewTransition) === !0)
    let te = a || o,
      ne = W && W.overrideNavigation,
      Te = kl(te, $, l),
      le = (W && W.flushSync) === !0
    if (!Te) {
      let O = Ur(404, { pathname: $.pathname }),
        { matches: N, route: L } = d2(te)
      ui(), Jn($, { matches: N, loaderData: {}, errors: { [L.id]: O } }, { flushSync: le })
      return
    }
    if (
      k.initialized &&
      !Pe &&
      UP(k.location, $) &&
      !(W && W.submission && vi(W.submission.formMethod))
    ) {
      Jn($, { matches: Te }, { flushSync: le })
      return
    }
    V = new AbortController()
    let se = Ja(e.history, $, V.signal, W && W.submission),
      x
    if (W && W.pendingError) x = [Uu(Te).route.id, { type: jt.error, error: W.pendingError }]
    else if (W && W.submission && vi(W.submission.formMethod)) {
      let O = await Vs(se, $, W.submission, Te, { replace: W.replace, flushSync: le })
      if (O.shortCircuited) return
      ;(x = O.pendingActionResult),
        (ne = Qg($, W.submission)),
        (le = !1),
        (se = Ja(e.history, se.url, se.signal))
    }
    let {
      shortCircuited: C,
      loaderData: _,
      errors: g,
    } = await ls(
      se,
      $,
      Te,
      ne,
      W && W.submission,
      W && W.fetcherSubmission,
      W && W.replace,
      W && W.initialHydration === !0,
      le,
      x
    )
    C || ((V = null), Jn($, Bt({ matches: Te }, f2(x), { loaderData: _, errors: g })))
  }
  async function Vs(j, $, W, te, ne) {
    ne === void 0 && (ne = {}), Nr()
    let Te = HP($, W)
    bt({ navigation: Te }, { flushSync: ne.flushSync === !0 })
    let le,
      se = zy(te, $)
    if (!se.route.action && !se.route.lazy)
      le = {
        type: jt.error,
        error: Ur(405, { method: j.method, pathname: $.pathname, routeId: se.route.id }),
      }
    else if (((le = (await mn('action', j, [se], te))[0]), j.signal.aborted))
      return { shortCircuited: !0 }
    if (ma(le)) {
      let x
      return (
        ne && ne.replace != null
          ? (x = ne.replace)
          : (x =
              a2(le.response.headers.get('Location'), new URL(j.url), l) ===
              k.location.pathname + k.location.search),
        await gr(j, le, { submission: W, replace: x }),
        { shortCircuited: !0 }
      )
    }
    if (ga(le)) throw Ur(400, { type: 'defer-action' })
    if (qr(le)) {
      let x = Uu(te, se.route.id)
      return (ne && ne.replace) !== !0 && (D = Zt.Push), { pendingActionResult: [x.route.id, le] }
    }
    return { pendingActionResult: [se.route.id, le] }
  }
  async function ls(j, $, W, te, ne, Te, le, se, x, C) {
    let _ = te || Qg($, ne),
      g = ne || Te || g2(_),
      O = a || o,
      [N, L] = i2(
        e.history,
        k,
        W,
        g,
        $,
        u.v7_partialHydration && se === !0,
        u.unstable_skipActionErrorRevalidation,
        Pe,
        We,
        Me,
        re,
        fe,
        Ie,
        O,
        l,
        C
      )
    if (
      (ui(
        (ue) =>
          !(W && W.some((Oe) => Oe.route.id === ue)) || (N && N.some((Oe) => Oe.route.id === ue))
      ),
      (oe = ++H),
      N.length === 0 && L.length === 0)
    ) {
      let ue = jr()
      return (
        Jn(
          $,
          Bt(
            { matches: W, loaderData: {}, errors: C && qr(C[1]) ? { [C[0]]: C[1].error } : null },
            f2(C),
            ue ? { fetchers: new Map(k.fetchers) } : {}
          ),
          { flushSync: x }
        ),
        { shortCircuited: !0 }
      )
    }
    if (!we && (!u.v7_partialHydration || !se)) {
      L.forEach((Oe) => {
        let Ne = k.fetchers.get(Oe.key),
          Se = su(void 0, Ne ? Ne.data : void 0)
        k.fetchers.set(Oe.key, Se)
      })
      let ue
      C && !qr(C[1])
        ? (ue = { [C[0]]: C[1].data })
        : k.actionData &&
          (Object.keys(k.actionData).length === 0 ? (ue = null) : (ue = k.actionData)),
        bt(
          Bt(
            { navigation: _ },
            ue !== void 0 ? { actionData: ue } : {},
            L.length > 0 ? { fetchers: new Map(k.fetchers) } : {}
          ),
          { flushSync: x }
        )
    }
    L.forEach((ue) => {
      K.has(ue.key) && er(ue.key), ue.controller && K.set(ue.key, ue.controller)
    })
    let q = () => L.forEach((ue) => er(ue.key))
    V && V.signal.addEventListener('abort', q)
    let { loaderResults: X, fetcherResults: ye } = await oi(k.matches, W, N, L, j)
    if (j.signal.aborted) return { shortCircuited: !0 }
    V && V.signal.removeEventListener('abort', q), L.forEach((ue) => K.delete(ue.key))
    let ae = h2([...X, ...ye])
    if (ae) {
      if (ae.idx >= N.length) {
        let ue = L[ae.idx - N.length].key
        Ie.add(ue)
      }
      return await gr(j, ae.result, { replace: le }), { shortCircuited: !0 }
    }
    let { loaderData: et, errors: ce } = c2(k, W, N, X, C, L, ye, Z)
    Z.forEach((ue, Oe) => {
      ue.subscribe((Ne) => {
        ;(Ne || ue.done) && Z.delete(Oe)
      })
    }),
      u.v7_partialHydration &&
        se &&
        k.errors &&
        Object.entries(k.errors)
          .filter((ue) => {
            let [Oe] = ue
            return !N.some((Ne) => Ne.route.id === Oe)
          })
          .forEach((ue) => {
            let [Oe, Ne] = ue
            ce = Object.assign(ce || {}, { [Oe]: Ne })
          })
    let $e = jr(),
      Be = ji(oe),
      ze = $e || Be || L.length > 0
    return Bt({ loaderData: et, errors: ce }, ze ? { fetchers: new Map(k.fetchers) } : {})
  }
  function pr(j, $, W, te) {
    if (r)
      throw new Error(
        "router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback."
      )
    K.has(j) && er(j)
    let ne = (te && te.unstable_flushSync) === !0,
      Te = a || o,
      le = By(
        k.location,
        k.matches,
        l,
        u.v7_prependBasename,
        W,
        u.v7_relativeSplatPath,
        $,
        te == null ? void 0 : te.relative
      ),
      se = kl(Te, le, l)
    if (!se) {
      ai(j, $, Ur(404, { pathname: le }), { flushSync: ne })
      return
    }
    let { path: x, submission: C, error: _ } = r2(u.v7_normalizeFormMethod, !0, le, te)
    if (_) {
      ai(j, $, _, { flushSync: ne })
      return
    }
    let g = zy(se, x)
    if (((F = (te && te.preventScrollReset) === !0), C && vi(C.formMethod))) {
      Ir(j, $, x, g, se, ne, C)
      return
    }
    fe.set(j, { routeId: $, path: x }), Dr(j, $, x, g, se, ne, C)
  }
  async function Ir(j, $, W, te, ne, Te, le) {
    if ((Nr(), fe.delete(j), !te.route.action && !te.route.lazy)) {
      let Se = Ur(405, { method: le.formMethod, pathname: W, routeId: $ })
      ai(j, $, Se, { flushSync: Te })
      return
    }
    let se = k.fetchers.get(j)
    Bn(j, qP(le, se), { flushSync: Te })
    let x = new AbortController(),
      C = Ja(e.history, W, x.signal, le)
    K.set(j, x)
    let _ = H,
      O = (await mn('action', C, [te], ne))[0]
    if (C.signal.aborted) {
      K.get(j) === x && K.delete(j)
      return
    }
    if (u.v7_fetcherPersist && re.has(j)) {
      if (ma(O) || qr(O)) {
        Bn(j, ro(void 0))
        return
      }
    } else {
      if (ma(O))
        if ((K.delete(j), oe > _)) {
          Bn(j, ro(void 0))
          return
        } else return Ie.add(j), Bn(j, su(le)), gr(C, O, { fetcherSubmission: le })
      if (qr(O)) {
        ai(j, $, O.error)
        return
      }
    }
    if (ga(O)) throw Ur(400, { type: 'defer-action' })
    let N = k.navigation.location || k.location,
      L = Ja(e.history, N, x.signal),
      q = a || o,
      X = k.navigation.state !== 'idle' ? kl(q, k.navigation.location, l) : k.matches
    ot(X, "Didn't find any matches after fetcher action")
    let ye = ++H
    Ae.set(j, ye)
    let ae = su(le, O.data)
    k.fetchers.set(j, ae)
    let [et, ce] = i2(
      e.history,
      k,
      X,
      le,
      N,
      !1,
      u.unstable_skipActionErrorRevalidation,
      Pe,
      We,
      Me,
      re,
      fe,
      Ie,
      q,
      l,
      [te.route.id, O]
    )
    ce
      .filter((Se) => Se.key !== j)
      .forEach((Se) => {
        let me = Se.key,
          Re = k.fetchers.get(me),
          ge = su(void 0, Re ? Re.data : void 0)
        k.fetchers.set(me, ge), K.has(me) && er(me), Se.controller && K.set(me, Se.controller)
      }),
      bt({ fetchers: new Map(k.fetchers) })
    let $e = () => ce.forEach((Se) => er(Se.key))
    x.signal.addEventListener('abort', $e)
    let { loaderResults: Be, fetcherResults: ze } = await oi(k.matches, X, et, ce, L)
    if (x.signal.aborted) return
    x.signal.removeEventListener('abort', $e),
      Ae.delete(j),
      K.delete(j),
      ce.forEach((Se) => K.delete(Se.key))
    let ue = h2([...Be, ...ze])
    if (ue) {
      if (ue.idx >= et.length) {
        let Se = ce[ue.idx - et.length].key
        Ie.add(Se)
      }
      return gr(L, ue.result)
    }
    let { loaderData: Oe, errors: Ne } = c2(k, k.matches, et, Be, void 0, ce, ze, Z)
    if (k.fetchers.has(j)) {
      let Se = ro(O.data)
      k.fetchers.set(j, Se)
    }
    ji(ye),
      k.navigation.state === 'loading' && ye > oe
        ? (ot(D, 'Expected pending action'),
          V && V.abort(),
          Jn(k.navigation.location, {
            matches: X,
            loaderData: Oe,
            errors: Ne,
            fetchers: new Map(k.fetchers),
          }))
        : (bt({
            errors: Ne,
            loaderData: u2(k.loaderData, Oe, X, Ne),
            fetchers: new Map(k.fetchers),
          }),
          (Pe = !1))
  }
  async function Dr(j, $, W, te, ne, Te, le) {
    let se = k.fetchers.get(j)
    Bn(j, su(le, se ? se.data : void 0), { flushSync: Te })
    let x = new AbortController(),
      C = Ja(e.history, W, x.signal)
    K.set(j, x)
    let _ = H,
      O = (await mn('loader', C, [te], ne))[0]
    if (
      (ga(O) && (O = (await Q5(O, C.signal, !0)) || O),
      K.get(j) === x && K.delete(j),
      !C.signal.aborted)
    ) {
      if (re.has(j)) {
        Bn(j, ro(void 0))
        return
      }
      if (ma(O))
        if (oe > _) {
          Bn(j, ro(void 0))
          return
        } else {
          Ie.add(j), await gr(C, O)
          return
        }
      if (qr(O)) {
        ai(j, $, O.error)
        return
      }
      ot(!ga(O), 'Unhandled fetcher deferred data'), Bn(j, ro(O.data))
    }
  }
  async function gr(j, $, W) {
    let { submission: te, fetcherSubmission: ne, replace: Te } = W === void 0 ? {} : W
    $.response.headers.has('X-Remix-Revalidate') && (Pe = !0)
    let le = $.response.headers.get('Location')
    ot(le, 'Expected a Location header on the redirect Response'), (le = a2(le, new URL(j.url), l))
    let se = hf(k.location, le, { _isRedirect: !0 })
    if (n) {
      let N = !1
      if ($.response.headers.has('X-Remix-Reload-Document')) N = !0
      else if (gw.test(le)) {
        const L = e.history.createURL(le)
        N = L.origin !== t.location.origin || Zf(L.pathname, l) == null
      }
      if (N) {
        Te ? t.location.replace(le) : t.location.assign(le)
        return
      }
    }
    V = null
    let x = Te === !0 ? Zt.Replace : Zt.Push,
      { formMethod: C, formAction: _, formEncType: g } = k.navigation
    !te && !ne && C && _ && g && (te = g2(k.navigation))
    let O = te || ne
    if (TP.has($.response.status) && O && vi(O.formMethod))
      await Tn(x, se, { submission: Bt({}, O, { formAction: le }), preventScrollReset: F })
    else {
      let N = Qg(se, te)
      await Tn(x, se, { overrideNavigation: N, fetcherSubmission: ne, preventScrollReset: F })
    }
  }
  async function mn(j, $, W, te) {
    try {
      let ne = await jP(c, j, $, W, te, s, i)
      return await Promise.all(
        ne.map((Te, le) => {
          if (zP(Te)) {
            let se = Te.result
            return {
              type: jt.redirect,
              response: FP(se, $, W[le].route.id, te, l, u.v7_relativeSplatPath),
            }
          }
          return $P(Te)
        })
      )
    } catch (ne) {
      return W.map(() => ({ type: jt.error, error: ne }))
    }
  }
  async function oi(j, $, W, te, ne) {
    let [Te, ...le] = await Promise.all([
      W.length ? mn('loader', ne, W, $) : [],
      ...te.map((se) => {
        if (se.matches && se.match && se.controller) {
          let x = Ja(e.history, se.path, se.controller.signal)
          return mn('loader', x, [se.match], se.matches).then((C) => C[0])
        } else return Promise.resolve({ type: jt.error, error: Ur(404, { pathname: se.path }) })
      }),
    ])
    return (
      await Promise.all([
        p2(
          j,
          W,
          Te,
          Te.map(() => ne.signal),
          !1,
          k.loaderData
        ),
        p2(
          j,
          te.map((se) => se.match),
          le,
          te.map((se) => (se.controller ? se.controller.signal : null)),
          !0
        ),
      ]),
      { loaderResults: Te, fetcherResults: le }
    )
  }
  function Nr() {
    ;(Pe = !0),
      We.push(...ui()),
      fe.forEach((j, $) => {
        K.has($) && (Me.push($), er($))
      })
  }
  function Bn(j, $, W) {
    W === void 0 && (W = {}),
      k.fetchers.set(j, $),
      bt({ fetchers: new Map(k.fetchers) }, { flushSync: (W && W.flushSync) === !0 })
  }
  function ai(j, $, W, te) {
    te === void 0 && (te = {})
    let ne = Uu(k.matches, $)
    Mr(j),
      bt(
        { errors: { [ne.route.id]: W }, fetchers: new Map(k.fetchers) },
        { flushSync: (te && te.flushSync) === !0 }
      )
  }
  function Hs(j) {
    return (
      u.v7_fetcherPersist && (_e.set(j, (_e.get(j) || 0) + 1), re.has(j) && re.delete(j)),
      k.fetchers.get(j) || AP
    )
  }
  function Mr(j) {
    let $ = k.fetchers.get(j)
    K.has(j) && !($ && $.state === 'loading' && Ae.has(j)) && er(j),
      fe.delete(j),
      Ae.delete(j),
      Ie.delete(j),
      re.delete(j),
      k.fetchers.delete(j)
  }
  function Go(j) {
    if (u.v7_fetcherPersist) {
      let $ = (_e.get(j) || 0) - 1
      $ <= 0 ? (_e.delete(j), re.add(j)) : _e.set(j, $)
    } else Mr(j)
    bt({ fetchers: new Map(k.fetchers) })
  }
  function er(j) {
    let $ = K.get(j)
    ot($, 'Expected fetch controller: ' + j), $.abort(), K.delete(j)
  }
  function li(j) {
    for (let $ of j) {
      let W = Hs($),
        te = ro(W.data)
      k.fetchers.set($, te)
    }
  }
  function jr() {
    let j = [],
      $ = !1
    for (let W of Ie) {
      let te = k.fetchers.get(W)
      ot(te, 'Expected fetcher: ' + W),
        te.state === 'loading' && (Ie.delete(W), j.push(W), ($ = !0))
    }
    return li(j), $
  }
  function ji(j) {
    let $ = []
    for (let [W, te] of Ae)
      if (te < j) {
        let ne = k.fetchers.get(W)
        ot(ne, 'Expected fetcher: ' + W), ne.state === 'loading' && (er(W), Ae.delete(W), $.push(W))
      }
    return li($), $.length > 0
  }
  function Li(j, $) {
    let W = k.blockers.get(j) || iu
    return it.get(j) !== $ && it.set(j, $), W
  }
  function $i(j) {
    k.blockers.delete(j), it.delete(j)
  }
  function ci(j, $) {
    let W = k.blockers.get(j) || iu
    ot(
      (W.state === 'unblocked' && $.state === 'blocked') ||
        (W.state === 'blocked' && $.state === 'blocked') ||
        (W.state === 'blocked' && $.state === 'proceeding') ||
        (W.state === 'blocked' && $.state === 'unblocked') ||
        (W.state === 'proceeding' && $.state === 'unblocked'),
      'Invalid blocker state transition: ' + W.state + ' -> ' + $.state
    )
    let te = new Map(k.blockers)
    te.set(j, $), bt({ blockers: te })
  }
  function Lr(j) {
    let { currentLocation: $, nextLocation: W, historyAction: te } = j
    if (it.size === 0) return
    it.size > 1 && vc(!1, 'A router only supports one blocker at a time')
    let ne = Array.from(it.entries()),
      [Te, le] = ne[ne.length - 1],
      se = k.blockers.get(Te)
    if (
      !(se && se.state === 'proceeding') &&
      le({ currentLocation: $, nextLocation: W, historyAction: te })
    )
      return Te
  }
  function ui(j) {
    let $ = []
    return (
      Z.forEach((W, te) => {
        ;(!j || j(te)) && (W.cancel(), $.push(te), Z.delete(te))
      }),
      $
    )
  }
  function Yo(j, $, W) {
    if (((p = j), (m = $), (h = W || null), !b && k.navigation === Yg)) {
      b = !0
      let te = cs(k.location, k.matches)
      te != null && bt({ restoreScrollPosition: te })
    }
    return () => {
      ;(p = null), (m = null), (h = null)
    }
  }
  function Qo(j, $) {
    return (
      (h &&
        h(
          j,
          $.map((te) => sP(te, k.loaderData))
        )) ||
      j.key
    )
  }
  function Xo(j, $) {
    if (p && m) {
      let W = Qo(j, $)
      p[W] = m()
    }
  }
  function cs(j, $) {
    if (p) {
      let W = Qo(j, $),
        te = p[W]
      if (typeof te == 'number') return te
    }
    return null
  }
  function Un(j) {
    ;(s = {}), (a = Fy(j, i, void 0, s))
  }
  return (
    (I = {
      get basename() {
        return l
      },
      get future() {
        return u
      },
      get state() {
        return k
      },
      get routes() {
        return o
      },
      get window() {
        return t
      },
      initialize: Ze,
      subscribe: gn,
      enableScrollRestoration: Yo,
      navigate: hr,
      fetch: pr,
      revalidate: si,
      createHref: (j) => e.history.createHref(j),
      encodeLocation: (j) => e.history.encodeLocation(j),
      getFetcher: Hs,
      deleteFetcher: Go,
      dispose: _t,
      getBlocker: Li,
      deleteBlocker: $i,
      _internalFetchControllers: K,
      _internalActiveDeferreds: Z,
      _internalSetRoutes: Un,
    }),
    I
  )
}
function IP(e) {
  return (
    e != null && (('formData' in e && e.formData != null) || ('body' in e && e.body !== void 0))
  )
}
function By(e, t, n, r, i, s, o, a) {
  let l, c
  if (o) {
    l = []
    for (let f of t)
      if ((l.push(f), f.route.id === o)) {
        c = f
        break
      }
  } else (l = t), (c = t[t.length - 1])
  let u = V5(i || '.', W5(l, s), Zf(e.pathname, n) || e.pathname, a === 'path')
  return (
    i == null && ((u.search = e.search), (u.hash = e.hash)),
    (i == null || i === '' || i === '.') &&
      c &&
      c.route.index &&
      !mw(u.search) &&
      (u.search = u.search ? u.search.replace(/^\?/, '?index&') : '?index'),
    r && n !== '/' && (u.pathname = u.pathname === '/' ? n : Do([n, u.pathname])),
    Xf(u)
  )
}
function r2(e, t, n, r) {
  if (!r || !IP(r)) return { path: n }
  if (r.formMethod && !VP(r.formMethod))
    return { path: n, error: Ur(405, { method: r.formMethod }) }
  let i = () => ({ path: n, error: Ur(400, { type: 'invalid-body' }) }),
    s = r.formMethod || 'get',
    o = e ? s.toUpperCase() : s.toLowerCase(),
    a = G5(n)
  if (r.body !== void 0) {
    if (r.formEncType === 'text/plain') {
      if (!vi(o)) return i()
      let d =
        typeof r.body == 'string'
          ? r.body
          : r.body instanceof FormData || r.body instanceof URLSearchParams
          ? Array.from(r.body.entries()).reduce((p, h) => {
              let [m, b] = h
              return (
                '' +
                p +
                m +
                '=' +
                b +
                `
`
              )
            }, '')
          : String(r.body)
      return {
        path: n,
        submission: {
          formMethod: o,
          formAction: a,
          formEncType: r.formEncType,
          formData: void 0,
          json: void 0,
          text: d,
        },
      }
    } else if (r.formEncType === 'application/json') {
      if (!vi(o)) return i()
      try {
        let d = typeof r.body == 'string' ? JSON.parse(r.body) : r.body
        return {
          path: n,
          submission: {
            formMethod: o,
            formAction: a,
            formEncType: r.formEncType,
            formData: void 0,
            json: d,
            text: void 0,
          },
        }
      } catch {
        return i()
      }
    }
  }
  ot(typeof FormData == 'function', 'FormData is not available in this environment')
  let l, c
  if (r.formData) (l = Uy(r.formData)), (c = r.formData)
  else if (r.body instanceof FormData) (l = Uy(r.body)), (c = r.body)
  else if (r.body instanceof URLSearchParams) (l = r.body), (c = l2(l))
  else if (r.body == null) (l = new URLSearchParams()), (c = new FormData())
  else
    try {
      ;(l = new URLSearchParams(r.body)), (c = l2(l))
    } catch {
      return i()
    }
  let u = {
    formMethod: o,
    formAction: a,
    formEncType: (r && r.formEncType) || 'application/x-www-form-urlencoded',
    formData: c,
    json: void 0,
    text: void 0,
  }
  if (vi(u.formMethod)) return { path: n, submission: u }
  let f = Bs(n)
  return (
    t && f.search && mw(f.search) && l.append('index', ''),
    (f.search = '?' + l),
    { path: Xf(f), submission: u }
  )
}
function DP(e, t) {
  let n = e
  if (t) {
    let r = e.findIndex((i) => i.route.id === t)
    r >= 0 && (n = e.slice(0, r))
  }
  return n
}
function i2(e, t, n, r, i, s, o, a, l, c, u, f, d, p, h, m) {
  let b = m ? (qr(m[1]) ? m[1].error : m[1].data) : void 0,
    y = e.createURL(t.location),
    v = e.createURL(i),
    S = m && qr(m[1]) ? m[0] : void 0,
    T = S ? DP(n, S) : n,
    A = m ? m[1].statusCode : void 0,
    I = o && A && A >= 400,
    k = T.filter((F, V) => {
      let { route: ie } = F
      if (ie.lazy) return !0
      if (ie.loader == null) return !1
      if (s)
        return typeof ie.loader != 'function' || ie.loader.hydrate
          ? !0
          : t.loaderData[ie.id] === void 0 && (!t.errors || t.errors[ie.id] === void 0)
      if (NP(t.loaderData, t.matches[V], F) || l.some((we) => we === F.route.id)) return !0
      let de = t.matches[V],
        xe = F
      return s2(
        F,
        Bt({ currentUrl: y, currentParams: de.params, nextUrl: v, nextParams: xe.params }, r, {
          actionResult: b,
          unstable_actionStatus: A,
          defaultShouldRevalidate: I
            ? !1
            : a ||
              y.pathname + y.search === v.pathname + v.search ||
              y.search !== v.search ||
              K5(de, xe),
        })
      )
    }),
    D = []
  return (
    f.forEach((F, V) => {
      if (s || !n.some((Pe) => Pe.route.id === F.routeId) || u.has(V)) return
      let ie = kl(p, F.path, h)
      if (!ie) {
        D.push({
          key: V,
          routeId: F.routeId,
          path: F.path,
          matches: null,
          match: null,
          controller: null,
        })
        return
      }
      let de = t.fetchers.get(V),
        xe = zy(ie, F.path),
        we = !1
      d.has(V)
        ? (we = !1)
        : c.includes(V)
        ? (we = !0)
        : de && de.state !== 'idle' && de.data === void 0
        ? (we = a)
        : (we = s2(
            xe,
            Bt(
              {
                currentUrl: y,
                currentParams: t.matches[t.matches.length - 1].params,
                nextUrl: v,
                nextParams: n[n.length - 1].params,
              },
              r,
              { actionResult: b, unstable_actionStatus: A, defaultShouldRevalidate: I ? !1 : a }
            )
          )),
        we &&
          D.push({
            key: V,
            routeId: F.routeId,
            path: F.path,
            matches: ie,
            match: xe,
            controller: new AbortController(),
          })
    }),
    [k, D]
  )
}
function NP(e, t, n) {
  let r = !t || n.route.id !== t.route.id,
    i = e[n.route.id] === void 0
  return r || i
}
function K5(e, t) {
  let n = e.route.path
  return (
    e.pathname !== t.pathname || (n != null && n.endsWith('*') && e.params['*'] !== t.params['*'])
  )
}
function s2(e, t) {
  if (e.route.shouldRevalidate) {
    let n = e.route.shouldRevalidate(t)
    if (typeof n == 'boolean') return n
  }
  return t.defaultShouldRevalidate
}
async function o2(e, t, n) {
  if (!e.lazy) return
  let r = await e.lazy()
  if (!e.lazy) return
  let i = n[e.id]
  ot(i, 'No route found in manifest')
  let s = {}
  for (let o in r) {
    let l = i[o] !== void 0 && o !== 'hasErrorBoundary'
    vc(
      !l,
      'Route "' +
        i.id +
        '" has a static property "' +
        o +
        '" defined but its lazy function is also returning a value for this property. ' +
        ('The lazy route property "' + o + '" will be ignored.')
    ),
      !l && !rP.has(o) && (s[o] = r[o])
  }
  Object.assign(i, s), Object.assign(i, Bt({}, t(i), { lazy: void 0 }))
}
function MP(e) {
  return Promise.all(e.matches.map((t) => t.resolve()))
}
async function jP(e, t, n, r, i, s, o, a) {
  let l = r.reduce((f, d) => f.add(d.route.id), new Set()),
    c = new Set(),
    u = await e({
      matches: i.map((f) => {
        let d = l.has(f.route.id)
        return Bt({}, f, {
          shouldLoad: d,
          resolve: (h) => (
            c.add(f.route.id),
            d ? LP(t, n, f, s, o, h, a) : Promise.resolve({ type: jt.data, result: void 0 })
          ),
        })
      }),
      request: n,
      params: i[0].params,
      context: a,
    })
  return (
    i.forEach((f) =>
      ot(
        c.has(f.route.id),
        '`match.resolve()` was not called for route id "' +
          f.route.id +
          '". You must call `match.resolve()` on every match passed to `dataStrategy` to ensure all routes are properly loaded.'
      )
    ),
    u.filter((f, d) => l.has(i[d].route.id))
  )
}
async function LP(e, t, n, r, i, s, o) {
  let a,
    l,
    c = (u) => {
      let f,
        d = new Promise((m, b) => (f = b))
      ;(l = () => f()), t.signal.addEventListener('abort', l)
      let p = (m) =>
          typeof u != 'function'
            ? Promise.reject(
                new Error(
                  'You cannot call the handler for a route which defines a boolean ' +
                    ('"' + e + '" [routeId: ' + n.route.id + ']')
                )
              )
            : u({ request: t, params: n.params, context: o }, ...(m !== void 0 ? [m] : [])),
        h
      return (
        s
          ? (h = s((m) => p(m)))
          : (h = (async () => {
              try {
                return { type: 'data', result: await p() }
              } catch (m) {
                return { type: 'error', result: m }
              }
            })()),
        Promise.race([h, d])
      )
    }
  try {
    let u = n.route[e]
    if (n.route.lazy)
      if (u) {
        let f,
          [d] = await Promise.all([
            c(u).catch((p) => {
              f = p
            }),
            o2(n.route, i, r),
          ])
        if (f !== void 0) throw f
        a = d
      } else if ((await o2(n.route, i, r), (u = n.route[e]), u)) a = await c(u)
      else if (e === 'action') {
        let f = new URL(t.url),
          d = f.pathname + f.search
        throw Ur(405, { method: t.method, pathname: d, routeId: n.route.id })
      } else return { type: jt.data, result: void 0 }
    else if (u) a = await c(u)
    else {
      let f = new URL(t.url),
        d = f.pathname + f.search
      throw Ur(404, { pathname: d })
    }
    ot(
      a.result !== void 0,
      'You defined ' +
        (e === 'action' ? 'an action' : 'a loader') +
        ' for route ' +
        ('"' + n.route.id + '" but didn\'t return anything from your `' + e + '` ') +
        'function. Please return a value or `null`.'
    )
  } catch (u) {
    return { type: jt.error, result: u }
  } finally {
    l && t.signal.removeEventListener('abort', l)
  }
  return a
}
async function $P(e) {
  let { result: t, type: n, status: r } = e
  if (Y5(t)) {
    let o
    try {
      let a = t.headers.get('Content-Type')
      a && /\bapplication\/json\b/.test(a)
        ? t.body == null
          ? (o = null)
          : (o = await t.json())
        : (o = await t.text())
    } catch (a) {
      return { type: jt.error, error: a }
    }
    return n === jt.error
      ? {
          type: jt.error,
          error: new hw(t.status, t.statusText, o),
          statusCode: t.status,
          headers: t.headers,
        }
      : { type: jt.data, data: o, statusCode: t.status, headers: t.headers }
  }
  if (n === jt.error) return { type: jt.error, error: t, statusCode: pw(t) ? t.status : r }
  if (WP(t)) {
    var i, s
    return {
      type: jt.deferred,
      deferredData: t,
      statusCode: (i = t.init) == null ? void 0 : i.status,
      headers: ((s = t.init) == null ? void 0 : s.headers) && new Headers(t.init.headers),
    }
  }
  return { type: jt.data, data: t, statusCode: r }
}
function FP(e, t, n, r, i, s) {
  let o = e.headers.get('Location')
  if (
    (ot(o, 'Redirects returned/thrown from loaders/actions must have a Location header'),
    !gw.test(o))
  ) {
    let a = r.slice(0, r.findIndex((l) => l.route.id === n) + 1)
    ;(o = By(new URL(t.url), a, i, !0, o, s)), e.headers.set('Location', o)
  }
  return e
}
function a2(e, t, n) {
  if (gw.test(e)) {
    let r = e,
      i = r.startsWith('//') ? new URL(t.protocol + r) : new URL(r),
      s = Zf(i.pathname, n) != null
    if (i.origin === t.origin && s) return i.pathname + i.search + i.hash
  }
  return e
}
function Ja(e, t, n, r) {
  let i = e.createURL(G5(t)).toString(),
    s = { signal: n }
  if (r && vi(r.formMethod)) {
    let { formMethod: o, formEncType: a } = r
    ;(s.method = o.toUpperCase()),
      a === 'application/json'
        ? ((s.headers = new Headers({ 'Content-Type': a })), (s.body = JSON.stringify(r.json)))
        : a === 'text/plain'
        ? (s.body = r.text)
        : a === 'application/x-www-form-urlencoded' && r.formData
        ? (s.body = Uy(r.formData))
        : (s.body = r.formData)
  }
  return new Request(i, s)
}
function Uy(e) {
  let t = new URLSearchParams()
  for (let [n, r] of e.entries()) t.append(n, typeof r == 'string' ? r : r.name)
  return t
}
function l2(e) {
  let t = new FormData()
  for (let [n, r] of e.entries()) t.append(n, r)
  return t
}
function BP(e, t, n, r, i, s) {
  let o = {},
    a = null,
    l,
    c = !1,
    u = {},
    f = r && qr(r[1]) ? r[1].error : void 0
  return (
    n.forEach((d, p) => {
      let h = t[p].route.id
      if ((ot(!ma(d), 'Cannot handle redirect results in processLoaderData'), qr(d))) {
        let m = d.error
        if ((f !== void 0 && ((m = f), (f = void 0)), (a = a || {}), s)) a[h] = m
        else {
          let b = Uu(e, h)
          a[b.route.id] == null && (a[b.route.id] = m)
        }
        ;(o[h] = void 0),
          c || ((c = !0), (l = pw(d.error) ? d.error.status : 500)),
          d.headers && (u[h] = d.headers)
      } else
        ga(d)
          ? (i.set(h, d.deferredData),
            (o[h] = d.deferredData.data),
            d.statusCode != null && d.statusCode !== 200 && !c && (l = d.statusCode),
            d.headers && (u[h] = d.headers))
          : ((o[h] = d.data),
            d.statusCode && d.statusCode !== 200 && !c && (l = d.statusCode),
            d.headers && (u[h] = d.headers))
    }),
    f !== void 0 && r && ((a = { [r[0]]: f }), (o[r[0]] = void 0)),
    { loaderData: o, errors: a, statusCode: l || 200, loaderHeaders: u }
  )
}
function c2(e, t, n, r, i, s, o, a) {
  let { loaderData: l, errors: c } = BP(t, n, r, i, a, !1)
  for (let u = 0; u < s.length; u++) {
    let { key: f, match: d, controller: p } = s[u]
    ot(o !== void 0 && o[u] !== void 0, 'Did not find corresponding fetcher result')
    let h = o[u]
    if (!(p && p.signal.aborted))
      if (qr(h)) {
        let m = Uu(e.matches, d == null ? void 0 : d.route.id)
        ;(c && c[m.route.id]) || (c = Bt({}, c, { [m.route.id]: h.error })), e.fetchers.delete(f)
      } else if (ma(h)) ot(!1, 'Unhandled fetcher revalidation redirect')
      else if (ga(h)) ot(!1, 'Unhandled fetcher deferred data')
      else {
        let m = ro(h.data)
        e.fetchers.set(f, m)
      }
  }
  return { loaderData: l, errors: c }
}
function u2(e, t, n, r) {
  let i = Bt({}, t)
  for (let s of n) {
    let o = s.route.id
    if (
      (t.hasOwnProperty(o)
        ? t[o] !== void 0 && (i[o] = t[o])
        : e[o] !== void 0 && s.route.loader && (i[o] = e[o]),
      r && r.hasOwnProperty(o))
    )
      break
  }
  return i
}
function f2(e) {
  return e ? (qr(e[1]) ? { actionData: {} } : { actionData: { [e[0]]: e[1].data } }) : {}
}
function Uu(e, t) {
  return (
    (t ? e.slice(0, e.findIndex((r) => r.route.id === t) + 1) : [...e])
      .reverse()
      .find((r) => r.route.hasErrorBoundary === !0) || e[0]
  )
}
function d2(e) {
  let t =
    e.length === 1
      ? e[0]
      : e.find((n) => n.index || !n.path || n.path === '/') || { id: '__shim-error-route__' }
  return { matches: [{ params: {}, pathname: '', pathnameBase: '', route: t }], route: t }
}
function Ur(e, t) {
  let { pathname: n, routeId: r, method: i, type: s } = t === void 0 ? {} : t,
    o = 'Unknown Server Error',
    a = 'Unknown @remix-run/router error'
  return (
    e === 400
      ? ((o = 'Bad Request'),
        i && n && r
          ? (a =
              'You made a ' +
              i +
              ' request to "' +
              n +
              '" but ' +
              ('did not provide a `loader` for route "' + r + '", ') +
              'so there is no way to handle the request.')
          : s === 'defer-action'
          ? (a = 'defer() is not supported in actions')
          : s === 'invalid-body' && (a = 'Unable to encode submission body'))
      : e === 403
      ? ((o = 'Forbidden'), (a = 'Route "' + r + '" does not match URL "' + n + '"'))
      : e === 404
      ? ((o = 'Not Found'), (a = 'No route matches URL "' + n + '"'))
      : e === 405 &&
        ((o = 'Method Not Allowed'),
        i && n && r
          ? (a =
              'You made a ' +
              i.toUpperCase() +
              ' request to "' +
              n +
              '" but ' +
              ('did not provide an `action` for route "' + r + '", ') +
              'so there is no way to handle the request.')
          : i && (a = 'Invalid request method "' + i.toUpperCase() + '"')),
    new hw(e || 500, o, new Error(a), !0)
  )
}
function h2(e) {
  for (let t = e.length - 1; t >= 0; t--) {
    let n = e[t]
    if (ma(n)) return { result: n, idx: t }
  }
}
function G5(e) {
  let t = typeof e == 'string' ? Bs(e) : e
  return Xf(Bt({}, t, { hash: '' }))
}
function UP(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search
    ? !1
    : e.hash === ''
    ? t.hash !== ''
    : e.hash === t.hash
    ? !0
    : t.hash !== ''
}
function zP(e) {
  return Y5(e.result) && kP.has(e.result.status)
}
function ga(e) {
  return e.type === jt.deferred
}
function qr(e) {
  return e.type === jt.error
}
function ma(e) {
  return (e && e.type) === jt.redirect
}
function WP(e) {
  let t = e
  return (
    t &&
    typeof t == 'object' &&
    typeof t.data == 'object' &&
    typeof t.subscribe == 'function' &&
    typeof t.cancel == 'function' &&
    typeof t.resolveData == 'function'
  )
}
function Y5(e) {
  return (
    e != null &&
    typeof e.status == 'number' &&
    typeof e.statusText == 'string' &&
    typeof e.headers == 'object' &&
    typeof e.body < 'u'
  )
}
function VP(e) {
  return OP.has(e.toLowerCase())
}
function vi(e) {
  return CP.has(e.toLowerCase())
}
async function p2(e, t, n, r, i, s) {
  for (let o = 0; o < n.length; o++) {
    let a = n[o],
      l = t[o]
    if (!l) continue
    let c = e.find((f) => f.route.id === l.route.id),
      u = c != null && !K5(c, l) && (s && s[l.route.id]) !== void 0
    if (ga(a) && (i || u)) {
      let f = r[o]
      ot(f, 'Expected an AbortSignal for revalidating fetcher deferred result'),
        await Q5(a, f, i).then((d) => {
          d && (n[o] = d || n[o])
        })
    }
  }
}
async function Q5(e, t, n) {
  if ((n === void 0 && (n = !1), !(await e.deferredData.resolveData(t)))) {
    if (n)
      try {
        return { type: jt.data, data: e.deferredData.unwrappedData }
      } catch (i) {
        return { type: jt.error, error: i }
      }
    return { type: jt.data, data: e.deferredData.data }
  }
}
function mw(e) {
  return new URLSearchParams(e).getAll('index').some((t) => t === '')
}
function zy(e, t) {
  let n = typeof t == 'string' ? Bs(t).search : t.search
  if (e[e.length - 1].route.index && mw(n || '')) return e[e.length - 1]
  let r = z5(e)
  return r[r.length - 1]
}
function g2(e) {
  let { formMethod: t, formAction: n, formEncType: r, text: i, formData: s, json: o } = e
  if (!(!t || !n || !r)) {
    if (i != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: void 0,
        text: i,
      }
    if (s != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: s,
        json: void 0,
        text: void 0,
      }
    if (o !== void 0)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: o,
        text: void 0,
      }
  }
}
function Qg(e, t) {
  return t
    ? {
        state: 'loading',
        location: e,
        formMethod: t.formMethod,
        formAction: t.formAction,
        formEncType: t.formEncType,
        formData: t.formData,
        json: t.json,
        text: t.text,
      }
    : {
        state: 'loading',
        location: e,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
      }
}
function HP(e, t) {
  return {
    state: 'submitting',
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text,
  }
}
function su(e, t) {
  return e
    ? {
        state: 'loading',
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text,
        data: t,
      }
    : {
        state: 'loading',
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: t,
      }
}
function qP(e, t) {
  return {
    state: 'submitting',
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0,
  }
}
function ro(e) {
  return {
    state: 'idle',
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e,
  }
}
function KP(e, t) {
  try {
    let n = e.sessionStorage.getItem(q5)
    if (n) {
      let r = JSON.parse(n)
      for (let [i, s] of Object.entries(r || {}))
        s && Array.isArray(s) && t.set(i, new Set(s || []))
    }
  } catch {}
}
function GP(e, t) {
  if (t.size > 0) {
    let n = {}
    for (let [r, i] of t) n[r] = [...i]
    try {
      e.sessionStorage.setItem(q5, JSON.stringify(n))
    } catch (r) {
      vc(!1, 'Failed to save applied view transitions in sessionStorage (' + r + ').')
    }
  }
}
/**
 * React Router v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function pf() {
  return (
    (pf = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    pf.apply(this, arguments)
  )
}
const D0 = w.createContext(null),
  X5 = w.createContext(null),
  N0 = w.createContext(null),
  M0 = w.createContext(null),
  Ka = w.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
  Z5 = w.createContext(null)
function j0() {
  return w.useContext(M0) != null
}
function L0() {
  return j0() || ot(!1), w.useContext(M0).location
}
function J5(e) {
  w.useContext(N0).static || w.useLayoutEffect(e)
}
function $0() {
  let { isDataRoute: e } = w.useContext(Ka)
  return e ? lI() : YP()
}
function YP() {
  j0() || ot(!1)
  let e = w.useContext(D0),
    { basename: t, future: n, navigator: r } = w.useContext(N0),
    { matches: i } = w.useContext(Ka),
    { pathname: s } = L0(),
    o = JSON.stringify(W5(i, n.v7_relativeSplatPath)),
    a = w.useRef(!1)
  return (
    J5(() => {
      a.current = !0
    }),
    w.useCallback(
      function (c, u) {
        if ((u === void 0 && (u = {}), !a.current)) return
        if (typeof c == 'number') {
          r.go(c)
          return
        }
        let f = V5(c, JSON.parse(o), s, u.relative === 'path')
        e == null && t !== '/' && (f.pathname = f.pathname === '/' ? t : Do([t, f.pathname])),
          (u.replace ? r.replace : r.push)(f, u.state, u)
      },
      [t, r, o, s, e]
    )
  )
}
const QP = w.createContext(null)
function XP(e) {
  let t = w.useContext(Ka).outlet
  return t && w.createElement(QP.Provider, { value: e }, t)
}
function ZP(e, t, n, r) {
  j0() || ot(!1)
  let { navigator: i } = w.useContext(N0),
    { matches: s } = w.useContext(Ka),
    o = s[s.length - 1],
    a = o ? o.params : {}
  o && o.pathname
  let l = o ? o.pathnameBase : '/'
  o && o.route
  let c = L0(),
    u
  if (t) {
    var f
    let b = typeof t == 'string' ? Bs(t) : t
    l === '/' || ((f = b.pathname) != null && f.startsWith(l)) || ot(!1), (u = b)
  } else u = c
  let d = u.pathname || '/',
    p = d
  if (l !== '/') {
    let b = l.replace(/^\//, '').split('/')
    p = '/' + d.replace(/^\//, '').split('/').slice(b.length).join('/')
  }
  let h = kl(e, { pathname: p }),
    m = rI(
      h &&
        h.map((b) =>
          Object.assign({}, b, {
            params: Object.assign({}, a, b.params),
            pathname: Do([
              l,
              i.encodeLocation ? i.encodeLocation(b.pathname).pathname : b.pathname,
            ]),
            pathnameBase:
              b.pathnameBase === '/'
                ? l
                : Do([
                    l,
                    i.encodeLocation ? i.encodeLocation(b.pathnameBase).pathname : b.pathnameBase,
                  ]),
          })
        ),
      s,
      n,
      r
    )
  return t && m
    ? w.createElement(
        M0.Provider,
        {
          value: {
            location: pf({ pathname: '/', search: '', hash: '', state: null, key: 'default' }, u),
            navigationType: Zt.Pop,
          },
        },
        m
      )
    : m
}
function JP() {
  let e = aI(),
    t = pw(e) ? e.status + ' ' + e.statusText : e instanceof Error ? e.message : JSON.stringify(e),
    n = e instanceof Error ? e.stack : null,
    i = { padding: '0.5rem', backgroundColor: 'rgba(200,200,200, 0.5)' },
    s = null
  return w.createElement(
    w.Fragment,
    null,
    w.createElement('h2', null, 'Unexpected Application Error!'),
    w.createElement('h3', { style: { fontStyle: 'italic' } }, t),
    n ? w.createElement('pre', { style: i }, n) : null,
    s
  )
}
const eI = w.createElement(JP, null)
class tI extends w.Component {
  constructor(t) {
    super(t), (this.state = { location: t.location, revalidation: t.revalidation, error: t.error })
  }
  static getDerivedStateFromError(t) {
    return { error: t }
  }
  static getDerivedStateFromProps(t, n) {
    return n.location !== t.location || (n.revalidation !== 'idle' && t.revalidation === 'idle')
      ? { error: t.error, location: t.location, revalidation: t.revalidation }
      : {
          error: t.error !== void 0 ? t.error : n.error,
          location: n.location,
          revalidation: t.revalidation || n.revalidation,
        }
  }
  componentDidCatch(t, n) {
    console.error('React Router caught the following error during render', t, n)
  }
  render() {
    return this.state.error !== void 0
      ? w.createElement(
          Ka.Provider,
          { value: this.props.routeContext },
          w.createElement(Z5.Provider, { value: this.state.error, children: this.props.component })
        )
      : this.props.children
  }
}
function nI(e) {
  let { routeContext: t, match: n, children: r } = e,
    i = w.useContext(D0)
  return (
    i &&
      i.static &&
      i.staticContext &&
      (n.route.errorElement || n.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = n.route.id),
    w.createElement(Ka.Provider, { value: t }, r)
  )
}
function rI(e, t, n, r) {
  var i
  if (
    (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null)
  ) {
    var s
    if ((s = n) != null && s.errors) e = n.matches
    else return null
  }
  let o = e,
    a = (i = n) == null ? void 0 : i.errors
  if (a != null) {
    let u = o.findIndex((f) => f.route.id && (a == null ? void 0 : a[f.route.id]) !== void 0)
    u >= 0 || ot(!1), (o = o.slice(0, Math.min(o.length, u + 1)))
  }
  let l = !1,
    c = -1
  if (n && r && r.v7_partialHydration)
    for (let u = 0; u < o.length; u++) {
      let f = o[u]
      if (((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (c = u), f.route.id)) {
        let { loaderData: d, errors: p } = n,
          h = f.route.loader && d[f.route.id] === void 0 && (!p || p[f.route.id] === void 0)
        if (f.route.lazy || h) {
          ;(l = !0), c >= 0 ? (o = o.slice(0, c + 1)) : (o = [o[0]])
          break
        }
      }
    }
  return o.reduceRight((u, f, d) => {
    let p,
      h = !1,
      m = null,
      b = null
    n &&
      ((p = a && f.route.id ? a[f.route.id] : void 0),
      (m = f.route.errorElement || eI),
      l &&
        (c < 0 && d === 0
          ? (cI('route-fallback', !1), (h = !0), (b = null))
          : c === d && ((h = !0), (b = f.route.hydrateFallbackElement || null))))
    let y = t.concat(o.slice(0, d + 1)),
      v = () => {
        let S
        return (
          p
            ? (S = m)
            : h
            ? (S = b)
            : f.route.Component
            ? (S = w.createElement(f.route.Component, null))
            : f.route.element
            ? (S = f.route.element)
            : (S = u),
          w.createElement(nI, {
            match: f,
            routeContext: { outlet: u, matches: y, isDataRoute: n != null },
            children: S,
          })
        )
      }
    return n && (f.route.ErrorBoundary || f.route.errorElement || d === 0)
      ? w.createElement(tI, {
          location: n.location,
          revalidation: n.revalidation,
          component: m,
          error: p,
          children: v(),
          routeContext: { outlet: null, matches: y, isDataRoute: !0 },
        })
      : v()
  }, null)
}
var e_ = (function (e) {
    return (
      (e.UseBlocker = 'useBlocker'),
      (e.UseRevalidator = 'useRevalidator'),
      (e.UseNavigateStable = 'useNavigate'),
      e
    )
  })(e_ || {}),
  Np = (function (e) {
    return (
      (e.UseBlocker = 'useBlocker'),
      (e.UseLoaderData = 'useLoaderData'),
      (e.UseActionData = 'useActionData'),
      (e.UseRouteError = 'useRouteError'),
      (e.UseNavigation = 'useNavigation'),
      (e.UseRouteLoaderData = 'useRouteLoaderData'),
      (e.UseMatches = 'useMatches'),
      (e.UseRevalidator = 'useRevalidator'),
      (e.UseNavigateStable = 'useNavigate'),
      (e.UseRouteId = 'useRouteId'),
      e
    )
  })(Np || {})
function iI(e) {
  let t = w.useContext(D0)
  return t || ot(!1), t
}
function sI(e) {
  let t = w.useContext(X5)
  return t || ot(!1), t
}
function oI(e) {
  let t = w.useContext(Ka)
  return t || ot(!1), t
}
function t_(e) {
  let t = oI(),
    n = t.matches[t.matches.length - 1]
  return n.route.id || ot(!1), n.route.id
}
function aI() {
  var e
  let t = w.useContext(Z5),
    n = sI(Np.UseRouteError),
    r = t_(Np.UseRouteError)
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r]
}
function lI() {
  let { router: e } = iI(e_.UseNavigateStable),
    t = t_(Np.UseNavigateStable),
    n = w.useRef(!1)
  return (
    J5(() => {
      n.current = !0
    }),
    w.useCallback(
      function (i, s) {
        s === void 0 && (s = {}),
          n.current &&
            (typeof i == 'number' ? e.navigate(i) : e.navigate(i, pf({ fromRouteId: t }, s)))
      },
      [e, t]
    )
  )
}
const m2 = {}
function cI(e, t, n) {
  !t && !m2[e] && (m2[e] = !0)
}
function uI(e) {
  return XP(e.context)
}
function fI(e) {
  let {
    basename: t = '/',
    children: n = null,
    location: r,
    navigationType: i = Zt.Pop,
    navigator: s,
    static: o = !1,
    future: a,
  } = e
  j0() && ot(!1)
  let l = t.replace(/^\/*/, '/'),
    c = w.useMemo(
      () => ({ basename: l, navigator: s, static: o, future: pf({ v7_relativeSplatPath: !1 }, a) }),
      [l, a, s, o]
    )
  typeof r == 'string' && (r = Bs(r))
  let { pathname: u = '/', search: f = '', hash: d = '', state: p = null, key: h = 'default' } = r,
    m = w.useMemo(() => {
      let b = Zf(u, l)
      return b == null
        ? null
        : { location: { pathname: b, search: f, hash: d, state: p, key: h }, navigationType: i }
    }, [l, u, f, d, p, h, i])
  return m == null
    ? null
    : w.createElement(
        N0.Provider,
        { value: c },
        w.createElement(M0.Provider, { children: n, value: m })
      )
}
new Promise(() => {})
function dI(e) {
  let t = { hasErrorBoundary: e.ErrorBoundary != null || e.errorElement != null }
  return (
    e.Component && Object.assign(t, { element: w.createElement(e.Component), Component: void 0 }),
    e.HydrateFallback &&
      Object.assign(t, {
        hydrateFallbackElement: w.createElement(e.HydrateFallback),
        HydrateFallback: void 0,
      }),
    e.ErrorBoundary &&
      Object.assign(t, { errorElement: w.createElement(e.ErrorBoundary), ErrorBoundary: void 0 }),
    t
  )
}
/**
 * React Router DOM v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Mp() {
  return (
    (Mp = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Mp.apply(this, arguments)
  )
}
const hI = '6'
try {
  window.__reactRouterVersion = hI
} catch {}
function pI(e, t) {
  return PP({
    basename: t == null ? void 0 : t.basename,
    future: Mp({}, t == null ? void 0 : t.future, { v7_prependBasename: !0 }),
    history: eP({ window: t == null ? void 0 : t.window }),
    hydrationData: (t == null ? void 0 : t.hydrationData) || gI(),
    routes: e,
    mapRouteProperties: dI,
    unstable_dataStrategy: t == null ? void 0 : t.unstable_dataStrategy,
    window: t == null ? void 0 : t.window,
  }).initialize()
}
function gI() {
  var e
  let t = (e = window) == null ? void 0 : e.__staticRouterHydrationData
  return t && t.errors && (t = Mp({}, t, { errors: mI(t.errors) })), t
}
function mI(e) {
  if (!e) return null
  let t = Object.entries(e),
    n = {}
  for (let [r, i] of t)
    if (i && i.__type === 'RouteErrorResponse')
      n[r] = new hw(i.status, i.statusText, i.data, i.internal === !0)
    else if (i && i.__type === 'Error') {
      if (i.__subType) {
        let s = window[i.__subType]
        if (typeof s == 'function')
          try {
            let o = new s(i.message)
            ;(o.stack = ''), (n[r] = o)
          } catch {}
      }
      if (n[r] == null) {
        let s = new Error(i.message)
        ;(s.stack = ''), (n[r] = s)
      }
    } else n[r] = i
  return n
}
const yI = w.createContext({ isTransitioning: !1 }),
  vI = w.createContext(new Map()),
  wI = 'startTransition',
  y2 = cp[wI],
  bI = 'flushSync',
  v2 = IR[bI]
function xI(e) {
  y2 ? y2(e) : e()
}
function ou(e) {
  v2 ? v2(e) : e()
}
class SI {
  constructor() {
    ;(this.status = 'pending'),
      (this.promise = new Promise((t, n) => {
        ;(this.resolve = (r) => {
          this.status === 'pending' && ((this.status = 'resolved'), t(r))
        }),
          (this.reject = (r) => {
            this.status === 'pending' && ((this.status = 'rejected'), n(r))
          })
      }))
  }
}
function EI(e) {
  let { fallbackElement: t, router: n, future: r } = e,
    [i, s] = w.useState(n.state),
    [o, a] = w.useState(),
    [l, c] = w.useState({ isTransitioning: !1 }),
    [u, f] = w.useState(),
    [d, p] = w.useState(),
    [h, m] = w.useState(),
    b = w.useRef(new Map()),
    { v7_startTransition: y } = r || {},
    v = w.useCallback(
      (k) => {
        y ? xI(k) : k()
      },
      [y]
    ),
    S = w.useCallback(
      (k, D) => {
        let { deletedFetchers: F, unstable_flushSync: V, unstable_viewTransitionOpts: ie } = D
        F.forEach((xe) => b.current.delete(xe)),
          k.fetchers.forEach((xe, we) => {
            xe.data !== void 0 && b.current.set(we, xe.data)
          })
        let de =
          n.window == null ||
          n.window.document == null ||
          typeof n.window.document.startViewTransition != 'function'
        if (!ie || de) {
          V ? ou(() => s(k)) : v(() => s(k))
          return
        }
        if (V) {
          ou(() => {
            d && (u && u.resolve(), d.skipTransition()),
              c({
                isTransitioning: !0,
                flushSync: !0,
                currentLocation: ie.currentLocation,
                nextLocation: ie.nextLocation,
              })
          })
          let xe = n.window.document.startViewTransition(() => {
            ou(() => s(k))
          })
          xe.finished.finally(() => {
            ou(() => {
              f(void 0), p(void 0), a(void 0), c({ isTransitioning: !1 })
            })
          }),
            ou(() => p(xe))
          return
        }
        d
          ? (u && u.resolve(),
            d.skipTransition(),
            m({ state: k, currentLocation: ie.currentLocation, nextLocation: ie.nextLocation }))
          : (a(k),
            c({
              isTransitioning: !0,
              flushSync: !1,
              currentLocation: ie.currentLocation,
              nextLocation: ie.nextLocation,
            }))
      },
      [n.window, d, u, b, v]
    )
  w.useLayoutEffect(() => n.subscribe(S), [n, S]),
    w.useEffect(() => {
      l.isTransitioning && !l.flushSync && f(new SI())
    }, [l]),
    w.useEffect(() => {
      if (u && o && n.window) {
        let k = o,
          D = u.promise,
          F = n.window.document.startViewTransition(async () => {
            v(() => s(k)), await D
          })
        F.finished.finally(() => {
          f(void 0), p(void 0), a(void 0), c({ isTransitioning: !1 })
        }),
          p(F)
      }
    }, [v, o, u, n.window]),
    w.useEffect(() => {
      u && o && i.location.key === o.location.key && u.resolve()
    }, [u, d, i.location, o]),
    w.useEffect(() => {
      !l.isTransitioning &&
        h &&
        (a(h.state),
        c({
          isTransitioning: !0,
          flushSync: !1,
          currentLocation: h.currentLocation,
          nextLocation: h.nextLocation,
        }),
        m(void 0))
    }, [l.isTransitioning, h]),
    w.useEffect(() => {}, [])
  let T = w.useMemo(
      () => ({
        createHref: n.createHref,
        encodeLocation: n.encodeLocation,
        go: (k) => n.navigate(k),
        push: (k, D, F) =>
          n.navigate(k, {
            state: D,
            preventScrollReset: F == null ? void 0 : F.preventScrollReset,
          }),
        replace: (k, D, F) =>
          n.navigate(k, {
            replace: !0,
            state: D,
            preventScrollReset: F == null ? void 0 : F.preventScrollReset,
          }),
      }),
      [n]
    ),
    A = n.basename || '/',
    I = w.useMemo(() => ({ router: n, navigator: T, static: !1, basename: A }), [n, T, A])
  return w.createElement(
    w.Fragment,
    null,
    w.createElement(
      D0.Provider,
      { value: I },
      w.createElement(
        X5.Provider,
        { value: i },
        w.createElement(
          vI.Provider,
          { value: b.current },
          w.createElement(
            yI.Provider,
            { value: l },
            w.createElement(
              fI,
              {
                basename: A,
                location: i.location,
                navigationType: i.historyAction,
                navigator: T,
                future: { v7_relativeSplatPath: n.future.v7_relativeSplatPath },
              },
              i.initialized || n.future.v7_partialHydration
                ? w.createElement(CI, { routes: n.routes, future: n.future, state: i })
                : t
            )
          )
        )
      )
    ),
    null
  )
}
function CI(e) {
  let { routes: t, future: n, state: r } = e
  return ZP(t, void 0, r, n)
}
var w2
;(function (e) {
  ;(e.UseScrollRestoration = 'useScrollRestoration'),
    (e.UseSubmit = 'useSubmit'),
    (e.UseSubmitFetcher = 'useSubmitFetcher'),
    (e.UseFetcher = 'useFetcher'),
    (e.useViewTransitionState = 'useViewTransitionState')
})(w2 || (w2 = {}))
var b2
;(function (e) {
  ;(e.UseFetcher = 'useFetcher'),
    (e.UseFetchers = 'useFetchers'),
    (e.UseScrollRestoration = 'useScrollRestoration')
})(b2 || (b2 = {}))
/**
 * @license
 * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */ const Nn = 'w',
  Fr = 'b',
  vn = 'p',
  Wy = 'n',
  yh = 'b',
  wu = 'r',
  fo = 'q',
  cn = 'k',
  Xg = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
  tr = -1,
  _I = {
    NORMAL: 'n',
    CAPTURE: 'c',
    BIG_PAWN: 'b',
    EP_CAPTURE: 'e',
    PROMOTION: 'p',
    KSIDE_CASTLE: 'k',
    QSIDE_CASTLE: 'q',
  },
  Ve = {
    NORMAL: 1,
    CAPTURE: 2,
    BIG_PAWN: 4,
    EP_CAPTURE: 8,
    PROMOTION: 16,
    KSIDE_CASTLE: 32,
    QSIDE_CASTLE: 64,
  },
  Ye = {
    a8: 0,
    b8: 1,
    c8: 2,
    d8: 3,
    e8: 4,
    f8: 5,
    g8: 6,
    h8: 7,
    a7: 16,
    b7: 17,
    c7: 18,
    d7: 19,
    e7: 20,
    f7: 21,
    g7: 22,
    h7: 23,
    a6: 32,
    b6: 33,
    c6: 34,
    d6: 35,
    e6: 36,
    f6: 37,
    g6: 38,
    h6: 39,
    a5: 48,
    b5: 49,
    c5: 50,
    d5: 51,
    e5: 52,
    f5: 53,
    g5: 54,
    h5: 55,
    a4: 64,
    b4: 65,
    c4: 66,
    d4: 67,
    e4: 68,
    f4: 69,
    g4: 70,
    h4: 71,
    a3: 80,
    b3: 81,
    c3: 82,
    d3: 83,
    e3: 84,
    f3: 85,
    g3: 86,
    h3: 87,
    a2: 96,
    b2: 97,
    c2: 98,
    d2: 99,
    e2: 100,
    f2: 101,
    g2: 102,
    h2: 103,
    a1: 112,
    b1: 113,
    c1: 114,
    d1: 115,
    e1: 116,
    f1: 117,
    g1: 118,
    h1: 119,
  },
  Zg = { b: [16, 32, 17, 15], w: [-16, -32, -17, -15] },
  x2 = {
    n: [-18, -33, -31, -14, 18, 33, 31, 14],
    b: [-17, -15, 17, 15],
    r: [-16, 1, 16, -1],
    q: [-17, -16, -15, 1, 17, 16, 15, -1],
    k: [-17, -16, -15, 1, 17, 16, 15, -1],
  },
  OI = [
    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20,
    0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20,
    0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56,
    0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0,
    0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,
    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0,
    20,
  ],
  kI = [
    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15,
    0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15,
    0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1,
    -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0,
    0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17,
    0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0,
    0, 0, 0, 0, -17,
  ],
  TI = { p: 1, n: 2, b: 4, r: 8, q: 16, k: 32 },
  AI = 'pnbrqkPNBRQK',
  S2 = [Wy, yh, wu, fo],
  RI = 7,
  PI = 6,
  II = 1,
  DI = 0,
  Td = { [cn]: Ve.KSIDE_CASTLE, [fo]: Ve.QSIDE_CASTLE },
  Ks = {
    w: [
      { square: Ye.a1, flag: Ve.QSIDE_CASTLE },
      { square: Ye.h1, flag: Ve.KSIDE_CASTLE },
    ],
    b: [
      { square: Ye.a8, flag: Ve.QSIDE_CASTLE },
      { square: Ye.h8, flag: Ve.KSIDE_CASTLE },
    ],
  },
  NI = { b: II, w: PI },
  MI = ['1-0', '0-1', '1/2-1/2', '*']
function Aa(e) {
  return e >> 4
}
function gf(e) {
  return e & 15
}
function n_(e) {
  return '0123456789'.indexOf(e) !== -1
}
function mr(e) {
  const t = gf(e),
    n = Aa(e)
  return 'abcdefgh'.substring(t, t + 1) + '87654321'.substring(n, n + 1)
}
function au(e) {
  return e === Nn ? Fr : Nn
}
function jI(e) {
  const t = e.split(/\s+/)
  if (t.length !== 6)
    return { ok: !1, error: 'Invalid FEN: must contain six space-delimited fields' }
  const n = parseInt(t[5], 10)
  if (isNaN(n) || n <= 0)
    return { ok: !1, error: 'Invalid FEN: move number must be a positive integer' }
  const r = parseInt(t[4], 10)
  if (isNaN(r) || r < 0)
    return { ok: !1, error: 'Invalid FEN: half move counter number must be a non-negative integer' }
  if (!/^(-|[abcdefgh][36])$/.test(t[3]))
    return { ok: !1, error: 'Invalid FEN: en-passant square is invalid' }
  if (/[^kKqQ-]/.test(t[2]))
    return { ok: !1, error: 'Invalid FEN: castling availability is invalid' }
  if (!/^(w|b)$/.test(t[1])) return { ok: !1, error: 'Invalid FEN: side-to-move is invalid' }
  const i = t[0].split('/')
  if (i.length !== 8)
    return { ok: !1, error: "Invalid FEN: piece data does not contain 8 '/'-delimited rows" }
  for (let o = 0; o < i.length; o++) {
    let a = 0,
      l = !1
    for (let c = 0; c < i[o].length; c++)
      if (n_(i[o][c])) {
        if (l) return { ok: !1, error: 'Invalid FEN: piece data is invalid (consecutive number)' }
        ;(a += parseInt(i[o][c], 10)), (l = !0)
      } else {
        if (!/^[prnbqkPRNBQK]$/.test(i[o][c]))
          return { ok: !1, error: 'Invalid FEN: piece data is invalid (invalid piece)' }
        ;(a += 1), (l = !1)
      }
    if (a !== 8)
      return { ok: !1, error: 'Invalid FEN: piece data is invalid (too many squares in rank)' }
  }
  if ((t[3][1] == '3' && t[1] == 'w') || (t[3][1] == '6' && t[1] == 'b'))
    return { ok: !1, error: 'Invalid FEN: illegal en-passant square' }
  const s = [
    { color: 'white', regex: /K/g },
    { color: 'black', regex: /k/g },
  ]
  for (const { color: o, regex: a } of s) {
    if (!a.test(t[0])) return { ok: !1, error: `Invalid FEN: missing ${o} king` }
    if ((t[0].match(a) || []).length > 1)
      return { ok: !1, error: `Invalid FEN: too many ${o} kings` }
  }
  return Array.from(i[0] + i[7]).some((o) => o.toUpperCase() === 'P')
    ? { ok: !1, error: 'Invalid FEN: some pawns are on the edge rows' }
    : { ok: !0 }
}
function LI(e, t) {
  const n = e.from,
    r = e.to,
    i = e.piece
  let s = 0,
    o = 0,
    a = 0
  for (let l = 0, c = t.length; l < c; l++) {
    const u = t[l].from,
      f = t[l].to,
      d = t[l].piece
    i === d && n !== u && r === f && (s++, Aa(n) === Aa(u) && o++, gf(n) === gf(u) && a++)
  }
  return s > 0 ? (o > 0 && a > 0 ? mr(n) : a > 0 ? mr(n).charAt(1) : mr(n).charAt(0)) : ''
}
function Gs(e, t, n, r, i, s = void 0, o = Ve.NORMAL) {
  const a = Aa(r)
  if (i === vn && (a === RI || a === DI))
    for (let l = 0; l < S2.length; l++) {
      const c = S2[l]
      e.push({
        color: t,
        from: n,
        to: r,
        piece: i,
        captured: s,
        promotion: c,
        flags: o | Ve.PROMOTION,
      })
    }
  else e.push({ color: t, from: n, to: r, piece: i, captured: s, flags: o })
}
function E2(e) {
  let t = e.charAt(0)
  return t >= 'a' && t <= 'h'
    ? e.match(/[a-h]\d.*[a-h]\d/)
      ? void 0
      : vn
    : ((t = t.toLowerCase()), t === 'o' ? cn : t)
}
function Jg(e) {
  return e.replace(/=/, '').replace(/[+#]?[?!]*$/, '')
}
function em(e) {
  return e.split(' ').slice(0, 4).join(' ')
}
class Ad {
  constructor(t = Xg) {
    zn(this, '_board', new Array(128))
    zn(this, '_turn', Nn)
    zn(this, '_header', {})
    zn(this, '_kings', { w: tr, b: tr })
    zn(this, '_epSquare', -1)
    zn(this, '_halfMoves', 0)
    zn(this, '_moveNumber', 0)
    zn(this, '_history', [])
    zn(this, '_comments', {})
    zn(this, '_castling', { w: 0, b: 0 })
    zn(this, '_positionCount', {})
    this.load(t)
  }
  clear({ preserveHeaders: t = !1 } = {}) {
    ;(this._board = new Array(128)),
      (this._kings = { w: tr, b: tr }),
      (this._turn = Nn),
      (this._castling = { w: 0, b: 0 }),
      (this._epSquare = tr),
      (this._halfMoves = 0),
      (this._moveNumber = 1),
      (this._history = []),
      (this._comments = {}),
      (this._header = t ? this._header : {}),
      (this._positionCount = {}),
      delete this._header.SetUp,
      delete this._header.FEN
  }
  removeHeader(t) {
    t in this._header && delete this._header[t]
  }
  load(t, { skipValidation: n = !1, preserveHeaders: r = !1 } = {}) {
    let i = t.split(/\s+/)
    if (i.length >= 2 && i.length < 6) {
      const a = ['-', '-', '0', '1']
      t = i.concat(a.slice(-(6 - i.length))).join(' ')
    }
    if (((i = t.split(/\s+/)), !n)) {
      const { ok: a, error: l } = jI(t)
      if (!a) throw new Error(l)
    }
    const s = i[0]
    let o = 0
    this.clear({ preserveHeaders: r })
    for (let a = 0; a < s.length; a++) {
      const l = s.charAt(a)
      if (l === '/') o += 8
      else if (n_(l)) o += parseInt(l, 10)
      else {
        const c = l < 'a' ? Nn : Fr
        this._put({ type: l.toLowerCase(), color: c }, mr(o)), o++
      }
    }
    ;(this._turn = i[1]),
      i[2].indexOf('K') > -1 && (this._castling.w |= Ve.KSIDE_CASTLE),
      i[2].indexOf('Q') > -1 && (this._castling.w |= Ve.QSIDE_CASTLE),
      i[2].indexOf('k') > -1 && (this._castling.b |= Ve.KSIDE_CASTLE),
      i[2].indexOf('q') > -1 && (this._castling.b |= Ve.QSIDE_CASTLE),
      (this._epSquare = i[3] === '-' ? tr : Ye[i[3]]),
      (this._halfMoves = parseInt(i[4], 10)),
      (this._moveNumber = parseInt(i[5], 10)),
      this._updateSetup(t),
      this._incPositionCount(t)
  }
  fen() {
    var s, o
    let t = 0,
      n = ''
    for (let a = Ye.a8; a <= Ye.h1; a++) {
      if (this._board[a]) {
        t > 0 && ((n += t), (t = 0))
        const { color: l, type: c } = this._board[a]
        n += l === Nn ? c.toUpperCase() : c.toLowerCase()
      } else t++
      ;(a + 1) & 136 && (t > 0 && (n += t), a !== Ye.h1 && (n += '/'), (t = 0), (a += 8))
    }
    let r = ''
    this._castling[Nn] & Ve.KSIDE_CASTLE && (r += 'K'),
      this._castling[Nn] & Ve.QSIDE_CASTLE && (r += 'Q'),
      this._castling[Fr] & Ve.KSIDE_CASTLE && (r += 'k'),
      this._castling[Fr] & Ve.QSIDE_CASTLE && (r += 'q'),
      (r = r || '-')
    let i = '-'
    if (this._epSquare !== tr) {
      const a = this._epSquare + (this._turn === Nn ? 16 : -16),
        l = [a + 1, a - 1]
      for (const c of l) {
        if (c & 136) continue
        const u = this._turn
        if (
          ((s = this._board[c]) == null ? void 0 : s.color) === u &&
          ((o = this._board[c]) == null ? void 0 : o.type) === vn
        ) {
          this._makeMove({
            color: u,
            from: c,
            to: this._epSquare,
            piece: vn,
            captured: vn,
            flags: Ve.EP_CAPTURE,
          })
          const f = !this._isKingAttacked(u)
          if ((this._undoMove(), f)) {
            i = mr(this._epSquare)
            break
          }
        }
      }
    }
    return [n, this._turn, r, i, this._halfMoves, this._moveNumber].join(' ')
  }
  _updateSetup(t) {
    this._history.length > 0 ||
      (t !== Xg
        ? ((this._header.SetUp = '1'), (this._header.FEN = t))
        : (delete this._header.SetUp, delete this._header.FEN))
  }
  reset() {
    this.load(Xg)
  }
  get(t) {
    return this._board[Ye[t]] || !1
  }
  put({ type: t, color: n }, r) {
    return this._put({ type: t, color: n }, r)
      ? (this._updateCastlingRights(),
        this._updateEnPassantSquare(),
        this._updateSetup(this.fen()),
        !0)
      : !1
  }
  _put({ type: t, color: n }, r) {
    if (AI.indexOf(t.toLowerCase()) === -1 || !(r in Ye)) return !1
    const i = Ye[r]
    if (t == cn && !(this._kings[n] == tr || this._kings[n] == i)) return !1
    const s = this._board[i]
    return (
      s && s.type === cn && (this._kings[s.color] = tr),
      (this._board[i] = { type: t, color: n }),
      t === cn && (this._kings[n] = i),
      !0
    )
  }
  remove(t) {
    const n = this.get(t)
    return (
      delete this._board[Ye[t]],
      n && n.type === cn && (this._kings[n.color] = tr),
      this._updateCastlingRights(),
      this._updateEnPassantSquare(),
      this._updateSetup(this.fen()),
      n
    )
  }
  _updateCastlingRights() {
    var r, i, s, o, a, l, c, u, f, d, p, h
    const t =
        ((r = this._board[Ye.e1]) == null ? void 0 : r.type) === cn &&
        ((i = this._board[Ye.e1]) == null ? void 0 : i.color) === Nn,
      n =
        ((s = this._board[Ye.e8]) == null ? void 0 : s.type) === cn &&
        ((o = this._board[Ye.e8]) == null ? void 0 : o.color) === Fr
    ;(!t ||
      ((a = this._board[Ye.a1]) == null ? void 0 : a.type) !== wu ||
      ((l = this._board[Ye.a1]) == null ? void 0 : l.color) !== Nn) &&
      (this._castling.w &= ~Ve.QSIDE_CASTLE),
      (!t ||
        ((c = this._board[Ye.h1]) == null ? void 0 : c.type) !== wu ||
        ((u = this._board[Ye.h1]) == null ? void 0 : u.color) !== Nn) &&
        (this._castling.w &= ~Ve.KSIDE_CASTLE),
      (!n ||
        ((f = this._board[Ye.a8]) == null ? void 0 : f.type) !== wu ||
        ((d = this._board[Ye.a8]) == null ? void 0 : d.color) !== Fr) &&
        (this._castling.b &= ~Ve.QSIDE_CASTLE),
      (!n ||
        ((p = this._board[Ye.h8]) == null ? void 0 : p.type) !== wu ||
        ((h = this._board[Ye.h8]) == null ? void 0 : h.color) !== Fr) &&
        (this._castling.b &= ~Ve.KSIDE_CASTLE)
  }
  _updateEnPassantSquare() {
    var s, o
    if (this._epSquare === tr) return
    const t = this._epSquare + (this._turn === Nn ? -16 : 16),
      n = this._epSquare + (this._turn === Nn ? 16 : -16),
      r = [n + 1, n - 1]
    if (
      this._board[t] !== null ||
      this._board[this._epSquare] !== null ||
      ((s = this._board[n]) == null ? void 0 : s.color) !== au(this._turn) ||
      ((o = this._board[n]) == null ? void 0 : o.type) !== vn
    ) {
      this._epSquare = tr
      return
    }
    const i = (a) => {
      var l, c
      return (
        !(a & 136) &&
        ((l = this._board[a]) == null ? void 0 : l.color) === this._turn &&
        ((c = this._board[a]) == null ? void 0 : c.type) === vn
      )
    }
    r.some(i) || (this._epSquare = tr)
  }
  _attacked(t, n) {
    for (let r = Ye.a8; r <= Ye.h1; r++) {
      if (r & 136) {
        r += 7
        continue
      }
      if (this._board[r] === void 0 || this._board[r].color !== t) continue
      const i = this._board[r],
        s = r - n
      if (s === 0) continue
      const o = s + 119
      if (OI[o] & TI[i.type]) {
        if (i.type === vn) {
          if (s > 0) {
            if (i.color === Nn) return !0
          } else if (i.color === Fr) return !0
          continue
        }
        if (i.type === 'n' || i.type === 'k') return !0
        const a = kI[o]
        let l = r + a,
          c = !1
        for (; l !== n; ) {
          if (this._board[l] != null) {
            c = !0
            break
          }
          l += a
        }
        if (!c) return !0
      }
    }
    return !1
  }
  _isKingAttacked(t) {
    const n = this._kings[t]
    return n === -1 ? !1 : this._attacked(au(t), n)
  }
  isAttacked(t, n) {
    return this._attacked(n, Ye[t])
  }
  isCheck() {
    return this._isKingAttacked(this._turn)
  }
  inCheck() {
    return this.isCheck()
  }
  isCheckmate() {
    return this.isCheck() && this._moves().length === 0
  }
  isStalemate() {
    return !this.isCheck() && this._moves().length === 0
  }
  isInsufficientMaterial() {
    const t = { b: 0, n: 0, r: 0, q: 0, k: 0, p: 0 },
      n = []
    let r = 0,
      i = 0
    for (let s = Ye.a8; s <= Ye.h1; s++) {
      if (((i = (i + 1) % 2), s & 136)) {
        s += 7
        continue
      }
      const o = this._board[s]
      o && ((t[o.type] = o.type in t ? t[o.type] + 1 : 1), o.type === yh && n.push(i), r++)
    }
    if (r === 2) return !0
    if (r === 3 && (t[yh] === 1 || t[Wy] === 1)) return !0
    if (r === t[yh] + 2) {
      let s = 0
      const o = n.length
      for (let a = 0; a < o; a++) s += n[a]
      if (s === 0 || s === o) return !0
    }
    return !1
  }
  isThreefoldRepetition() {
    return this._getPositionCount(this.fen()) >= 3
  }
  isDraw() {
    return (
      this._halfMoves >= 100 ||
      this.isStalemate() ||
      this.isInsufficientMaterial() ||
      this.isThreefoldRepetition()
    )
  }
  isGameOver() {
    return this.isCheckmate() || this.isStalemate() || this.isDraw()
  }
  moves({ verbose: t = !1, square: n = void 0, piece: r = void 0 } = {}) {
    const i = this._moves({ square: n, piece: r })
    return t ? i.map((s) => this._makePretty(s)) : i.map((s) => this._moveToSan(s, i))
  }
  _moves({ legal: t = !0, piece: n = void 0, square: r = void 0 } = {}) {
    var p
    const i = r ? r.toLowerCase() : void 0,
      s = n == null ? void 0 : n.toLowerCase(),
      o = [],
      a = this._turn,
      l = au(a)
    let c = Ye.a8,
      u = Ye.h1,
      f = !1
    if (i)
      if (i in Ye) (c = u = Ye[i]), (f = !0)
      else return []
    for (let h = c; h <= u; h++) {
      if (h & 136) {
        h += 7
        continue
      }
      if (!this._board[h] || this._board[h].color === l) continue
      const { type: m } = this._board[h]
      let b
      if (m === vn) {
        if (s && s !== m) continue
        ;(b = h + Zg[a][0]),
          this._board[b] ||
            (Gs(o, a, h, b, vn),
            (b = h + Zg[a][1]),
            NI[a] === Aa(h) && !this._board[b] && Gs(o, a, h, b, vn, void 0, Ve.BIG_PAWN))
        for (let y = 2; y < 4; y++)
          (b = h + Zg[a][y]),
            !(b & 136) &&
              (((p = this._board[b]) == null ? void 0 : p.color) === l
                ? Gs(o, a, h, b, vn, this._board[b].type, Ve.CAPTURE)
                : b === this._epSquare && Gs(o, a, h, b, vn, vn, Ve.EP_CAPTURE))
      } else {
        if (s && s !== m) continue
        for (let y = 0, v = x2[m].length; y < v; y++) {
          const S = x2[m][y]
          for (b = h; (b += S), !(b & 136); ) {
            if (!this._board[b]) Gs(o, a, h, b, m)
            else {
              if (this._board[b].color === a) break
              Gs(o, a, h, b, m, this._board[b].type, Ve.CAPTURE)
              break
            }
            if (m === Wy || m === cn) break
          }
        }
      }
    }
    if ((s === void 0 || s === cn) && (!f || u === this._kings[a])) {
      if (this._castling[a] & Ve.KSIDE_CASTLE) {
        const h = this._kings[a],
          m = h + 2
        !this._board[h + 1] &&
          !this._board[m] &&
          !this._attacked(l, this._kings[a]) &&
          !this._attacked(l, h + 1) &&
          !this._attacked(l, m) &&
          Gs(o, a, this._kings[a], m, cn, void 0, Ve.KSIDE_CASTLE)
      }
      if (this._castling[a] & Ve.QSIDE_CASTLE) {
        const h = this._kings[a],
          m = h - 2
        !this._board[h - 1] &&
          !this._board[h - 2] &&
          !this._board[h - 3] &&
          !this._attacked(l, this._kings[a]) &&
          !this._attacked(l, h - 1) &&
          !this._attacked(l, m) &&
          Gs(o, a, this._kings[a], m, cn, void 0, Ve.QSIDE_CASTLE)
      }
    }
    if (!t || this._kings[a] === -1) return o
    const d = []
    for (let h = 0, m = o.length; h < m; h++)
      this._makeMove(o[h]), this._isKingAttacked(a) || d.push(o[h]), this._undoMove()
    return d
  }
  move(t, { strict: n = !1 } = {}) {
    let r = null
    if (typeof t == 'string') r = this._moveFromSan(t, n)
    else if (typeof t == 'object') {
      const s = this._moves()
      for (let o = 0, a = s.length; o < a; o++)
        if (
          t.from === mr(s[o].from) &&
          t.to === mr(s[o].to) &&
          (!('promotion' in s[o]) || t.promotion === s[o].promotion)
        ) {
          r = s[o]
          break
        }
    }
    if (!r)
      throw typeof t == 'string'
        ? new Error(`Invalid move: ${t}`)
        : new Error(`Invalid move: ${JSON.stringify(t)}`)
    const i = this._makePretty(r)
    return this._makeMove(r), this._incPositionCount(i.after), i
  }
  _push(t) {
    this._history.push({
      move: t,
      kings: { b: this._kings.b, w: this._kings.w },
      turn: this._turn,
      castling: { b: this._castling.b, w: this._castling.w },
      epSquare: this._epSquare,
      halfMoves: this._halfMoves,
      moveNumber: this._moveNumber,
    })
  }
  _makeMove(t) {
    const n = this._turn,
      r = au(n)
    if (
      (this._push(t),
      (this._board[t.to] = this._board[t.from]),
      delete this._board[t.from],
      t.flags & Ve.EP_CAPTURE &&
        (this._turn === Fr ? delete this._board[t.to - 16] : delete this._board[t.to + 16]),
      t.promotion && (this._board[t.to] = { type: t.promotion, color: n }),
      this._board[t.to].type === cn)
    ) {
      if (((this._kings[n] = t.to), t.flags & Ve.KSIDE_CASTLE)) {
        const i = t.to - 1,
          s = t.to + 1
        ;(this._board[i] = this._board[s]), delete this._board[s]
      } else if (t.flags & Ve.QSIDE_CASTLE) {
        const i = t.to + 1,
          s = t.to - 2
        ;(this._board[i] = this._board[s]), delete this._board[s]
      }
      this._castling[n] = 0
    }
    if (this._castling[n]) {
      for (let i = 0, s = Ks[n].length; i < s; i++)
        if (t.from === Ks[n][i].square && this._castling[n] & Ks[n][i].flag) {
          this._castling[n] ^= Ks[n][i].flag
          break
        }
    }
    if (this._castling[r]) {
      for (let i = 0, s = Ks[r].length; i < s; i++)
        if (t.to === Ks[r][i].square && this._castling[r] & Ks[r][i].flag) {
          this._castling[r] ^= Ks[r][i].flag
          break
        }
    }
    t.flags & Ve.BIG_PAWN
      ? n === Fr
        ? (this._epSquare = t.to - 16)
        : (this._epSquare = t.to + 16)
      : (this._epSquare = tr),
      t.piece === vn
        ? (this._halfMoves = 0)
        : t.flags & (Ve.CAPTURE | Ve.EP_CAPTURE)
        ? (this._halfMoves = 0)
        : this._halfMoves++,
      n === Fr && this._moveNumber++,
      (this._turn = r)
  }
  undo() {
    const t = this._undoMove()
    if (t) {
      const n = this._makePretty(t)
      return this._decPositionCount(n.after), n
    }
    return null
  }
  _undoMove() {
    const t = this._history.pop()
    if (t === void 0) return null
    const n = t.move
    ;(this._kings = t.kings),
      (this._turn = t.turn),
      (this._castling = t.castling),
      (this._epSquare = t.epSquare),
      (this._halfMoves = t.halfMoves),
      (this._moveNumber = t.moveNumber)
    const r = this._turn,
      i = au(r)
    if (
      ((this._board[n.from] = this._board[n.to]),
      (this._board[n.from].type = n.piece),
      delete this._board[n.to],
      n.captured)
    )
      if (n.flags & Ve.EP_CAPTURE) {
        let s
        r === Fr ? (s = n.to - 16) : (s = n.to + 16), (this._board[s] = { type: vn, color: i })
      } else this._board[n.to] = { type: n.captured, color: i }
    if (n.flags & (Ve.KSIDE_CASTLE | Ve.QSIDE_CASTLE)) {
      let s, o
      n.flags & Ve.KSIDE_CASTLE
        ? ((s = n.to + 1), (o = n.to - 1))
        : ((s = n.to - 2), (o = n.to + 1)),
        (this._board[s] = this._board[o]),
        delete this._board[o]
    }
    return n
  }
  pgn({
    newline: t = `
`,
    maxWidth: n = 0,
  } = {}) {
    const r = []
    let i = !1
    for (const d in this._header) r.push('[' + d + ' "' + this._header[d] + '"]' + t), (i = !0)
    i && this._history.length && r.push(t)
    const s = (d) => {
        const p = this._comments[this.fen()]
        if (typeof p < 'u') {
          const h = d.length > 0 ? ' ' : ''
          d = `${d}${h}{${p}}`
        }
        return d
      },
      o = []
    for (; this._history.length > 0; ) o.push(this._undoMove())
    const a = []
    let l = ''
    for (o.length === 0 && a.push(s('')); o.length > 0; ) {
      l = s(l)
      const d = o.pop()
      if (!d) break
      if (!this._history.length && d.color === 'b') {
        const p = `${this._moveNumber}. ...`
        l = l ? `${l} ${p}` : p
      } else d.color === 'w' && (l.length && a.push(l), (l = this._moveNumber + '.'))
      ;(l = l + ' ' + this._moveToSan(d, this._moves({ legal: !0 }))), this._makeMove(d)
    }
    if (
      (l.length && a.push(s(l)),
      typeof this._header.Result < 'u' && a.push(this._header.Result),
      n === 0)
    )
      return r.join('') + a.join(' ')
    const c = function () {
        return r.length > 0 && r[r.length - 1] === ' ' ? (r.pop(), !0) : !1
      },
      u = function (d, p) {
        for (const h of p.split(' '))
          if (h) {
            if (d + h.length > n) {
              for (; c(); ) d--
              r.push(t), (d = 0)
            }
            r.push(h), (d += h.length), r.push(' '), d++
          }
        return c() && d--, d
      }
    let f = 0
    for (let d = 0; d < a.length; d++) {
      if (f + a[d].length > n && a[d].includes('{')) {
        f = u(f, a[d])
        continue
      }
      f + a[d].length > n && d !== 0
        ? (r[r.length - 1] === ' ' && r.pop(), r.push(t), (f = 0))
        : d !== 0 && (r.push(' '), f++),
        r.push(a[d]),
        (f += a[d].length)
    }
    return r.join('')
  }
  header(...t) {
    for (let n = 0; n < t.length; n += 2)
      typeof t[n] == 'string' && typeof t[n + 1] == 'string' && (this._header[t[n]] = t[n + 1])
    return this._header
  }
  loadPgn(
    t,
    {
      strict: n = !1,
      newlineChar: r = `\r?
`,
    } = {}
  ) {
    function i(S) {
      return S.replace(/\\/g, '\\')
    }
    function s(S) {
      const T = {},
        A = S.split(new RegExp(i(r)))
      let I = '',
        k = ''
      for (let D = 0; D < A.length; D++) {
        const F = /^\s*\[\s*([A-Za-z]+)\s*"(.*)"\s*\]\s*$/
        ;(I = A[D].replace(F, '$1')), (k = A[D].replace(F, '$2')), I.trim().length > 0 && (T[I] = k)
      }
      return T
    }
    t = t.trim()
    const a = new RegExp(
        '^(\\[((?:' + i(r) + ')|.)*\\])((?:\\s*' + i(r) + '){2}|(?:\\s*' + i(r) + ')*$)'
      ).exec(t),
      l = a && a.length >= 2 ? a[1] : ''
    this.reset()
    const c = s(l)
    let u = ''
    for (const S in c) S.toLowerCase() === 'fen' && (u = c[S]), this.header(S, c[S])
    if (!n) u && this.load(u, { preserveHeaders: !0 })
    else if (c.SetUp === '1') {
      if (!('FEN' in c)) throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag')
      this.load(c.FEN, { preserveHeaders: !0 })
    }
    function f(S) {
      return Array.from(S)
        .map(function (T) {
          return T.charCodeAt(0) < 128
            ? T.charCodeAt(0).toString(16)
            : encodeURIComponent(T).replace(/%/g, '').toLowerCase()
        })
        .join('')
    }
    function d(S) {
      return S.length == 0 ? '' : decodeURIComponent('%' + (S.match(/.{1,2}/g) || []).join('%'))
    }
    const p = function (S) {
        return (S = S.replace(new RegExp(i(r), 'g'), ' ')), `{${f(S.slice(1, S.length - 1))}}`
      },
      h = function (S) {
        if (S.startsWith('{') && S.endsWith('}')) return d(S.slice(1, S.length - 1))
      }
    let m = t
      .replace(l, '')
      .replace(new RegExp(`({[^}]*})+?|;([^${i(r)}]*)`, 'g'), function (S, T, A) {
        return T !== void 0 ? p(T) : ' ' + p(`{${A.slice(1)}}`)
      })
      .replace(new RegExp(i(r), 'g'), ' ')
    const b = /(\([^()]+\))+?/g
    for (; b.test(m); ) m = m.replace(b, '')
    ;(m = m.replace(/\d+\.(\.\.)?/g, '')),
      (m = m.replace(/\.\.\./g, '')),
      (m = m.replace(/\$\d+/g, ''))
    let y = m.trim().split(new RegExp(/\s+/))
    y = y.filter((S) => S !== '')
    let v = ''
    for (let S = 0; S < y.length; S++) {
      const T = h(y[S])
      if (T !== void 0) {
        this._comments[this.fen()] = T
        continue
      }
      const A = this._moveFromSan(y[S], n)
      if (A == null)
        if (MI.indexOf(y[S]) > -1) v = y[S]
        else throw new Error(`Invalid move in PGN: ${y[S]}`)
      else (v = ''), this._makeMove(A), this._incPositionCount(this.fen())
    }
    v && Object.keys(this._header).length && !this._header.Result && this.header('Result', v)
  }
  _moveToSan(t, n) {
    let r = ''
    if (t.flags & Ve.KSIDE_CASTLE) r = 'O-O'
    else if (t.flags & Ve.QSIDE_CASTLE) r = 'O-O-O'
    else {
      if (t.piece !== vn) {
        const i = LI(t, n)
        r += t.piece.toUpperCase() + i
      }
      t.flags & (Ve.CAPTURE | Ve.EP_CAPTURE) &&
        (t.piece === vn && (r += mr(t.from)[0]), (r += 'x')),
        (r += mr(t.to)),
        t.promotion && (r += '=' + t.promotion.toUpperCase())
    }
    return (
      this._makeMove(t),
      this.isCheck() && (this.isCheckmate() ? (r += '#') : (r += '+')),
      this._undoMove(),
      r
    )
  }
  _moveFromSan(t, n = !1) {
    const r = Jg(t)
    let i = E2(r),
      s = this._moves({ legal: !0, piece: i })
    for (let d = 0, p = s.length; d < p; d++) if (r === Jg(this._moveToSan(s[d], s))) return s[d]
    if (n) return null
    let o,
      a,
      l,
      c,
      u,
      f = !1
    if (
      ((a = r.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/)),
      a
        ? ((o = a[1]), (l = a[2]), (c = a[3]), (u = a[4]), l.length == 1 && (f = !0))
        : ((a = r.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/)),
          a && ((o = a[1]), (l = a[2]), (c = a[3]), (u = a[4]), l.length == 1 && (f = !0))),
      (i = E2(r)),
      (s = this._moves({ legal: !0, piece: o || i })),
      !c)
    )
      return null
    for (let d = 0, p = s.length; d < p; d++)
      if (l) {
        if (
          (!o || o.toLowerCase() == s[d].piece) &&
          Ye[l] == s[d].from &&
          Ye[c] == s[d].to &&
          (!u || u.toLowerCase() == s[d].promotion)
        )
          return s[d]
        if (f) {
          const h = mr(s[d].from)
          if (
            (!o || o.toLowerCase() == s[d].piece) &&
            Ye[c] == s[d].to &&
            (l == h[0] || l == h[1]) &&
            (!u || u.toLowerCase() == s[d].promotion)
          )
            return s[d]
        }
      } else if (r === Jg(this._moveToSan(s[d], s)).replace('x', '')) return s[d]
    return null
  }
  ascii() {
    let t = `   +------------------------+
`
    for (let n = Ye.a8; n <= Ye.h1; n++) {
      if ((gf(n) === 0 && (t += ' ' + '87654321'[Aa(n)] + ' |'), this._board[n])) {
        const r = this._board[n].type,
          s = this._board[n].color === Nn ? r.toUpperCase() : r.toLowerCase()
        t += ' ' + s + ' '
      } else t += ' . '
      ;(n + 1) & 136 &&
        ((t += `|
`),
        (n += 8))
    }
    return (
      (t += `   +------------------------+
`),
      (t += '     a  b  c  d  e  f  g  h'),
      t
    )
  }
  perft(t) {
    const n = this._moves({ legal: !1 })
    let r = 0
    const i = this._turn
    for (let s = 0, o = n.length; s < o; s++)
      this._makeMove(n[s]),
        this._isKingAttacked(i) || (t - 1 > 0 ? (r += this.perft(t - 1)) : r++),
        this._undoMove()
    return r
  }
  _makePretty(t) {
    const { color: n, piece: r, from: i, to: s, flags: o, captured: a, promotion: l } = t
    let c = ''
    for (const p in Ve) Ve[p] & o && (c += _I[p])
    const u = mr(i),
      f = mr(s),
      d = {
        color: n,
        piece: r,
        from: u,
        to: f,
        san: this._moveToSan(t, this._moves({ legal: !0 })),
        flags: c,
        lan: u + f,
        before: this.fen(),
        after: '',
      }
    return (
      this._makeMove(t),
      (d.after = this.fen()),
      this._undoMove(),
      a && (d.captured = a),
      l && ((d.promotion = l), (d.lan += l)),
      d
    )
  }
  turn() {
    return this._turn
  }
  board() {
    const t = []
    let n = []
    for (let r = Ye.a8; r <= Ye.h1; r++)
      this._board[r] == null
        ? n.push(null)
        : n.push({ square: mr(r), type: this._board[r].type, color: this._board[r].color }),
        (r + 1) & 136 && (t.push(n), (n = []), (r += 8))
    return t
  }
  squareColor(t) {
    if (t in Ye) {
      const n = Ye[t]
      return (Aa(n) + gf(n)) % 2 === 0 ? 'light' : 'dark'
    }
    return null
  }
  history({ verbose: t = !1 } = {}) {
    const n = [],
      r = []
    for (; this._history.length > 0; ) n.push(this._undoMove())
    for (;;) {
      const i = n.pop()
      if (!i) break
      t ? r.push(this._makePretty(i)) : r.push(this._moveToSan(i, this._moves())), this._makeMove(i)
    }
    return r
  }
  _getPositionCount(t) {
    const n = em(t)
    return this._positionCount[n] || 0
  }
  _incPositionCount(t) {
    const n = em(t)
    this._positionCount[n] === void 0 && (this._positionCount[n] = 0), (this._positionCount[n] += 1)
  }
  _decPositionCount(t) {
    const n = em(t)
    this._positionCount[n] === 1 ? delete this._positionCount[n] : (this._positionCount[n] -= 1)
  }
  _pruneComments() {
    const t = [],
      n = {},
      r = (i) => {
        i in this._comments && (n[i] = this._comments[i])
      }
    for (; this._history.length > 0; ) t.push(this._undoMove())
    for (r(this.fen()); ; ) {
      const i = t.pop()
      if (!i) break
      this._makeMove(i), r(this.fen())
    }
    this._comments = n
  }
  getComment() {
    return this._comments[this.fen()]
  }
  setComment(t) {
    this._comments[this.fen()] = t.replace('{', '[').replace('}', ']')
  }
  deleteComment() {
    const t = this._comments[this.fen()]
    return delete this._comments[this.fen()], t
  }
  getComments() {
    return (
      this._pruneComments(),
      Object.keys(this._comments).map((t) => ({ fen: t, comment: this._comments[t] }))
    )
  }
  deleteComments() {
    return (
      this._pruneComments(),
      Object.keys(this._comments).map((t) => {
        const n = this._comments[t]
        return delete this._comments[t], { fen: t, comment: n }
      })
    )
  }
  setCastlingRights(t, n) {
    for (const i of [cn, fo])
      n[i] !== void 0 && (n[i] ? (this._castling[t] |= Td[i]) : (this._castling[t] &= ~Td[i]))
    this._updateCastlingRights()
    const r = this.getCastlingRights(t)
    return (n[cn] === void 0 || n[cn] === r[cn]) && (n[fo] === void 0 || n[fo] === r[fo])
  }
  getCastlingRights(t) {
    return { [cn]: (this._castling[t] & Td[cn]) !== 0, [fo]: (this._castling[t] & Td[fo]) !== 0 }
  }
  moveNumber() {
    return this._moveNumber
  }
}
function $I(e, t) {
  var n = {}
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
        (n[r[i]] = e[r[i]])
  return n
}
const r_ = w.createContext({ dragDropManager: void 0 })
function $r(e) {
  return (
    'Minified Redux error #' +
    e +
    '; visit https://redux.js.org/Errors?code=' +
    e +
    ' for the full message or use the non-minified dev environment for full errors. '
  )
}
var C2 = (function () {
    return (typeof Symbol == 'function' && Symbol.observable) || '@@observable'
  })(),
  tm = function () {
    return Math.random().toString(36).substring(7).split('').join('.')
  },
  _2 = {
    INIT: '@@redux/INIT' + tm(),
    REPLACE: '@@redux/REPLACE' + tm(),
    PROBE_UNKNOWN_ACTION: function () {
      return '@@redux/PROBE_UNKNOWN_ACTION' + tm()
    },
  }
function FI(e) {
  if (typeof e != 'object' || e === null) return !1
  for (var t = e; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t)
  return Object.getPrototypeOf(e) === t
}
function i_(e, t, n) {
  var r
  if (
    (typeof t == 'function' && typeof n == 'function') ||
    (typeof n == 'function' && typeof arguments[3] == 'function')
  )
    throw new Error($r(0))
  if ((typeof t == 'function' && typeof n > 'u' && ((n = t), (t = void 0)), typeof n < 'u')) {
    if (typeof n != 'function') throw new Error($r(1))
    return n(i_)(e, t)
  }
  if (typeof e != 'function') throw new Error($r(2))
  var i = e,
    s = t,
    o = [],
    a = o,
    l = !1
  function c() {
    a === o && (a = o.slice())
  }
  function u() {
    if (l) throw new Error($r(3))
    return s
  }
  function f(m) {
    if (typeof m != 'function') throw new Error($r(4))
    if (l) throw new Error($r(5))
    var b = !0
    return (
      c(),
      a.push(m),
      function () {
        if (b) {
          if (l) throw new Error($r(6))
          ;(b = !1), c()
          var v = a.indexOf(m)
          a.splice(v, 1), (o = null)
        }
      }
    )
  }
  function d(m) {
    if (!FI(m)) throw new Error($r(7))
    if (typeof m.type > 'u') throw new Error($r(8))
    if (l) throw new Error($r(9))
    try {
      ;(l = !0), (s = i(s, m))
    } finally {
      l = !1
    }
    for (var b = (o = a), y = 0; y < b.length; y++) {
      var v = b[y]
      v()
    }
    return m
  }
  function p(m) {
    if (typeof m != 'function') throw new Error($r(10))
    ;(i = m), d({ type: _2.REPLACE })
  }
  function h() {
    var m,
      b = f
    return (
      (m = {
        subscribe: function (v) {
          if (typeof v != 'object' || v === null) throw new Error($r(11))
          function S() {
            v.next && v.next(u())
          }
          S()
          var T = b(S)
          return { unsubscribe: T }
        },
      }),
      (m[C2] = function () {
        return this
      }),
      m
    )
  }
  return (
    d({ type: _2.INIT }),
    (r = { dispatch: d, subscribe: f, getState: u, replaceReducer: p }),
    (r[C2] = h),
    r
  )
}
function qe(e, t, ...n) {
  if (BI() && t === void 0) throw new Error('invariant requires an error message argument')
  if (!e) {
    let r
    if (t === void 0)
      r = new Error(
        'Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.'
      )
    else {
      let i = 0
      ;(r = new Error(
        t.replace(/%s/g, function () {
          return n[i++]
        })
      )),
        (r.name = 'Invariant Violation')
    }
    throw ((r.framesToPop = 1), r)
  }
}
function BI() {
  return typeof process < 'u' && process.env.NODE_ENV === 'production'
}
function UI(e, t, n) {
  return t.split('.').reduce((r, i) => (r && r[i] ? r[i] : n || null), e)
}
function zI(e, t) {
  return e.filter((n) => n !== t)
}
function s_(e) {
  return typeof e == 'object'
}
function WI(e, t) {
  const n = new Map(),
    r = (s) => {
      n.set(s, n.has(s) ? n.get(s) + 1 : 1)
    }
  e.forEach(r), t.forEach(r)
  const i = []
  return (
    n.forEach((s, o) => {
      s === 1 && i.push(o)
    }),
    i
  )
}
function VI(e, t) {
  return e.filter((n) => t.indexOf(n) > -1)
}
const yw = 'dnd-core/INIT_COORDS',
  F0 = 'dnd-core/BEGIN_DRAG',
  vw = 'dnd-core/PUBLISH_DRAG_SOURCE',
  B0 = 'dnd-core/HOVER',
  U0 = 'dnd-core/DROP',
  z0 = 'dnd-core/END_DRAG'
function O2(e, t) {
  return { type: yw, payload: { sourceClientOffset: t || null, clientOffset: e || null } }
}
const HI = { type: yw, payload: { clientOffset: null, sourceClientOffset: null } }
function qI(e) {
  return function (n = [], r = { publishSource: !0 }) {
    const { publishSource: i = !0, clientOffset: s, getSourceClientOffset: o } = r,
      a = e.getMonitor(),
      l = e.getRegistry()
    e.dispatch(O2(s)), KI(n, a, l)
    const c = QI(n, a)
    if (c == null) {
      e.dispatch(HI)
      return
    }
    let u = null
    if (s) {
      if (!o) throw new Error('getSourceClientOffset must be defined')
      GI(o), (u = o(c))
    }
    e.dispatch(O2(s, u))
    const d = l.getSource(c).beginDrag(a, c)
    if (d == null) return
    YI(d), l.pinSource(c)
    const p = l.getSourceType(c)
    return {
      type: F0,
      payload: {
        itemType: p,
        item: d,
        sourceId: c,
        clientOffset: s || null,
        sourceClientOffset: u || null,
        isSourcePublic: !!i,
      },
    }
  }
}
function KI(e, t, n) {
  qe(!t.isDragging(), 'Cannot call beginDrag while dragging.'),
    e.forEach(function (r) {
      qe(n.getSource(r), 'Expected sourceIds to be registered.')
    })
}
function GI(e) {
  qe(
    typeof e == 'function',
    'When clientOffset is provided, getSourceClientOffset must be a function.'
  )
}
function YI(e) {
  qe(s_(e), 'Item must be an object.')
}
function QI(e, t) {
  let n = null
  for (let r = e.length - 1; r >= 0; r--)
    if (t.canDragSource(e[r])) {
      n = e[r]
      break
    }
  return n
}
function XI(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function ZI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {},
      r = Object.keys(n)
    typeof Object.getOwnPropertySymbols == 'function' &&
      (r = r.concat(
        Object.getOwnPropertySymbols(n).filter(function (i) {
          return Object.getOwnPropertyDescriptor(n, i).enumerable
        })
      )),
      r.forEach(function (i) {
        XI(e, i, n[i])
      })
  }
  return e
}
function JI(e) {
  return function (n = {}) {
    const r = e.getMonitor(),
      i = e.getRegistry()
    e8(r),
      r8(r).forEach((o, a) => {
        const l = t8(o, a, i, r),
          c = { type: U0, payload: { dropResult: ZI({}, n, l) } }
        e.dispatch(c)
      })
  }
}
function e8(e) {
  qe(e.isDragging(), 'Cannot call drop while not dragging.'),
    qe(!e.didDrop(), 'Cannot call drop twice during one drag operation.')
}
function t8(e, t, n, r) {
  const i = n.getTarget(e)
  let s = i ? i.drop(r, e) : void 0
  return n8(s), typeof s > 'u' && (s = t === 0 ? {} : r.getDropResult()), s
}
function n8(e) {
  qe(typeof e > 'u' || s_(e), 'Drop result must either be an object or undefined.')
}
function r8(e) {
  const t = e.getTargetIds().filter(e.canDropOnTarget, e)
  return t.reverse(), t
}
function i8(e) {
  return function () {
    const n = e.getMonitor(),
      r = e.getRegistry()
    s8(n)
    const i = n.getSourceId()
    return i != null && (r.getSource(i, !0).endDrag(n, i), r.unpinSource()), { type: z0 }
  }
}
function s8(e) {
  qe(e.isDragging(), 'Cannot call endDrag while not dragging.')
}
function Vy(e, t) {
  return t === null ? e === null : Array.isArray(e) ? e.some((n) => n === t) : e === t
}
function o8(e) {
  return function (n, { clientOffset: r } = {}) {
    a8(n)
    const i = n.slice(0),
      s = e.getMonitor(),
      o = e.getRegistry(),
      a = s.getItemType()
    return (
      c8(i, o, a),
      l8(i, s, o),
      u8(i, s, o),
      { type: B0, payload: { targetIds: i, clientOffset: r || null } }
    )
  }
}
function a8(e) {
  qe(Array.isArray(e), 'Expected targetIds to be an array.')
}
function l8(e, t, n) {
  qe(t.isDragging(), 'Cannot call hover while not dragging.'),
    qe(!t.didDrop(), 'Cannot call hover after drop.')
  for (let r = 0; r < e.length; r++) {
    const i = e[r]
    qe(e.lastIndexOf(i) === r, 'Expected targetIds to be unique in the passed array.')
    const s = n.getTarget(i)
    qe(s, 'Expected targetIds to be registered.')
  }
}
function c8(e, t, n) {
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r],
      s = t.getTargetType(i)
    Vy(s, n) || e.splice(r, 1)
  }
}
function u8(e, t, n) {
  e.forEach(function (r) {
    n.getTarget(r).hover(t, r)
  })
}
function f8(e) {
  return function () {
    if (e.getMonitor().isDragging()) return { type: vw }
  }
}
function d8(e) {
  return { beginDrag: qI(e), publishDragSource: f8(e), hover: o8(e), drop: JI(e), endDrag: i8(e) }
}
class h8 {
  receiveBackend(t) {
    this.backend = t
  }
  getMonitor() {
    return this.monitor
  }
  getBackend() {
    return this.backend
  }
  getRegistry() {
    return this.monitor.registry
  }
  getActions() {
    const t = this,
      { dispatch: n } = this.store
    function r(s) {
      return (...o) => {
        const a = s.apply(t, o)
        typeof a < 'u' && n(a)
      }
    }
    const i = d8(this)
    return Object.keys(i).reduce((s, o) => {
      const a = i[o]
      return (s[o] = r(a)), s
    }, {})
  }
  dispatch(t) {
    this.store.dispatch(t)
  }
  constructor(t, n) {
    ;(this.isSetUp = !1),
      (this.handleRefCountChange = () => {
        const r = this.store.getState().refCount > 0
        this.backend &&
          (r && !this.isSetUp
            ? (this.backend.setup(), (this.isSetUp = !0))
            : !r && this.isSetUp && (this.backend.teardown(), (this.isSetUp = !1)))
      }),
      (this.store = t),
      (this.monitor = n),
      t.subscribe(this.handleRefCountChange)
  }
}
function p8(e, t) {
  return { x: e.x + t.x, y: e.y + t.y }
}
function o_(e, t) {
  return { x: e.x - t.x, y: e.y - t.y }
}
function g8(e) {
  const { clientOffset: t, initialClientOffset: n, initialSourceClientOffset: r } = e
  return !t || !n || !r ? null : o_(p8(t, r), n)
}
function m8(e) {
  const { clientOffset: t, initialClientOffset: n } = e
  return !t || !n ? null : o_(t, n)
}
const zu = [],
  ww = []
zu.__IS_NONE__ = !0
ww.__IS_ALL__ = !0
function y8(e, t) {
  return e === zu ? !1 : e === ww || typeof t > 'u' ? !0 : VI(t, e).length > 0
}
class v8 {
  subscribeToStateChange(t, n = {}) {
    const { handlerIds: r } = n
    qe(typeof t == 'function', 'listener must be a function.'),
      qe(
        typeof r > 'u' || Array.isArray(r),
        'handlerIds, when specified, must be an array of strings.'
      )
    let i = this.store.getState().stateId
    const s = () => {
      const o = this.store.getState(),
        a = o.stateId
      try {
        a === i || (a === i + 1 && !y8(o.dirtyHandlerIds, r)) || t()
      } finally {
        i = a
      }
    }
    return this.store.subscribe(s)
  }
  subscribeToOffsetChange(t) {
    qe(typeof t == 'function', 'listener must be a function.')
    let n = this.store.getState().dragOffset
    const r = () => {
      const i = this.store.getState().dragOffset
      i !== n && ((n = i), t())
    }
    return this.store.subscribe(r)
  }
  canDragSource(t) {
    if (!t) return !1
    const n = this.registry.getSource(t)
    return (
      qe(n, `Expected to find a valid source. sourceId=${t}`),
      this.isDragging() ? !1 : n.canDrag(this, t)
    )
  }
  canDropOnTarget(t) {
    if (!t) return !1
    const n = this.registry.getTarget(t)
    if (
      (qe(n, `Expected to find a valid target. targetId=${t}`),
      !this.isDragging() || this.didDrop())
    )
      return !1
    const r = this.registry.getTargetType(t),
      i = this.getItemType()
    return Vy(r, i) && n.canDrop(this, t)
  }
  isDragging() {
    return !!this.getItemType()
  }
  isDraggingSource(t) {
    if (!t) return !1
    const n = this.registry.getSource(t, !0)
    if (
      (qe(n, `Expected to find a valid source. sourceId=${t}`),
      !this.isDragging() || !this.isSourcePublic())
    )
      return !1
    const r = this.registry.getSourceType(t),
      i = this.getItemType()
    return r !== i ? !1 : n.isDragging(this, t)
  }
  isOverTarget(t, n = { shallow: !1 }) {
    if (!t) return !1
    const { shallow: r } = n
    if (!this.isDragging()) return !1
    const i = this.registry.getTargetType(t),
      s = this.getItemType()
    if (s && !Vy(i, s)) return !1
    const o = this.getTargetIds()
    if (!o.length) return !1
    const a = o.indexOf(t)
    return r ? a === o.length - 1 : a > -1
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType
  }
  getItem() {
    return this.store.getState().dragOperation.item
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop
  }
  isSourcePublic() {
    return !!this.store.getState().dragOperation.isSourcePublic
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset
  }
  getSourceClientOffset() {
    return g8(this.store.getState().dragOffset)
  }
  getDifferenceFromInitialOffset() {
    return m8(this.store.getState().dragOffset)
  }
  constructor(t, n) {
    ;(this.store = t), (this.registry = n)
  }
}
const k2 = typeof global < 'u' ? global : self,
  a_ = k2.MutationObserver || k2.WebKitMutationObserver
function l_(e) {
  return function () {
    const n = setTimeout(i, 0),
      r = setInterval(i, 50)
    function i() {
      clearTimeout(n), clearInterval(r), e()
    }
  }
}
function w8(e) {
  let t = 1
  const n = new a_(e),
    r = document.createTextNode('')
  return (
    n.observe(r, { characterData: !0 }),
    function () {
      ;(t = -t), (r.data = t)
    }
  )
}
const b8 = typeof a_ == 'function' ? w8 : l_
class x8 {
  enqueueTask(t) {
    const { queue: n, requestFlush: r } = this
    n.length || (r(), (this.flushing = !0)), (n[n.length] = t)
  }
  constructor() {
    ;(this.queue = []),
      (this.pendingErrors = []),
      (this.flushing = !1),
      (this.index = 0),
      (this.capacity = 1024),
      (this.flush = () => {
        const { queue: t } = this
        for (; this.index < t.length; ) {
          const n = this.index
          if ((this.index++, t[n].call(), this.index > this.capacity)) {
            for (let r = 0, i = t.length - this.index; r < i; r++) t[r] = t[r + this.index]
            ;(t.length -= this.index), (this.index = 0)
          }
        }
        ;(t.length = 0), (this.index = 0), (this.flushing = !1)
      }),
      (this.registerPendingError = (t) => {
        this.pendingErrors.push(t), this.requestErrorThrow()
      }),
      (this.requestFlush = b8(this.flush)),
      (this.requestErrorThrow = l_(() => {
        if (this.pendingErrors.length) throw this.pendingErrors.shift()
      }))
  }
}
class S8 {
  call() {
    try {
      this.task && this.task()
    } catch (t) {
      this.onError(t)
    } finally {
      ;(this.task = null), this.release(this)
    }
  }
  constructor(t, n) {
    ;(this.onError = t), (this.release = n), (this.task = null)
  }
}
class E8 {
  create(t) {
    const n = this.freeTasks,
      r = n.length ? n.pop() : new S8(this.onError, (i) => (n[n.length] = i))
    return (r.task = t), r
  }
  constructor(t) {
    ;(this.onError = t), (this.freeTasks = [])
  }
}
const c_ = new x8(),
  C8 = new E8(c_.registerPendingError)
function _8(e) {
  c_.enqueueTask(C8.create(e))
}
const bw = 'dnd-core/ADD_SOURCE',
  xw = 'dnd-core/ADD_TARGET',
  Sw = 'dnd-core/REMOVE_SOURCE',
  W0 = 'dnd-core/REMOVE_TARGET'
function O8(e) {
  return { type: bw, payload: { sourceId: e } }
}
function k8(e) {
  return { type: xw, payload: { targetId: e } }
}
function T8(e) {
  return { type: Sw, payload: { sourceId: e } }
}
function A8(e) {
  return { type: W0, payload: { targetId: e } }
}
function R8(e) {
  qe(typeof e.canDrag == 'function', 'Expected canDrag to be a function.'),
    qe(typeof e.beginDrag == 'function', 'Expected beginDrag to be a function.'),
    qe(typeof e.endDrag == 'function', 'Expected endDrag to be a function.')
}
function P8(e) {
  qe(typeof e.canDrop == 'function', 'Expected canDrop to be a function.'),
    qe(typeof e.hover == 'function', 'Expected hover to be a function.'),
    qe(typeof e.drop == 'function', 'Expected beginDrag to be a function.')
}
function Hy(e, t) {
  if (t && Array.isArray(e)) {
    e.forEach((n) => Hy(n, !1))
    return
  }
  qe(
    typeof e == 'string' || typeof e == 'symbol',
    t
      ? 'Type can only be a string, a symbol, or an array of either.'
      : 'Type can only be a string or a symbol.'
  )
}
var Kr
;(function (e) {
  ;(e.SOURCE = 'SOURCE'), (e.TARGET = 'TARGET')
})(Kr || (Kr = {}))
let I8 = 0
function D8() {
  return I8++
}
function N8(e) {
  const t = D8().toString()
  switch (e) {
    case Kr.SOURCE:
      return `S${t}`
    case Kr.TARGET:
      return `T${t}`
    default:
      throw new Error(`Unknown Handler Role: ${e}`)
  }
}
function T2(e) {
  switch (e[0]) {
    case 'S':
      return Kr.SOURCE
    case 'T':
      return Kr.TARGET
    default:
      throw new Error(`Cannot parse handler ID: ${e}`)
  }
}
function A2(e, t) {
  const n = e.entries()
  let r = !1
  do {
    const {
      done: i,
      value: [, s],
    } = n.next()
    if (s === t) return !0
    r = !!i
  } while (!r)
  return !1
}
class M8 {
  addSource(t, n) {
    Hy(t), R8(n)
    const r = this.addHandler(Kr.SOURCE, t, n)
    return this.store.dispatch(O8(r)), r
  }
  addTarget(t, n) {
    Hy(t, !0), P8(n)
    const r = this.addHandler(Kr.TARGET, t, n)
    return this.store.dispatch(k8(r)), r
  }
  containsHandler(t) {
    return A2(this.dragSources, t) || A2(this.dropTargets, t)
  }
  getSource(t, n = !1) {
    return (
      qe(this.isSourceId(t), 'Expected a valid source ID.'),
      n && t === this.pinnedSourceId ? this.pinnedSource : this.dragSources.get(t)
    )
  }
  getTarget(t) {
    return qe(this.isTargetId(t), 'Expected a valid target ID.'), this.dropTargets.get(t)
  }
  getSourceType(t) {
    return qe(this.isSourceId(t), 'Expected a valid source ID.'), this.types.get(t)
  }
  getTargetType(t) {
    return qe(this.isTargetId(t), 'Expected a valid target ID.'), this.types.get(t)
  }
  isSourceId(t) {
    return T2(t) === Kr.SOURCE
  }
  isTargetId(t) {
    return T2(t) === Kr.TARGET
  }
  removeSource(t) {
    qe(this.getSource(t), 'Expected an existing source.'),
      this.store.dispatch(T8(t)),
      _8(() => {
        this.dragSources.delete(t), this.types.delete(t)
      })
  }
  removeTarget(t) {
    qe(this.getTarget(t), 'Expected an existing target.'),
      this.store.dispatch(A8(t)),
      this.dropTargets.delete(t),
      this.types.delete(t)
  }
  pinSource(t) {
    const n = this.getSource(t)
    qe(n, 'Expected an existing source.'), (this.pinnedSourceId = t), (this.pinnedSource = n)
  }
  unpinSource() {
    qe(this.pinnedSource, 'No source is pinned at the time.'),
      (this.pinnedSourceId = null),
      (this.pinnedSource = null)
  }
  addHandler(t, n, r) {
    const i = N8(t)
    return (
      this.types.set(i, n),
      t === Kr.SOURCE ? this.dragSources.set(i, r) : t === Kr.TARGET && this.dropTargets.set(i, r),
      i
    )
  }
  constructor(t) {
    ;(this.types = new Map()),
      (this.dragSources = new Map()),
      (this.dropTargets = new Map()),
      (this.pinnedSourceId = null),
      (this.pinnedSource = null),
      (this.store = t)
  }
}
const j8 = (e, t) => e === t
function L8(e, t) {
  return !e && !t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y
}
function $8(e, t, n = j8) {
  if (e.length !== t.length) return !1
  for (let r = 0; r < e.length; ++r) if (!n(e[r], t[r])) return !1
  return !0
}
function F8(e = zu, t) {
  switch (t.type) {
    case B0:
      break
    case bw:
    case xw:
    case W0:
    case Sw:
      return zu
    case F0:
    case vw:
    case z0:
    case U0:
    default:
      return ww
  }
  const { targetIds: n = [], prevTargetIds: r = [] } = t.payload,
    i = WI(n, r)
  if (!(i.length > 0 || !$8(n, r))) return zu
  const o = r[r.length - 1],
    a = n[n.length - 1]
  return o !== a && (o && i.push(o), a && i.push(a)), i
}
function B8(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function U8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {},
      r = Object.keys(n)
    typeof Object.getOwnPropertySymbols == 'function' &&
      (r = r.concat(
        Object.getOwnPropertySymbols(n).filter(function (i) {
          return Object.getOwnPropertyDescriptor(n, i).enumerable
        })
      )),
      r.forEach(function (i) {
        B8(e, i, n[i])
      })
  }
  return e
}
const R2 = { initialSourceClientOffset: null, initialClientOffset: null, clientOffset: null }
function z8(e = R2, t) {
  const { payload: n } = t
  switch (t.type) {
    case yw:
    case F0:
      return {
        initialSourceClientOffset: n.sourceClientOffset,
        initialClientOffset: n.clientOffset,
        clientOffset: n.clientOffset,
      }
    case B0:
      return L8(e.clientOffset, n.clientOffset) ? e : U8({}, e, { clientOffset: n.clientOffset })
    case z0:
    case U0:
      return R2
    default:
      return e
  }
}
function W8(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function el(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {},
      r = Object.keys(n)
    typeof Object.getOwnPropertySymbols == 'function' &&
      (r = r.concat(
        Object.getOwnPropertySymbols(n).filter(function (i) {
          return Object.getOwnPropertyDescriptor(n, i).enumerable
        })
      )),
      r.forEach(function (i) {
        W8(e, i, n[i])
      })
  }
  return e
}
const V8 = {
  itemType: null,
  item: null,
  sourceId: null,
  targetIds: [],
  dropResult: null,
  didDrop: !1,
  isSourcePublic: null,
}
function H8(e = V8, t) {
  const { payload: n } = t
  switch (t.type) {
    case F0:
      return el({}, e, {
        itemType: n.itemType,
        item: n.item,
        sourceId: n.sourceId,
        isSourcePublic: n.isSourcePublic,
        dropResult: null,
        didDrop: !1,
      })
    case vw:
      return el({}, e, { isSourcePublic: !0 })
    case B0:
      return el({}, e, { targetIds: n.targetIds })
    case W0:
      return e.targetIds.indexOf(n.targetId) === -1
        ? e
        : el({}, e, { targetIds: zI(e.targetIds, n.targetId) })
    case U0:
      return el({}, e, { dropResult: n.dropResult, didDrop: !0, targetIds: [] })
    case z0:
      return el({}, e, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: !1,
        isSourcePublic: null,
        targetIds: [],
      })
    default:
      return e
  }
}
function q8(e = 0, t) {
  switch (t.type) {
    case bw:
    case xw:
      return e + 1
    case Sw:
    case W0:
      return e - 1
    default:
      return e
  }
}
function K8(e = 0) {
  return e + 1
}
function G8(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function Y8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {},
      r = Object.keys(n)
    typeof Object.getOwnPropertySymbols == 'function' &&
      (r = r.concat(
        Object.getOwnPropertySymbols(n).filter(function (i) {
          return Object.getOwnPropertyDescriptor(n, i).enumerable
        })
      )),
      r.forEach(function (i) {
        G8(e, i, n[i])
      })
  }
  return e
}
function Q8(e = {}, t) {
  return {
    dirtyHandlerIds: F8(e.dirtyHandlerIds, {
      type: t.type,
      payload: Y8({}, t.payload, { prevTargetIds: UI(e, 'dragOperation.targetIds', []) }),
    }),
    dragOffset: z8(e.dragOffset, t),
    refCount: q8(e.refCount, t),
    dragOperation: H8(e.dragOperation, t),
    stateId: K8(e.stateId),
  }
}
function X8(e, t = void 0, n = {}, r = !1) {
  const i = Z8(r),
    s = new v8(i, new M8(i)),
    o = new h8(i, s),
    a = e(o, t, n)
  return o.receiveBackend(a), o
}
function Z8(e) {
  const t = typeof window < 'u' && window.__REDUX_DEVTOOLS_EXTENSION__
  return i_(Q8, e && t && t({ name: 'dnd-core', instanceId: 'dnd-core' }))
}
function J8(e, t) {
  if (e == null) return {}
  var n = eD(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
  }
  return n
}
function eD(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    s
  for (s = 0; s < r.length; s++) (i = r[s]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
let P2 = 0
const vh = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__')
var tD = w.memo(function (t) {
  var { children: n } = t,
    r = J8(t, ['children'])
  const [i, s] = nD(r)
  return (
    w.useEffect(() => {
      if (s) {
        const o = u_()
        return (
          ++P2,
          () => {
            --P2 === 0 && (o[vh] = null)
          }
        )
      }
    }, []),
    E.jsx(r_.Provider, { value: i, children: n })
  )
})
function nD(e) {
  if ('manager' in e) return [{ dragDropManager: e.manager }, !1]
  const t = rD(e.backend, e.context, e.options, e.debugMode),
    n = !e.context
  return [t, n]
}
function rD(e, t = u_(), n, r) {
  const i = t
  return i[vh] || (i[vh] = { dragDropManager: X8(e, t, n, r) }), i[vh]
}
function u_() {
  return typeof global < 'u' ? global : window
}
var iD = function e(t, n) {
  if (t === n) return !0
  if (t && n && typeof t == 'object' && typeof n == 'object') {
    if (t.constructor !== n.constructor) return !1
    var r, i, s
    if (Array.isArray(t)) {
      if (((r = t.length), r != n.length)) return !1
      for (i = r; i-- !== 0; ) if (!e(t[i], n[i])) return !1
      return !0
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf()
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString()
    if (((s = Object.keys(t)), (r = s.length), r !== Object.keys(n).length)) return !1
    for (i = r; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, s[i])) return !1
    for (i = r; i-- !== 0; ) {
      var o = s[i]
      if (!e(t[o], n[o])) return !1
    }
    return !0
  }
  return t !== t && n !== n
}
const Fa = typeof window < 'u' ? w.useLayoutEffect : w.useEffect
function f_(e, t, n) {
  const [r, i] = w.useState(() => t(e)),
    s = w.useCallback(() => {
      const o = t(e)
      iD(r, o) || (i(o), n && n())
    }, [r, e, n])
  return Fa(s), [r, s]
}
function sD(e, t, n) {
  const [r, i] = f_(e, t, n)
  return (
    Fa(
      function () {
        const o = e.getHandlerId()
        if (o != null) return e.subscribeToStateChange(i, { handlerIds: [o] })
      },
      [e, i]
    ),
    r
  )
}
function d_(e, t, n) {
  return sD(t, e || (() => ({})), () => n.reconnect())
}
function h_(e, t) {
  const n = [...(t || [])]
  return (
    t == null && typeof e != 'function' && n.push(e),
    w.useMemo(() => (typeof e == 'function' ? e() : e), n)
  )
}
function oD(e) {
  return w.useMemo(() => e.hooks.dragSource(), [e])
}
function aD(e) {
  return w.useMemo(() => e.hooks.dragPreview(), [e])
}
let nm = !1,
  rm = !1
class lD {
  receiveHandlerId(t) {
    this.sourceId = t
  }
  getHandlerId() {
    return this.sourceId
  }
  canDrag() {
    qe(
      !nm,
      'You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor'
    )
    try {
      return (nm = !0), this.internalMonitor.canDragSource(this.sourceId)
    } finally {
      nm = !1
    }
  }
  isDragging() {
    if (!this.sourceId) return !1
    qe(
      !rm,
      'You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor'
    )
    try {
      return (rm = !0), this.internalMonitor.isDraggingSource(this.sourceId)
    } finally {
      rm = !1
    }
  }
  subscribeToStateChange(t, n) {
    return this.internalMonitor.subscribeToStateChange(t, n)
  }
  isDraggingSource(t) {
    return this.internalMonitor.isDraggingSource(t)
  }
  isOverTarget(t, n) {
    return this.internalMonitor.isOverTarget(t, n)
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds()
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic()
  }
  getSourceId() {
    return this.internalMonitor.getSourceId()
  }
  subscribeToOffsetChange(t) {
    return this.internalMonitor.subscribeToOffsetChange(t)
  }
  canDragSource(t) {
    return this.internalMonitor.canDragSource(t)
  }
  canDropOnTarget(t) {
    return this.internalMonitor.canDropOnTarget(t)
  }
  getItemType() {
    return this.internalMonitor.getItemType()
  }
  getItem() {
    return this.internalMonitor.getItem()
  }
  getDropResult() {
    return this.internalMonitor.getDropResult()
  }
  didDrop() {
    return this.internalMonitor.didDrop()
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset()
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset()
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset()
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset()
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset()
  }
  constructor(t) {
    ;(this.sourceId = null), (this.internalMonitor = t.getMonitor())
  }
}
let im = !1
class cD {
  receiveHandlerId(t) {
    this.targetId = t
  }
  getHandlerId() {
    return this.targetId
  }
  subscribeToStateChange(t, n) {
    return this.internalMonitor.subscribeToStateChange(t, n)
  }
  canDrop() {
    if (!this.targetId) return !1
    qe(
      !im,
      'You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor'
    )
    try {
      return (im = !0), this.internalMonitor.canDropOnTarget(this.targetId)
    } finally {
      im = !1
    }
  }
  isOver(t) {
    return this.targetId ? this.internalMonitor.isOverTarget(this.targetId, t) : !1
  }
  getItemType() {
    return this.internalMonitor.getItemType()
  }
  getItem() {
    return this.internalMonitor.getItem()
  }
  getDropResult() {
    return this.internalMonitor.getDropResult()
  }
  didDrop() {
    return this.internalMonitor.didDrop()
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset()
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset()
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset()
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset()
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset()
  }
  constructor(t) {
    ;(this.targetId = null), (this.internalMonitor = t.getMonitor())
  }
}
function uD(e, t, n) {
  const r = n.getRegistry(),
    i = r.addTarget(e, t)
  return [i, () => r.removeTarget(i)]
}
function fD(e, t, n) {
  const r = n.getRegistry(),
    i = r.addSource(e, t)
  return [i, () => r.removeSource(i)]
}
function qy(e, t, n, r) {
  let i = n ? n.call(r, e, t) : void 0
  if (i !== void 0) return !!i
  if (e === t) return !0
  if (typeof e != 'object' || !e || typeof t != 'object' || !t) return !1
  const s = Object.keys(e),
    o = Object.keys(t)
  if (s.length !== o.length) return !1
  const a = Object.prototype.hasOwnProperty.bind(t)
  for (let l = 0; l < s.length; l++) {
    const c = s[l]
    if (!a(c)) return !1
    const u = e[c],
      f = t[c]
    if (((i = n ? n.call(r, u, f, c) : void 0), i === !1 || (i === void 0 && u !== f))) return !1
  }
  return !0
}
function Ky(e) {
  return e !== null && typeof e == 'object' && Object.prototype.hasOwnProperty.call(e, 'current')
}
function dD(e) {
  if (typeof e.type == 'string') return
  const t = e.type.displayName || e.type.name || 'the component'
  throw new Error(
    `Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t} into a <div>, or turn it into a drag source or a drop target itself.`
  )
}
function hD(e) {
  return (t = null, n = null) => {
    if (!w.isValidElement(t)) {
      const s = t
      return e(s, n), s
    }
    const r = t
    return dD(r), pD(r, n ? (s) => e(s, n) : e)
  }
}
function p_(e) {
  const t = {}
  return (
    Object.keys(e).forEach((n) => {
      const r = e[n]
      if (n.endsWith('Ref')) t[n] = e[n]
      else {
        const i = hD(r)
        t[n] = () => i
      }
    }),
    t
  )
}
function I2(e, t) {
  typeof e == 'function' ? e(t) : (e.current = t)
}
function pD(e, t) {
  const n = e.ref
  return (
    qe(
      typeof n != 'string',
      'Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs'
    ),
    n
      ? w.cloneElement(e, {
          ref: (r) => {
            I2(n, r), I2(t, r)
          },
        })
      : w.cloneElement(e, { ref: t })
  )
}
class gD {
  receiveHandlerId(t) {
    this.handlerId !== t && ((this.handlerId = t), this.reconnect())
  }
  get connectTarget() {
    return this.dragSource
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal
  }
  set dragSourceOptions(t) {
    this.dragSourceOptionsInternal = t
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal
  }
  set dragPreviewOptions(t) {
    this.dragPreviewOptionsInternal = t
  }
  reconnect() {
    const t = this.reconnectDragSource()
    this.reconnectDragPreview(t)
  }
  reconnectDragSource() {
    const t = this.dragSource,
      n =
        this.didHandlerIdChange() ||
        this.didConnectedDragSourceChange() ||
        this.didDragSourceOptionsChange()
    return (
      n && this.disconnectDragSource(),
      this.handlerId
        ? t
          ? (n &&
              ((this.lastConnectedHandlerId = this.handlerId),
              (this.lastConnectedDragSource = t),
              (this.lastConnectedDragSourceOptions = this.dragSourceOptions),
              (this.dragSourceUnsubscribe = this.backend.connectDragSource(
                this.handlerId,
                t,
                this.dragSourceOptions
              ))),
            n)
          : ((this.lastConnectedDragSource = t), n)
        : n
    )
  }
  reconnectDragPreview(t = !1) {
    const n = this.dragPreview,
      r =
        t ||
        this.didHandlerIdChange() ||
        this.didConnectedDragPreviewChange() ||
        this.didDragPreviewOptionsChange()
    if ((r && this.disconnectDragPreview(), !!this.handlerId)) {
      if (!n) {
        this.lastConnectedDragPreview = n
        return
      }
      r &&
        ((this.lastConnectedHandlerId = this.handlerId),
        (this.lastConnectedDragPreview = n),
        (this.lastConnectedDragPreviewOptions = this.dragPreviewOptions),
        (this.dragPreviewUnsubscribe = this.backend.connectDragPreview(
          this.handlerId,
          n,
          this.dragPreviewOptions
        )))
    }
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview
  }
  didDragSourceOptionsChange() {
    return !qy(this.lastConnectedDragSourceOptions, this.dragSourceOptions)
  }
  didDragPreviewOptionsChange() {
    return !qy(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions)
  }
  disconnectDragSource() {
    this.dragSourceUnsubscribe &&
      (this.dragSourceUnsubscribe(), (this.dragSourceUnsubscribe = void 0))
  }
  disconnectDragPreview() {
    this.dragPreviewUnsubscribe &&
      (this.dragPreviewUnsubscribe(),
      (this.dragPreviewUnsubscribe = void 0),
      (this.dragPreviewNode = null),
      (this.dragPreviewRef = null))
  }
  get dragSource() {
    return this.dragSourceNode || (this.dragSourceRef && this.dragSourceRef.current)
  }
  get dragPreview() {
    return this.dragPreviewNode || (this.dragPreviewRef && this.dragPreviewRef.current)
  }
  clearDragSource() {
    ;(this.dragSourceNode = null), (this.dragSourceRef = null)
  }
  clearDragPreview() {
    ;(this.dragPreviewNode = null), (this.dragPreviewRef = null)
  }
  constructor(t) {
    ;(this.hooks = p_({
      dragSource: (n, r) => {
        this.clearDragSource(),
          (this.dragSourceOptions = r || null),
          Ky(n) ? (this.dragSourceRef = n) : (this.dragSourceNode = n),
          this.reconnectDragSource()
      },
      dragPreview: (n, r) => {
        this.clearDragPreview(),
          (this.dragPreviewOptions = r || null),
          Ky(n) ? (this.dragPreviewRef = n) : (this.dragPreviewNode = n),
          this.reconnectDragPreview()
      },
    })),
      (this.handlerId = null),
      (this.dragSourceRef = null),
      (this.dragSourceOptionsInternal = null),
      (this.dragPreviewRef = null),
      (this.dragPreviewOptionsInternal = null),
      (this.lastConnectedHandlerId = null),
      (this.lastConnectedDragSource = null),
      (this.lastConnectedDragSourceOptions = null),
      (this.lastConnectedDragPreview = null),
      (this.lastConnectedDragPreviewOptions = null),
      (this.backend = t)
  }
}
class mD {
  get connectTarget() {
    return this.dropTarget
  }
  reconnect() {
    const t = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange()
    t && this.disconnectDropTarget()
    const n = this.dropTarget
    if (this.handlerId) {
      if (!n) {
        this.lastConnectedDropTarget = n
        return
      }
      t &&
        ((this.lastConnectedHandlerId = this.handlerId),
        (this.lastConnectedDropTarget = n),
        (this.lastConnectedDropTargetOptions = this.dropTargetOptions),
        (this.unsubscribeDropTarget = this.backend.connectDropTarget(
          this.handlerId,
          n,
          this.dropTargetOptions
        )))
    }
  }
  receiveHandlerId(t) {
    t !== this.handlerId && ((this.handlerId = t), this.reconnect())
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal
  }
  set dropTargetOptions(t) {
    this.dropTargetOptionsInternal = t
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget
  }
  didOptionsChange() {
    return !qy(this.lastConnectedDropTargetOptions, this.dropTargetOptions)
  }
  disconnectDropTarget() {
    this.unsubscribeDropTarget &&
      (this.unsubscribeDropTarget(), (this.unsubscribeDropTarget = void 0))
  }
  get dropTarget() {
    return this.dropTargetNode || (this.dropTargetRef && this.dropTargetRef.current)
  }
  clearDropTarget() {
    ;(this.dropTargetRef = null), (this.dropTargetNode = null)
  }
  constructor(t) {
    ;(this.hooks = p_({
      dropTarget: (n, r) => {
        this.clearDropTarget(),
          (this.dropTargetOptions = r),
          Ky(n) ? (this.dropTargetRef = n) : (this.dropTargetNode = n),
          this.reconnect()
      },
    })),
      (this.handlerId = null),
      (this.dropTargetRef = null),
      (this.dropTargetOptionsInternal = null),
      (this.lastConnectedHandlerId = null),
      (this.lastConnectedDropTarget = null),
      (this.lastConnectedDropTargetOptions = null),
      (this.backend = t)
  }
}
function Ga() {
  const { dragDropManager: e } = w.useContext(r_)
  return qe(e != null, 'Expected drag drop context'), e
}
function yD(e, t) {
  const n = Ga(),
    r = w.useMemo(() => new gD(n.getBackend()), [n])
  return (
    Fa(
      () => ((r.dragSourceOptions = e || null), r.reconnect(), () => r.disconnectDragSource()),
      [r, e]
    ),
    Fa(
      () => ((r.dragPreviewOptions = t || null), r.reconnect(), () => r.disconnectDragPreview()),
      [r, t]
    ),
    r
  )
}
function vD() {
  const e = Ga()
  return w.useMemo(() => new lD(e), [e])
}
class wD {
  beginDrag() {
    const t = this.spec,
      n = this.monitor
    let r = null
    return (
      typeof t.item == 'object'
        ? (r = t.item)
        : typeof t.item == 'function'
        ? (r = t.item(n))
        : (r = {}),
      r ?? null
    )
  }
  canDrag() {
    const t = this.spec,
      n = this.monitor
    return typeof t.canDrag == 'boolean'
      ? t.canDrag
      : typeof t.canDrag == 'function'
      ? t.canDrag(n)
      : !0
  }
  isDragging(t, n) {
    const r = this.spec,
      i = this.monitor,
      { isDragging: s } = r
    return s ? s(i) : n === t.getSourceId()
  }
  endDrag() {
    const t = this.spec,
      n = this.monitor,
      r = this.connector,
      { end: i } = t
    i && i(n.getItem(), n), r.reconnect()
  }
  constructor(t, n, r) {
    ;(this.spec = t), (this.monitor = n), (this.connector = r)
  }
}
function bD(e, t, n) {
  const r = w.useMemo(() => new wD(e, t, n), [t, n])
  return (
    w.useEffect(() => {
      r.spec = e
    }, [e]),
    r
  )
}
function xD(e) {
  return w.useMemo(() => {
    const t = e.type
    return qe(t != null, 'spec.type must be defined'), t
  }, [e])
}
function SD(e, t, n) {
  const r = Ga(),
    i = bD(e, t, n),
    s = xD(e)
  Fa(
    function () {
      if (s != null) {
        const [a, l] = fD(s, i, r)
        return t.receiveHandlerId(a), n.receiveHandlerId(a), l
      }
    },
    [r, t, n, i, s]
  )
}
function ED(e, t) {
  const n = h_(e, t)
  qe(
    !n.begin,
    'useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)'
  )
  const r = vD(),
    i = yD(n.options, n.previewOptions)
  return SD(n, r, i), [d_(n.collect, r, i), oD(i), aD(i)]
}
function CD(e) {
  const n = Ga().getMonitor(),
    [r, i] = f_(n, e)
  return (
    w.useEffect(() => n.subscribeToOffsetChange(i)),
    w.useEffect(() => n.subscribeToStateChange(i)),
    r
  )
}
function _D(e) {
  return w.useMemo(() => e.hooks.dropTarget(), [e])
}
function OD(e) {
  const t = Ga(),
    n = w.useMemo(() => new mD(t.getBackend()), [t])
  return (
    Fa(
      () => ((n.dropTargetOptions = e || null), n.reconnect(), () => n.disconnectDropTarget()),
      [e]
    ),
    n
  )
}
function kD() {
  const e = Ga()
  return w.useMemo(() => new cD(e), [e])
}
function TD(e) {
  const { accept: t } = e
  return w.useMemo(
    () => (qe(e.accept != null, 'accept must be defined'), Array.isArray(t) ? t : [t]),
    [t]
  )
}
class AD {
  canDrop() {
    const t = this.spec,
      n = this.monitor
    return t.canDrop ? t.canDrop(n.getItem(), n) : !0
  }
  hover() {
    const t = this.spec,
      n = this.monitor
    t.hover && t.hover(n.getItem(), n)
  }
  drop() {
    const t = this.spec,
      n = this.monitor
    if (t.drop) return t.drop(n.getItem(), n)
  }
  constructor(t, n) {
    ;(this.spec = t), (this.monitor = n)
  }
}
function RD(e, t) {
  const n = w.useMemo(() => new AD(e, t), [t])
  return (
    w.useEffect(() => {
      n.spec = e
    }, [e]),
    n
  )
}
function PD(e, t, n) {
  const r = Ga(),
    i = RD(e, t),
    s = TD(e)
  Fa(
    function () {
      const [a, l] = uD(s, i, r)
      return t.receiveHandlerId(a), n.receiveHandlerId(a), l
    },
    [r, t, i, n, s.map((o) => o.toString()).join('|')]
  )
}
function ID(e, t) {
  const n = h_(e, t),
    r = kD(),
    i = OD(n.options)
  return PD(n, r, i), [d_(n.collect, r, i), _D(i)]
}
function g_(e) {
  let t = null
  return () => (t == null && (t = e()), t)
}
function DD(e, t) {
  return e.filter((n) => n !== t)
}
function ND(e, t) {
  const n = new Set(),
    r = (s) => n.add(s)
  e.forEach(r), t.forEach(r)
  const i = []
  return n.forEach((s) => i.push(s)), i
}
class MD {
  enter(t) {
    const n = this.entered.length,
      r = (i) => this.isNodeInDocument(i) && (!i.contains || i.contains(t))
    return (this.entered = ND(this.entered.filter(r), [t])), n === 0 && this.entered.length > 0
  }
  leave(t) {
    const n = this.entered.length
    return (
      (this.entered = DD(this.entered.filter(this.isNodeInDocument), t)),
      n > 0 && this.entered.length === 0
    )
  }
  reset() {
    this.entered = []
  }
  constructor(t) {
    ;(this.entered = []), (this.isNodeInDocument = t)
  }
}
class jD {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((t) => {
      Object.defineProperty(this.item, t, {
        configurable: !0,
        enumerable: !0,
        get() {
          return console.warn(`Browser doesn't allow reading "${t}" until the drop event.`), null
        },
      })
    })
  }
  loadDataTransfer(t) {
    if (t) {
      const n = {}
      Object.keys(this.config.exposeProperties).forEach((r) => {
        const i = this.config.exposeProperties[r]
        i != null &&
          (n[r] = { value: i(t, this.config.matchesTypes), configurable: !0, enumerable: !0 })
      }),
        Object.defineProperties(this.item, n)
    }
  }
  canDrag() {
    return !0
  }
  beginDrag() {
    return this.item
  }
  isDragging(t, n) {
    return n === t.getSourceId()
  }
  endDrag() {}
  constructor(t) {
    ;(this.config = t), (this.item = {}), this.initializeExposedProperties()
  }
}
const m_ = '__NATIVE_FILE__',
  y_ = '__NATIVE_URL__',
  v_ = '__NATIVE_TEXT__',
  w_ = '__NATIVE_HTML__'
var D2 = Object.freeze({ __proto__: null, FILE: m_, HTML: w_, TEXT: v_, URL: y_ })
function sm(e, t, n) {
  const r = t.reduce((i, s) => i || e.getData(s), '')
  return r ?? n
}
const Gy = {
  [m_]: {
    exposeProperties: {
      files: (e) => Array.prototype.slice.call(e.files),
      items: (e) => e.items,
      dataTransfer: (e) => e,
    },
    matchesTypes: ['Files'],
  },
  [w_]: {
    exposeProperties: { html: (e, t) => sm(e, t, ''), dataTransfer: (e) => e },
    matchesTypes: ['Html', 'text/html'],
  },
  [y_]: {
    exposeProperties: {
      urls: (e, t) =>
        sm(e, t, '').split(`
`),
      dataTransfer: (e) => e,
    },
    matchesTypes: ['Url', 'text/uri-list'],
  },
  [v_]: {
    exposeProperties: { text: (e, t) => sm(e, t, ''), dataTransfer: (e) => e },
    matchesTypes: ['Text', 'text/plain'],
  },
}
function LD(e, t) {
  const n = Gy[e]
  if (!n) throw new Error(`native type ${e} has no configuration`)
  const r = new jD(n)
  return r.loadDataTransfer(t), r
}
function om(e) {
  if (!e) return null
  const t = Array.prototype.slice.call(e.types || [])
  return (
    Object.keys(Gy).filter((n) => {
      const r = Gy[n]
      return r != null && r.matchesTypes ? r.matchesTypes.some((i) => t.indexOf(i) > -1) : !1
    })[0] || null
  )
}
const $D = g_(() => /firefox/i.test(navigator.userAgent)),
  b_ = g_(() => !!window.safari)
class N2 {
  interpolate(t) {
    const { xs: n, ys: r, c1s: i, c2s: s, c3s: o } = this
    let a = n.length - 1
    if (t === n[a]) return r[a]
    let l = 0,
      c = o.length - 1,
      u
    for (; l <= c; ) {
      u = Math.floor(0.5 * (l + c))
      const p = n[u]
      if (p < t) l = u + 1
      else if (p > t) c = u - 1
      else return r[u]
    }
    a = Math.max(0, c)
    const f = t - n[a],
      d = f * f
    return r[a] + i[a] * f + s[a] * d + o[a] * f * d
  }
  constructor(t, n) {
    const { length: r } = t,
      i = []
    for (let p = 0; p < r; p++) i.push(p)
    i.sort((p, h) => (t[p] < t[h] ? -1 : 1))
    const s = [],
      o = []
    let a, l
    for (let p = 0; p < r - 1; p++)
      (a = t[p + 1] - t[p]), (l = n[p + 1] - n[p]), s.push(a), o.push(l / a)
    const c = [o[0]]
    for (let p = 0; p < s.length - 1; p++) {
      const h = o[p],
        m = o[p + 1]
      if (h * m <= 0) c.push(0)
      else {
        a = s[p]
        const b = s[p + 1],
          y = a + b
        c.push((3 * y) / ((y + b) / h + (y + a) / m))
      }
    }
    c.push(o[o.length - 1])
    const u = [],
      f = []
    let d
    for (let p = 0; p < c.length - 1; p++) {
      d = o[p]
      const h = c[p],
        m = 1 / s[p],
        b = h + c[p + 1] - d - d
      u.push((d - h - b) * m), f.push(b * m * m)
    }
    ;(this.xs = t), (this.ys = n), (this.c1s = c), (this.c2s = u), (this.c3s = f)
  }
}
const FD = 1
function x_(e) {
  const t = e.nodeType === FD ? e : e.parentElement
  if (!t) return null
  const { top: n, left: r } = t.getBoundingClientRect()
  return { x: r, y: n }
}
function Rd(e) {
  return { x: e.clientX, y: e.clientY }
}
function BD(e) {
  var t
  return (
    e.nodeName === 'IMG' &&
    ($D() || !(!((t = document.documentElement) === null || t === void 0) && t.contains(e)))
  )
}
function UD(e, t, n, r) {
  let i = e ? t.width : n,
    s = e ? t.height : r
  return (
    b_() && e && ((s /= window.devicePixelRatio), (i /= window.devicePixelRatio)),
    { dragPreviewWidth: i, dragPreviewHeight: s }
  )
}
function zD(e, t, n, r, i) {
  const s = BD(t),
    a = x_(s ? e : t),
    l = { x: n.x - a.x, y: n.y - a.y },
    { offsetWidth: c, offsetHeight: u } = e,
    { anchorX: f, anchorY: d } = r,
    { dragPreviewWidth: p, dragPreviewHeight: h } = UD(s, t, c, u),
    m = () => {
      let I = new N2([0, 0.5, 1], [l.y, (l.y / u) * h, l.y + h - u]).interpolate(d)
      return b_() && s && (I += (window.devicePixelRatio - 1) * h), I
    },
    b = () => new N2([0, 0.5, 1], [l.x, (l.x / c) * p, l.x + p - c]).interpolate(f),
    { offsetX: y, offsetY: v } = i,
    S = y === 0 || y,
    T = v === 0 || v
  return { x: S ? y : b(), y: T ? v : m() }
}
let WD = class {
  get window() {
    if (this.globalContext) return this.globalContext
    if (typeof window < 'u') return window
  }
  get document() {
    var t
    return !((t = this.globalContext) === null || t === void 0) && t.document
      ? this.globalContext.document
      : this.window
      ? this.window.document
      : void 0
  }
  get rootElement() {
    var t
    return ((t = this.optionsArgs) === null || t === void 0 ? void 0 : t.rootElement) || this.window
  }
  constructor(t, n) {
    ;(this.ownerDocument = null), (this.globalContext = t), (this.optionsArgs = n)
  }
}
function VD(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function M2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {},
      r = Object.keys(n)
    typeof Object.getOwnPropertySymbols == 'function' &&
      (r = r.concat(
        Object.getOwnPropertySymbols(n).filter(function (i) {
          return Object.getOwnPropertyDescriptor(n, i).enumerable
        })
      )),
      r.forEach(function (i) {
        VD(e, i, n[i])
      })
  }
  return e
}
class HD {
  profile() {
    var t, n
    return {
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      sourceNodeOptions: this.sourceNodeOptions.size,
      sourceNodes: this.sourceNodes.size,
      dragStartSourceIds:
        ((t = this.dragStartSourceIds) === null || t === void 0 ? void 0 : t.length) || 0,
      dropTargetIds: this.dropTargetIds.length,
      dragEnterTargetIds: this.dragEnterTargetIds.length,
      dragOverTargetIds:
        ((n = this.dragOverTargetIds) === null || n === void 0 ? void 0 : n.length) || 0,
    }
  }
  get window() {
    return this.options.window
  }
  get document() {
    return this.options.document
  }
  get rootElement() {
    return this.options.rootElement
  }
  setup() {
    const t = this.rootElement
    if (t !== void 0) {
      if (t.__isReactDndBackendSetUp)
        throw new Error('Cannot have two HTML5 backends at the same time.')
      ;(t.__isReactDndBackendSetUp = !0), this.addEventListeners(t)
    }
  }
  teardown() {
    const t = this.rootElement
    if (
      t !== void 0 &&
      ((t.__isReactDndBackendSetUp = !1),
      this.removeEventListeners(this.rootElement),
      this.clearCurrentDragSourceNode(),
      this.asyncEndDragFrameId)
    ) {
      var n
      ;(n = this.window) === null ||
        n === void 0 ||
        n.cancelAnimationFrame(this.asyncEndDragFrameId)
    }
  }
  connectDragPreview(t, n, r) {
    return (
      this.sourcePreviewNodeOptions.set(t, r),
      this.sourcePreviewNodes.set(t, n),
      () => {
        this.sourcePreviewNodes.delete(t), this.sourcePreviewNodeOptions.delete(t)
      }
    )
  }
  connectDragSource(t, n, r) {
    this.sourceNodes.set(t, n), this.sourceNodeOptions.set(t, r)
    const i = (o) => this.handleDragStart(o, t),
      s = (o) => this.handleSelectStart(o)
    return (
      n.setAttribute('draggable', 'true'),
      n.addEventListener('dragstart', i),
      n.addEventListener('selectstart', s),
      () => {
        this.sourceNodes.delete(t),
          this.sourceNodeOptions.delete(t),
          n.removeEventListener('dragstart', i),
          n.removeEventListener('selectstart', s),
          n.setAttribute('draggable', 'false')
      }
    )
  }
  connectDropTarget(t, n) {
    const r = (o) => this.handleDragEnter(o, t),
      i = (o) => this.handleDragOver(o, t),
      s = (o) => this.handleDrop(o, t)
    return (
      n.addEventListener('dragenter', r),
      n.addEventListener('dragover', i),
      n.addEventListener('drop', s),
      () => {
        n.removeEventListener('dragenter', r),
          n.removeEventListener('dragover', i),
          n.removeEventListener('drop', s)
      }
    )
  }
  addEventListeners(t) {
    t.addEventListener &&
      (t.addEventListener('dragstart', this.handleTopDragStart),
      t.addEventListener('dragstart', this.handleTopDragStartCapture, !0),
      t.addEventListener('dragend', this.handleTopDragEndCapture, !0),
      t.addEventListener('dragenter', this.handleTopDragEnter),
      t.addEventListener('dragenter', this.handleTopDragEnterCapture, !0),
      t.addEventListener('dragleave', this.handleTopDragLeaveCapture, !0),
      t.addEventListener('dragover', this.handleTopDragOver),
      t.addEventListener('dragover', this.handleTopDragOverCapture, !0),
      t.addEventListener('drop', this.handleTopDrop),
      t.addEventListener('drop', this.handleTopDropCapture, !0))
  }
  removeEventListeners(t) {
    t.removeEventListener &&
      (t.removeEventListener('dragstart', this.handleTopDragStart),
      t.removeEventListener('dragstart', this.handleTopDragStartCapture, !0),
      t.removeEventListener('dragend', this.handleTopDragEndCapture, !0),
      t.removeEventListener('dragenter', this.handleTopDragEnter),
      t.removeEventListener('dragenter', this.handleTopDragEnterCapture, !0),
      t.removeEventListener('dragleave', this.handleTopDragLeaveCapture, !0),
      t.removeEventListener('dragover', this.handleTopDragOver),
      t.removeEventListener('dragover', this.handleTopDragOverCapture, !0),
      t.removeEventListener('drop', this.handleTopDrop),
      t.removeEventListener('drop', this.handleTopDropCapture, !0))
  }
  getCurrentSourceNodeOptions() {
    const t = this.monitor.getSourceId(),
      n = this.sourceNodeOptions.get(t)
    return M2({ dropEffect: this.altKeyPressed ? 'copy' : 'move' }, n || {})
  }
  getCurrentDropEffect() {
    return this.isDraggingNativeItem() ? 'copy' : this.getCurrentSourceNodeOptions().dropEffect
  }
  getCurrentSourcePreviewNodeOptions() {
    const t = this.monitor.getSourceId(),
      n = this.sourcePreviewNodeOptions.get(t)
    return M2({ anchorX: 0.5, anchorY: 0.5, captureDraggingState: !1 }, n || {})
  }
  isDraggingNativeItem() {
    const t = this.monitor.getItemType()
    return Object.keys(D2).some((n) => D2[n] === t)
  }
  beginDragNativeItem(t, n) {
    this.clearCurrentDragSourceNode(),
      (this.currentNativeSource = LD(t, n)),
      (this.currentNativeHandle = this.registry.addSource(t, this.currentNativeSource)),
      this.actions.beginDrag([this.currentNativeHandle])
  }
  setCurrentDragSourceNode(t) {
    this.clearCurrentDragSourceNode(), (this.currentDragSourceNode = t)
    const n = 1e3
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var r
      return (r = this.rootElement) === null || r === void 0
        ? void 0
        : r.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, !0)
    }, n)
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      if (((this.currentDragSourceNode = null), this.rootElement)) {
        var t
        ;(t = this.window) === null ||
          t === void 0 ||
          t.clearTimeout(this.mouseMoveTimeoutTimer || void 0),
          this.rootElement.removeEventListener(
            'mousemove',
            this.endDragIfSourceWasRemovedFromDOM,
            !0
          )
      }
      return (this.mouseMoveTimeoutTimer = null), !0
    }
    return !1
  }
  handleDragStart(t, n) {
    t.defaultPrevented ||
      (this.dragStartSourceIds || (this.dragStartSourceIds = []),
      this.dragStartSourceIds.unshift(n))
  }
  handleDragEnter(t, n) {
    this.dragEnterTargetIds.unshift(n)
  }
  handleDragOver(t, n) {
    this.dragOverTargetIds === null && (this.dragOverTargetIds = []),
      this.dragOverTargetIds.unshift(n)
  }
  handleDrop(t, n) {
    this.dropTargetIds.unshift(n)
  }
  constructor(t, n, r) {
    ;(this.sourcePreviewNodes = new Map()),
      (this.sourcePreviewNodeOptions = new Map()),
      (this.sourceNodes = new Map()),
      (this.sourceNodeOptions = new Map()),
      (this.dragStartSourceIds = null),
      (this.dropTargetIds = []),
      (this.dragEnterTargetIds = []),
      (this.currentNativeSource = null),
      (this.currentNativeHandle = null),
      (this.currentDragSourceNode = null),
      (this.altKeyPressed = !1),
      (this.mouseMoveTimeoutTimer = null),
      (this.asyncEndDragFrameId = null),
      (this.dragOverTargetIds = null),
      (this.lastClientOffset = null),
      (this.hoverRafId = null),
      (this.getSourceClientOffset = (i) => {
        const s = this.sourceNodes.get(i)
        return (s && x_(s)) || null
      }),
      (this.endDragNativeItem = () => {
        this.isDraggingNativeItem() &&
          (this.actions.endDrag(),
          this.currentNativeHandle && this.registry.removeSource(this.currentNativeHandle),
          (this.currentNativeHandle = null),
          (this.currentNativeSource = null))
      }),
      (this.isNodeInDocument = (i) =>
        !!(i && this.document && this.document.body && this.document.body.contains(i))),
      (this.endDragIfSourceWasRemovedFromDOM = () => {
        const i = this.currentDragSourceNode
        i == null ||
          this.isNodeInDocument(i) ||
          (this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(),
          this.cancelHover())
      }),
      (this.scheduleHover = (i) => {
        this.hoverRafId === null &&
          typeof requestAnimationFrame < 'u' &&
          (this.hoverRafId = requestAnimationFrame(() => {
            this.monitor.isDragging() &&
              this.actions.hover(i || [], { clientOffset: this.lastClientOffset }),
              (this.hoverRafId = null)
          }))
      }),
      (this.cancelHover = () => {
        this.hoverRafId !== null &&
          typeof cancelAnimationFrame < 'u' &&
          (cancelAnimationFrame(this.hoverRafId), (this.hoverRafId = null))
      }),
      (this.handleTopDragStartCapture = () => {
        this.clearCurrentDragSourceNode(), (this.dragStartSourceIds = [])
      }),
      (this.handleTopDragStart = (i) => {
        if (i.defaultPrevented) return
        const { dragStartSourceIds: s } = this
        this.dragStartSourceIds = null
        const o = Rd(i)
        this.monitor.isDragging() && (this.actions.endDrag(), this.cancelHover()),
          this.actions.beginDrag(s || [], {
            publishSource: !1,
            getSourceClientOffset: this.getSourceClientOffset,
            clientOffset: o,
          })
        const { dataTransfer: a } = i,
          l = om(a)
        if (this.monitor.isDragging()) {
          if (a && typeof a.setDragImage == 'function') {
            const u = this.monitor.getSourceId(),
              f = this.sourceNodes.get(u),
              d = this.sourcePreviewNodes.get(u) || f
            if (d) {
              const {
                  anchorX: p,
                  anchorY: h,
                  offsetX: m,
                  offsetY: b,
                } = this.getCurrentSourcePreviewNodeOptions(),
                S = zD(f, d, o, { anchorX: p, anchorY: h }, { offsetX: m, offsetY: b })
              a.setDragImage(d, S.x, S.y)
            }
          }
          try {
            a == null || a.setData('application/json', {})
          } catch {}
          this.setCurrentDragSourceNode(i.target)
          const { captureDraggingState: c } = this.getCurrentSourcePreviewNodeOptions()
          c
            ? this.actions.publishDragSource()
            : setTimeout(() => this.actions.publishDragSource(), 0)
        } else if (l) this.beginDragNativeItem(l)
        else {
          if (
            a &&
            !a.types &&
            ((i.target && !i.target.hasAttribute) || !i.target.hasAttribute('draggable'))
          )
            return
          i.preventDefault()
        }
      }),
      (this.handleTopDragEndCapture = () => {
        this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(),
          this.cancelHover()
      }),
      (this.handleTopDragEnterCapture = (i) => {
        if (((this.dragEnterTargetIds = []), this.isDraggingNativeItem())) {
          var s
          ;(s = this.currentNativeSource) === null ||
            s === void 0 ||
            s.loadDataTransfer(i.dataTransfer)
        }
        if (!this.enterLeaveCounter.enter(i.target) || this.monitor.isDragging()) return
        const { dataTransfer: a } = i,
          l = om(a)
        l && this.beginDragNativeItem(l, a)
      }),
      (this.handleTopDragEnter = (i) => {
        const { dragEnterTargetIds: s } = this
        if (((this.dragEnterTargetIds = []), !this.monitor.isDragging())) return
        ;(this.altKeyPressed = i.altKey),
          s.length > 0 && this.actions.hover(s, { clientOffset: Rd(i) }),
          s.some((a) => this.monitor.canDropOnTarget(a)) &&
            (i.preventDefault(),
            i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect()))
      }),
      (this.handleTopDragOverCapture = (i) => {
        if (((this.dragOverTargetIds = []), this.isDraggingNativeItem())) {
          var s
          ;(s = this.currentNativeSource) === null ||
            s === void 0 ||
            s.loadDataTransfer(i.dataTransfer)
        }
      }),
      (this.handleTopDragOver = (i) => {
        const { dragOverTargetIds: s } = this
        if (((this.dragOverTargetIds = []), !this.monitor.isDragging())) {
          i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = 'none')
          return
        }
        ;(this.altKeyPressed = i.altKey),
          (this.lastClientOffset = Rd(i)),
          this.scheduleHover(s),
          (s || []).some((a) => this.monitor.canDropOnTarget(a))
            ? (i.preventDefault(),
              i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect()))
            : this.isDraggingNativeItem()
            ? i.preventDefault()
            : (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = 'none'))
      }),
      (this.handleTopDragLeaveCapture = (i) => {
        this.isDraggingNativeItem() && i.preventDefault(),
          this.enterLeaveCounter.leave(i.target) &&
            (this.isDraggingNativeItem() && setTimeout(() => this.endDragNativeItem(), 0),
            this.cancelHover())
      }),
      (this.handleTopDropCapture = (i) => {
        if (((this.dropTargetIds = []), this.isDraggingNativeItem())) {
          var s
          i.preventDefault(),
            (s = this.currentNativeSource) === null ||
              s === void 0 ||
              s.loadDataTransfer(i.dataTransfer)
        } else om(i.dataTransfer) && i.preventDefault()
        this.enterLeaveCounter.reset()
      }),
      (this.handleTopDrop = (i) => {
        const { dropTargetIds: s } = this
        ;(this.dropTargetIds = []),
          this.actions.hover(s, { clientOffset: Rd(i) }),
          this.actions.drop({ dropEffect: this.getCurrentDropEffect() }),
          this.isDraggingNativeItem()
            ? this.endDragNativeItem()
            : this.monitor.isDragging() && this.actions.endDrag(),
          this.cancelHover()
      }),
      (this.handleSelectStart = (i) => {
        const s = i.target
        typeof s.dragDrop == 'function' &&
          (s.tagName === 'INPUT' ||
            s.tagName === 'SELECT' ||
            s.tagName === 'TEXTAREA' ||
            s.isContentEditable ||
            (i.preventDefault(), s.dragDrop()))
      }),
      (this.options = new WD(n, r)),
      (this.actions = t.getActions()),
      (this.monitor = t.getMonitor()),
      (this.registry = t.getRegistry()),
      (this.enterLeaveCounter = new MD(this.isNodeInDocument))
  }
}
let Pd
function qD() {
  return (
    Pd ||
      ((Pd = new Image()),
      (Pd.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==')),
    Pd
  )
}
const KD = function (t, n, r) {
  return new HD(t, n, r)
}
var No
;(function (e) {
  ;(e.mouse = 'mouse'), (e.touch = 'touch'), (e.keyboard = 'keyboard')
})(No || (No = {}))
class GD {
  get delay() {
    var t
    return (t = this.args.delay) !== null && t !== void 0 ? t : 0
  }
  get scrollAngleRanges() {
    return this.args.scrollAngleRanges
  }
  get getDropTargetElementsAtPoint() {
    return this.args.getDropTargetElementsAtPoint
  }
  get ignoreContextMenu() {
    var t
    return (t = this.args.ignoreContextMenu) !== null && t !== void 0 ? t : !1
  }
  get enableHoverOutsideTarget() {
    var t
    return (t = this.args.enableHoverOutsideTarget) !== null && t !== void 0 ? t : !1
  }
  get enableKeyboardEvents() {
    var t
    return (t = this.args.enableKeyboardEvents) !== null && t !== void 0 ? t : !1
  }
  get enableMouseEvents() {
    var t
    return (t = this.args.enableMouseEvents) !== null && t !== void 0 ? t : !1
  }
  get enableTouchEvents() {
    var t
    return (t = this.args.enableTouchEvents) !== null && t !== void 0 ? t : !0
  }
  get touchSlop() {
    return this.args.touchSlop || 0
  }
  get delayTouchStart() {
    var t, n, r, i
    return (i =
      (r = (t = this.args) === null || t === void 0 ? void 0 : t.delayTouchStart) !== null &&
      r !== void 0
        ? r
        : (n = this.args) === null || n === void 0
        ? void 0
        : n.delay) !== null && i !== void 0
      ? i
      : 0
  }
  get delayMouseStart() {
    var t, n, r, i
    return (i =
      (r = (t = this.args) === null || t === void 0 ? void 0 : t.delayMouseStart) !== null &&
      r !== void 0
        ? r
        : (n = this.args) === null || n === void 0
        ? void 0
        : n.delay) !== null && i !== void 0
      ? i
      : 0
  }
  get window() {
    if (this.context && this.context.window) return this.context.window
    if (typeof window < 'u') return window
  }
  get document() {
    var t
    if (!((t = this.context) === null || t === void 0) && t.document) return this.context.document
    if (this.window) return this.window.document
  }
  get rootElement() {
    var t
    return ((t = this.args) === null || t === void 0 ? void 0 : t.rootElement) || this.document
  }
  constructor(t, n) {
    ;(this.args = t), (this.context = n)
  }
}
function YD(e, t, n, r) {
  return Math.sqrt(Math.pow(Math.abs(n - e), 2) + Math.pow(Math.abs(r - t), 2))
}
function QD(e, t, n, r, i) {
  if (!i) return !1
  const s = (Math.atan2(r - t, n - e) * 180) / Math.PI + 180
  for (let o = 0; o < i.length; ++o) {
    const a = i[o]
    if (a && (a.start == null || s >= a.start) && (a.end == null || s <= a.end)) return !0
  }
  return !1
}
const XD = { Left: 1, Right: 2, Center: 4 },
  ZD = { Left: 0, Center: 1, Right: 2 }
function am(e) {
  return e.button === void 0 || e.button === ZD.Left
}
function JD(e) {
  return e.buttons === void 0 || (e.buttons & XD.Left) === 0
}
function S_(e) {
  return !!e.targetTouches
}
const eN = 1
function tN(e) {
  const t = e.nodeType === eN ? e : e.parentElement
  if (!t) return
  const { top: n, left: r } = t.getBoundingClientRect()
  return { x: r, y: n }
}
function nN(e, t) {
  if (e.targetTouches.length === 1) return jp(e.targetTouches[0])
  if (t && e.touches.length === 1 && e.touches[0].target === t.target) return jp(e.touches[0])
}
function jp(e, t) {
  return S_(e) ? nN(e, t) : { x: e.clientX, y: e.clientY }
}
const j2 = (() => {
    let e = !1
    try {
      addEventListener(
        'test',
        () => {},
        Object.defineProperty({}, 'passive', {
          get() {
            return (e = !0), !0
          },
        })
      )
    } catch {}
    return e
  })(),
  lu = {
    [No.mouse]: {
      start: 'mousedown',
      move: 'mousemove',
      end: 'mouseup',
      contextmenu: 'contextmenu',
    },
    [No.touch]: { start: 'touchstart', move: 'touchmove', end: 'touchend' },
    [No.keyboard]: { keydown: 'keydown' },
  }
class Wu {
  profile() {
    var t
    return {
      sourceNodes: this.sourceNodes.size,
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      targetNodes: this.targetNodes.size,
      dragOverTargetIds:
        ((t = this.dragOverTargetIds) === null || t === void 0 ? void 0 : t.length) || 0,
    }
  }
  get document() {
    return this.options.document
  }
  setup() {
    const t = this.options.rootElement
    t &&
      (qe(!Wu.isSetUp, 'Cannot have two Touch backends at the same time.'),
      (Wu.isSetUp = !0),
      this.addEventListener(t, 'start', this.getTopMoveStartHandler()),
      this.addEventListener(t, 'start', this.handleTopMoveStartCapture, !0),
      this.addEventListener(t, 'move', this.handleTopMove),
      this.addEventListener(t, 'move', this.handleTopMoveCapture, !0),
      this.addEventListener(t, 'end', this.handleTopMoveEndCapture, !0),
      this.options.enableMouseEvents &&
        !this.options.ignoreContextMenu &&
        this.addEventListener(t, 'contextmenu', this.handleTopMoveEndCapture),
      this.options.enableKeyboardEvents &&
        this.addEventListener(t, 'keydown', this.handleCancelOnEscape, !0))
  }
  teardown() {
    const t = this.options.rootElement
    t &&
      ((Wu.isSetUp = !1),
      (this._mouseClientOffset = {}),
      this.removeEventListener(t, 'start', this.handleTopMoveStartCapture, !0),
      this.removeEventListener(t, 'start', this.handleTopMoveStart),
      this.removeEventListener(t, 'move', this.handleTopMoveCapture, !0),
      this.removeEventListener(t, 'move', this.handleTopMove),
      this.removeEventListener(t, 'end', this.handleTopMoveEndCapture, !0),
      this.options.enableMouseEvents &&
        !this.options.ignoreContextMenu &&
        this.removeEventListener(t, 'contextmenu', this.handleTopMoveEndCapture),
      this.options.enableKeyboardEvents &&
        this.removeEventListener(t, 'keydown', this.handleCancelOnEscape, !0),
      this.uninstallSourceNodeRemovalObserver())
  }
  addEventListener(t, n, r, i = !1) {
    const s = j2 ? { capture: i, passive: !1 } : i
    this.listenerTypes.forEach(function (o) {
      const a = lu[o][n]
      a && t.addEventListener(a, r, s)
    })
  }
  removeEventListener(t, n, r, i = !1) {
    const s = j2 ? { capture: i, passive: !1 } : i
    this.listenerTypes.forEach(function (o) {
      const a = lu[o][n]
      a && t.removeEventListener(a, r, s)
    })
  }
  connectDragSource(t, n) {
    const r = this.handleMoveStart.bind(this, t)
    return (
      this.sourceNodes.set(t, n),
      this.addEventListener(n, 'start', r),
      () => {
        this.sourceNodes.delete(t), this.removeEventListener(n, 'start', r)
      }
    )
  }
  connectDragPreview(t, n, r) {
    return (
      this.sourcePreviewNodeOptions.set(t, r),
      this.sourcePreviewNodes.set(t, n),
      () => {
        this.sourcePreviewNodes.delete(t), this.sourcePreviewNodeOptions.delete(t)
      }
    )
  }
  connectDropTarget(t, n) {
    const r = this.options.rootElement
    if (!this.document || !r) return () => {}
    const i = (s) => {
      if (!this.document || !r || !this.monitor.isDragging()) return
      let o
      switch (s.type) {
        case lu.mouse.move:
          o = { x: s.clientX, y: s.clientY }
          break
        case lu.touch.move:
          var a, l
          o = {
            x: ((a = s.touches[0]) === null || a === void 0 ? void 0 : a.clientX) || 0,
            y: ((l = s.touches[0]) === null || l === void 0 ? void 0 : l.clientY) || 0,
          }
          break
      }
      const c = o != null ? this.document.elementFromPoint(o.x, o.y) : void 0,
        u = c && n.contains(c)
      if (c === n || u) return this.handleMove(s, t)
    }
    return (
      this.addEventListener(this.document.body, 'move', i),
      this.targetNodes.set(t, n),
      () => {
        this.document &&
          (this.targetNodes.delete(t), this.removeEventListener(this.document.body, 'move', i))
      }
    )
  }
  getTopMoveStartHandler() {
    return !this.options.delayTouchStart && !this.options.delayMouseStart
      ? this.handleTopMoveStart
      : this.handleTopMoveStartDelay
  }
  installSourceNodeRemovalObserver(t) {
    this.uninstallSourceNodeRemovalObserver(),
      (this.draggedSourceNode = t),
      (this.draggedSourceNodeRemovalObserver = new MutationObserver(() => {
        t &&
          !t.parentElement &&
          (this.resurrectSourceNode(), this.uninstallSourceNodeRemovalObserver())
      })),
      !(!t || !t.parentElement) &&
        this.draggedSourceNodeRemovalObserver.observe(t.parentElement, { childList: !0 })
  }
  resurrectSourceNode() {
    this.document &&
      this.draggedSourceNode &&
      ((this.draggedSourceNode.style.display = 'none'),
      this.draggedSourceNode.removeAttribute('data-reactid'),
      this.document.body.appendChild(this.draggedSourceNode))
  }
  uninstallSourceNodeRemovalObserver() {
    this.draggedSourceNodeRemovalObserver && this.draggedSourceNodeRemovalObserver.disconnect(),
      (this.draggedSourceNodeRemovalObserver = void 0),
      (this.draggedSourceNode = void 0)
  }
  constructor(t, n, r) {
    ;(this.getSourceClientOffset = (i) => {
      const s = this.sourceNodes.get(i)
      return s && tN(s)
    }),
      (this.handleTopMoveStartCapture = (i) => {
        am(i) && (this.moveStartSourceIds = [])
      }),
      (this.handleMoveStart = (i) => {
        Array.isArray(this.moveStartSourceIds) && this.moveStartSourceIds.unshift(i)
      }),
      (this.handleTopMoveStart = (i) => {
        if (!am(i)) return
        const s = jp(i)
        s &&
          (S_(i) && (this.lastTargetTouchFallback = i.targetTouches[0]),
          (this._mouseClientOffset = s)),
          (this.waitingForDelay = !1)
      }),
      (this.handleTopMoveStartDelay = (i) => {
        if (!am(i)) return
        const s =
          i.type === lu.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart
        ;(this.timeout = setTimeout(this.handleTopMoveStart.bind(this, i), s)),
          (this.waitingForDelay = !0)
      }),
      (this.handleTopMoveCapture = () => {
        this.dragOverTargetIds = []
      }),
      (this.handleMove = (i, s) => {
        this.dragOverTargetIds && this.dragOverTargetIds.unshift(s)
      }),
      (this.handleTopMove = (i) => {
        if ((this.timeout && clearTimeout(this.timeout), !this.document || this.waitingForDelay))
          return
        const { moveStartSourceIds: s, dragOverTargetIds: o } = this,
          a = this.options.enableHoverOutsideTarget,
          l = jp(i, this.lastTargetTouchFallback)
        if (!l) return
        if (
          this._isScrolling ||
          (!this.monitor.isDragging() &&
            QD(
              this._mouseClientOffset.x || 0,
              this._mouseClientOffset.y || 0,
              l.x,
              l.y,
              this.options.scrollAngleRanges
            ))
        ) {
          this._isScrolling = !0
          return
        }
        if (
          (!this.monitor.isDragging() &&
            this._mouseClientOffset.hasOwnProperty('x') &&
            s &&
            YD(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, l.x, l.y) >
              (this.options.touchSlop ? this.options.touchSlop : 0) &&
            ((this.moveStartSourceIds = void 0),
            this.actions.beginDrag(s, {
              clientOffset: this._mouseClientOffset,
              getSourceClientOffset: this.getSourceClientOffset,
              publishSource: !1,
            })),
          !this.monitor.isDragging())
        )
          return
        const c = this.sourceNodes.get(this.monitor.getSourceId())
        this.installSourceNodeRemovalObserver(c),
          this.actions.publishDragSource(),
          i.cancelable && i.preventDefault()
        const u = (o || []).map((h) => this.targetNodes.get(h)).filter((h) => !!h),
          f = this.options.getDropTargetElementsAtPoint
            ? this.options.getDropTargetElementsAtPoint(l.x, l.y, u)
            : this.document.elementsFromPoint(l.x, l.y),
          d = []
        for (const h in f) {
          if (!f.hasOwnProperty(h)) continue
          let m = f[h]
          for (m != null && d.push(m); m; )
            (m = m.parentElement), m && d.indexOf(m) === -1 && d.push(m)
        }
        const p = d
          .filter((h) => u.indexOf(h) > -1)
          .map((h) => this._getDropTargetId(h))
          .filter((h) => !!h)
          .filter((h, m, b) => b.indexOf(h) === m)
        if (a)
          for (const h in this.targetNodes) {
            const m = this.targetNodes.get(h)
            if (c && m && m.contains(c) && p.indexOf(h) === -1) {
              p.unshift(h)
              break
            }
          }
        p.reverse(), this.actions.hover(p, { clientOffset: l })
      }),
      (this._getDropTargetId = (i) => {
        const s = this.targetNodes.keys()
        let o = s.next()
        for (; o.done === !1; ) {
          const a = o.value
          if (i === this.targetNodes.get(a)) return a
          o = s.next()
        }
      }),
      (this.handleTopMoveEndCapture = (i) => {
        if (((this._isScrolling = !1), (this.lastTargetTouchFallback = void 0), !!JD(i))) {
          if (!this.monitor.isDragging() || this.monitor.didDrop()) {
            this.moveStartSourceIds = void 0
            return
          }
          i.cancelable && i.preventDefault(),
            (this._mouseClientOffset = {}),
            this.uninstallSourceNodeRemovalObserver(),
            this.actions.drop(),
            this.actions.endDrag()
        }
      }),
      (this.handleCancelOnEscape = (i) => {
        i.key === 'Escape' &&
          this.monitor.isDragging() &&
          ((this._mouseClientOffset = {}),
          this.uninstallSourceNodeRemovalObserver(),
          this.actions.endDrag())
      }),
      (this.options = new GD(r, n)),
      (this.actions = t.getActions()),
      (this.monitor = t.getMonitor()),
      (this.sourceNodes = new Map()),
      (this.sourcePreviewNodes = new Map()),
      (this.sourcePreviewNodeOptions = new Map()),
      (this.targetNodes = new Map()),
      (this.listenerTypes = []),
      (this._mouseClientOffset = {}),
      (this._isScrolling = !1),
      this.options.enableMouseEvents && this.listenerTypes.push(No.mouse),
      this.options.enableTouchEvents && this.listenerTypes.push(No.touch),
      this.options.enableKeyboardEvents && this.listenerTypes.push(No.keyboard)
  }
}
const rN = function (t, n = {}, r = {}) {
    return new Wu(t, n, r)
  },
  mf = 'abcdefgh'.split(''),
  wh = {
    a8: 'bR',
    b8: 'bN',
    c8: 'bB',
    d8: 'bQ',
    e8: 'bK',
    f8: 'bB',
    g8: 'bN',
    h8: 'bR',
    a7: 'bP',
    b7: 'bP',
    c7: 'bP',
    d7: 'bP',
    e7: 'bP',
    f7: 'bP',
    g7: 'bP',
    h7: 'bP',
    a2: 'wP',
    b2: 'wP',
    c2: 'wP',
    d2: 'wP',
    e2: 'wP',
    f2: 'wP',
    g2: 'wP',
    h2: 'wP',
    a1: 'wR',
    b1: 'wN',
    c1: 'wB',
    d1: 'wQ',
    e1: 'wK',
    f1: 'wB',
    g1: 'wN',
    h1: 'wR',
  },
  iN = { a: 0, b: 1, c: 2, d: 3, e: 4, f: 5, g: 6, h: 7 },
  sN = { a: 7, b: 6, c: 5, d: 4, e: 3, f: 2, g: 1, h: 0 },
  oN = [7, 6, 5, 4, 3, 2, 1, 0],
  aN = [0, 1, 2, 3, 4, 5, 6, 7],
  L2 = {
    wP: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsx('path', {
            d: 'm 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z',
            style: {
              opacity: '1',
              fill: '#ffffff',
              fillOpacity: '1',
              fillRule: 'nonzero',
              stroke: '#000000',
              strokeWidth: '1.5',
              strokeLinecap: 'round',
              strokeLinejoin: 'miter',
              strokeMiterlimit: '4',
              strokeDasharray: 'none',
              strokeOpacity: '1',
            },
          }),
        }
      )
    ),
    wR: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  opacity: '1',
                  fill: '#ffffff',
                  fillOpacity: '1',
                  fillRule: 'evenodd',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeMiterlimit: '4',
                  strokeDasharray: 'none',
                  strokeOpacity: '1',
                },
              },
              {
                children: [
                  E.jsx('path', {
                    d: 'M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ',
                    style: { strokeLinecap: 'butt' },
                  }),
                  E.jsx('path', {
                    d: 'M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ',
                    style: { strokeLinecap: 'butt' },
                  }),
                  E.jsx('path', {
                    d: 'M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14',
                    style: { strokeLinecap: 'butt' },
                  }),
                  E.jsx('path', { d: 'M 34,14 L 31,17 L 14,17 L 11,14' }),
                  E.jsx('path', {
                    d: 'M 31,17 L 31,29.5 L 14,29.5 L 14,17',
                    style: { strokeLinecap: 'butt', strokeLinejoin: 'miter' },
                  }),
                  E.jsx('path', { d: 'M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5' }),
                  E.jsx('path', {
                    d: 'M 11,14 L 34,14',
                    style: { fill: 'none', stroke: '#000000', strokeLinejoin: 'miter' },
                  }),
                ],
              }
            )
          ),
        }
      )
    ),
    wN: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  opacity: '1',
                  fill: 'none',
                  fillOpacity: '1',
                  fillRule: 'evenodd',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeMiterlimit: '4',
                  strokeDasharray: 'none',
                  strokeOpacity: '1',
                },
              },
              {
                children: [
                  E.jsx('path', {
                    d: 'M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18',
                    style: { fill: '#ffffff', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10',
                    style: { fill: '#ffffff', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z',
                    style: { fill: '#000000', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z',
                    transform: 'matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)',
                    style: { fill: '#000000', stroke: '#000000' },
                  }),
                ],
              }
            )
          ),
        }
      )
    ),
    wB: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  opacity: '1',
                  fill: 'none',
                  fillRule: 'evenodd',
                  fillOpacity: '1',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeMiterlimit: '4',
                  strokeDasharray: 'none',
                  strokeOpacity: '1',
                },
              },
              {
                children: [
                  E.jsxs(
                    'g',
                    Object.assign(
                      { style: { fill: '#ffffff', stroke: '#000000', strokeLinecap: 'butt' } },
                      {
                        children: [
                          E.jsx('path', {
                            d: 'M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z',
                          }),
                          E.jsx('path', {
                            d: 'M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z',
                          }),
                          E.jsx('path', {
                            d: 'M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z',
                          }),
                        ],
                      }
                    )
                  ),
                  E.jsx('path', {
                    d: 'M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18',
                    style: { fill: 'none', stroke: '#000000', strokeLinejoin: 'miter' },
                  }),
                ],
              }
            )
          ),
        }
      )
    ),
    wQ: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  fill: '#ffffff',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinejoin: 'round',
                },
              },
              {
                children: [
                  E.jsx('path', {
                    d: 'M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z',
                  }),
                  E.jsx('path', {
                    d: 'M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z',
                  }),
                  E.jsx('path', { d: 'M 11.5,30 C 15,29 30,29 33.5,30', style: { fill: 'none' } }),
                  E.jsx('path', {
                    d: 'M 12,33.5 C 18,32.5 27,32.5 33,33.5',
                    style: { fill: 'none' },
                  }),
                  E.jsx('circle', { cx: '6', cy: '12', r: '2' }),
                  E.jsx('circle', { cx: '14', cy: '9', r: '2' }),
                  E.jsx('circle', { cx: '22.5', cy: '8', r: '2' }),
                  E.jsx('circle', { cx: '31', cy: '9', r: '2' }),
                  E.jsx('circle', { cx: '39', cy: '12', r: '2' }),
                ],
              }
            )
          ),
        }
      )
    ),
    wK: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  fill: 'none',
                  fillOpacity: '1',
                  fillRule: 'evenodd',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeMiterlimit: '4',
                  strokeDasharray: 'none',
                  strokeOpacity: '1',
                },
              },
              {
                children: [
                  E.jsx('path', {
                    d: 'M 22.5,11.63 L 22.5,6',
                    style: { fill: 'none', stroke: '#000000', strokeLinejoin: 'miter' },
                  }),
                  E.jsx('path', {
                    d: 'M 20,8 L 25,8',
                    style: { fill: 'none', stroke: '#000000', strokeLinejoin: 'miter' },
                  }),
                  E.jsx('path', {
                    d: 'M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25',
                    style: {
                      fill: '#ffffff',
                      stroke: '#000000',
                      strokeLinecap: 'butt',
                      strokeLinejoin: 'miter',
                    },
                  }),
                  E.jsx('path', {
                    d: 'M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37',
                    style: { fill: '#ffffff', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 12.5,30 C 18,27 27,27 32.5,30',
                    style: { fill: 'none', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5',
                    style: { fill: 'none', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 12.5,37 C 18,34 27,34 32.5,37',
                    style: { fill: 'none', stroke: '#000000' },
                  }),
                ],
              }
            )
          ),
        }
      )
    ),
    bP: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsx('path', {
            d: 'm 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z',
            style: {
              opacity: '1',
              fill: '#000000',
              fillOpacity: '1',
              fillRule: 'nonzero',
              stroke: '#000000',
              strokeWidth: '1.5',
              strokeLinecap: 'round',
              strokeLinejoin: 'miter',
              strokeMiterlimit: '4',
              strokeDasharray: 'none',
              strokeOpacity: '1',
            },
          }),
        }
      )
    ),
    bR: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  opacity: '1',
                  fill: '#000000',
                  fillOpacity: '1',
                  fillRule: 'evenodd',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeMiterlimit: '4',
                  strokeDasharray: 'none',
                  strokeOpacity: '1',
                },
              },
              {
                children: [
                  E.jsx('path', {
                    d: 'M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ',
                    style: { strokeLinecap: 'butt' },
                  }),
                  E.jsx('path', {
                    d: 'M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z ',
                    style: { strokeLinecap: 'butt' },
                  }),
                  E.jsx('path', {
                    d: 'M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ',
                    style: { strokeLinecap: 'butt' },
                  }),
                  E.jsx('path', {
                    d: 'M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z ',
                    style: { strokeLinecap: 'butt', strokeLinejoin: 'miter' },
                  }),
                  E.jsx('path', {
                    d: 'M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z ',
                    style: { strokeLinecap: 'butt' },
                  }),
                  E.jsx('path', {
                    d: 'M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z ',
                    style: { strokeLinecap: 'butt' },
                  }),
                  E.jsx('path', {
                    d: 'M 12,35.5 L 33,35.5 L 33,35.5',
                    style: {
                      fill: 'none',
                      stroke: '#ffffff',
                      strokeWidth: '1',
                      strokeLinejoin: 'miter',
                    },
                  }),
                  E.jsx('path', {
                    d: 'M 13,31.5 L 32,31.5',
                    style: {
                      fill: 'none',
                      stroke: '#ffffff',
                      strokeWidth: '1',
                      strokeLinejoin: 'miter',
                    },
                  }),
                  E.jsx('path', {
                    d: 'M 14,29.5 L 31,29.5',
                    style: {
                      fill: 'none',
                      stroke: '#ffffff',
                      strokeWidth: '1',
                      strokeLinejoin: 'miter',
                    },
                  }),
                  E.jsx('path', {
                    d: 'M 14,16.5 L 31,16.5',
                    style: {
                      fill: 'none',
                      stroke: '#ffffff',
                      strokeWidth: '1',
                      strokeLinejoin: 'miter',
                    },
                  }),
                  E.jsx('path', {
                    d: 'M 11,14 L 34,14',
                    style: {
                      fill: 'none',
                      stroke: '#ffffff',
                      strokeWidth: '1',
                      strokeLinejoin: 'miter',
                    },
                  }),
                ],
              }
            )
          ),
        }
      )
    ),
    bN: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  opacity: '1',
                  fill: 'none',
                  fillOpacity: '1',
                  fillRule: 'evenodd',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeMiterlimit: '4',
                  strokeDasharray: 'none',
                  strokeOpacity: '1',
                },
              },
              {
                children: [
                  E.jsx('path', {
                    d: 'M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18',
                    style: { fill: '#000000', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10',
                    style: { fill: '#000000', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z',
                    style: { fill: '#ffffff', stroke: '#ffffff' },
                  }),
                  E.jsx('path', {
                    d: 'M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z',
                    transform: 'matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)',
                    style: { fill: '#ffffff', stroke: '#ffffff' },
                  }),
                  E.jsx('path', {
                    d: 'M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z ',
                    style: { fill: '#ffffff', stroke: 'none' },
                  }),
                ],
              }
            )
          ),
        }
      )
    ),
    bB: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  opacity: '1',
                  fill: 'none',
                  fillRule: 'evenodd',
                  fillOpacity: '1',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeMiterlimit: '4',
                  strokeDasharray: 'none',
                  strokeOpacity: '1',
                },
              },
              {
                children: [
                  E.jsxs(
                    'g',
                    Object.assign(
                      { style: { fill: '#000000', stroke: '#000000', strokeLinecap: 'butt' } },
                      {
                        children: [
                          E.jsx('path', {
                            d: 'M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z',
                          }),
                          E.jsx('path', {
                            d: 'M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z',
                          }),
                          E.jsx('path', {
                            d: 'M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z',
                          }),
                        ],
                      }
                    )
                  ),
                  E.jsx('path', {
                    d: 'M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18',
                    style: { fill: 'none', stroke: '#ffffff', strokeLinejoin: 'miter' },
                  }),
                ],
              }
            )
          ),
        }
      )
    ),
    bQ: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  fill: '#000000',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                },
              },
              {
                children: [
                  E.jsx('path', {
                    d: 'M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z',
                    style: { strokeLinecap: 'butt', fill: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'm 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z',
                  }),
                  E.jsx('path', { d: 'M 11.5,30 C 15,29 30,29 33.5,30' }),
                  E.jsx('path', { d: 'm 12,33.5 c 6,-1 15,-1 21,0' }),
                  E.jsx('circle', { cx: '6', cy: '12', r: '2' }),
                  E.jsx('circle', { cx: '14', cy: '9', r: '2' }),
                  E.jsx('circle', { cx: '22.5', cy: '8', r: '2' }),
                  E.jsx('circle', { cx: '31', cy: '9', r: '2' }),
                  E.jsx('circle', { cx: '39', cy: '12', r: '2' }),
                  E.jsx('path', {
                    d: 'M 11,38.5 A 35,35 1 0 0 34,38.5',
                    style: { fill: 'none', stroke: '#000000', strokeLinecap: 'butt' },
                  }),
                  E.jsxs(
                    'g',
                    Object.assign(
                      { style: { fill: 'none', stroke: '#ffffff' } },
                      {
                        children: [
                          E.jsx('path', { d: 'M 11,29 A 35,35 1 0 1 34,29' }),
                          E.jsx('path', { d: 'M 12.5,31.5 L 32.5,31.5' }),
                          E.jsx('path', { d: 'M 11.5,34.5 A 35,35 1 0 0 33.5,34.5' }),
                          E.jsx('path', { d: 'M 10.5,37.5 A 35,35 1 0 0 34.5,37.5' }),
                        ],
                      }
                    )
                  ),
                ],
              }
            )
          ),
        }
      )
    ),
    bK: E.jsx(
      'svg',
      Object.assign(
        { xmlns: 'http://www.w3.org/2000/svg', version: '1.1', width: '45', height: '45' },
        {
          children: E.jsxs(
            'g',
            Object.assign(
              {
                style: {
                  fill: 'none',
                  fillOpacity: '1',
                  fillRule: 'evenodd',
                  stroke: '#000000',
                  strokeWidth: '1.5',
                  strokeLinecap: 'round',
                  strokeLinejoin: 'round',
                  strokeMiterlimit: '4',
                  strokeDasharray: 'none',
                  strokeOpacity: '1',
                },
              },
              {
                children: [
                  E.jsx('path', {
                    d: 'M 22.5,11.63 L 22.5,6',
                    style: { fill: 'none', stroke: '#000000', strokeLinejoin: 'miter' },
                    id: 'path6570',
                  }),
                  E.jsx('path', {
                    d: 'M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25',
                    style: {
                      fill: '#000000',
                      fillOpacity: '1',
                      strokeLinecap: 'butt',
                      strokeLinejoin: 'miter',
                    },
                  }),
                  E.jsx('path', {
                    d: 'M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37',
                    style: { fill: '#000000', stroke: '#000000' },
                  }),
                  E.jsx('path', {
                    d: 'M 20,8 L 25,8',
                    style: { fill: 'none', stroke: '#000000', strokeLinejoin: 'miter' },
                  }),
                  E.jsx('path', {
                    d: 'M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5',
                    style: { fill: 'none', stroke: '#ffffff' },
                  }),
                  E.jsx('path', {
                    d: 'M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37',
                    style: { fill: 'none', stroke: '#ffffff' },
                  }),
                ],
              }
            )
          ),
        }
      )
    ),
  }
function Yy(e, t, n) {
  const r = t / 8,
    i = e === 'white' ? iN : sN,
    s = e === 'white' ? oN : aN,
    o = i[n[0]] * r + r / 2,
    a = s[parseInt(n[1], 10) - 1] * r + r / 2
  return { x: o, y: a }
}
function $2(e) {
  let t = !1
  return (
    Object.keys(wh).forEach((n) => {
      e[n] !== wh[n] && (t = !0)
    }),
    Object.keys(e).forEach((n) => {
      wh[n] !== e[n] && (t = !0)
    }),
    t
  )
}
function lN(e, t) {
  const n = { removed: {}, added: {} }
  return (
    Object.keys(e).forEach((r) => {
      t[r] !== e[r] && (n.removed[r] = e[r])
    }),
    Object.keys(t).forEach((r) => {
      e[r] !== t[r] && (n.added[r] = t[r])
    }),
    n
  )
}
function F2(e) {
  return e === 'start' ? wh : typeof e == 'string' ? cN(e) : e
}
function cN(e) {
  if (!uN(e)) return {}
  e = e.replace(/ .+$/, '')
  const t = e.split('/'),
    n = {}
  let r = 8
  for (let i = 0; i < 8; i++) {
    const s = t[i].split('')
    let o = 0
    for (let a = 0; a < s.length; a++)
      if (s[a].search(/[1-8]/) !== -1) {
        const l = parseInt(s[a], 10)
        o = o + l
      } else {
        const l = mf[o] + r
        ;(n[l] = dN(s[a])), (o = o + 1)
      }
    r = r - 1
  }
  return n
}
function uN(e) {
  ;(e = e.replace(/ .+$/, '')), (e = fN(e))
  const t = e.split('/')
  if (t.length !== 8) return !1
  for (let n = 0; n < 8; n++)
    if (t[n].length !== 8 || t[n].search(/[^kqrnbpKQRNBP1]/) !== -1) return !1
  return !0
}
function fN(e) {
  return e
    .replace(/8/g, '11111111')
    .replace(/7/g, '1111111')
    .replace(/6/g, '111111')
    .replace(/5/g, '11111')
    .replace(/4/g, '1111')
    .replace(/3/g, '111')
    .replace(/2/g, '11')
}
function dN(e) {
  return e.toLowerCase() === e ? 'b' + e.toUpperCase() : 'w' + e.toUpperCase()
}
const hN = (e, t = !0, n, r) => {
    const [i, s] = w.useState([]),
      [o, a] = w.useState([]),
      [l, c] = w.useState()
    w.useEffect(() => {
      Array.isArray(e) && s(e == null ? void 0 : e.filter((h) => h[0] !== h[1]))
    }, [e]),
      w.useEffect(() => {
        n == null || n(o)
      }, [o])
    function u() {
      a([]), c(void 0)
    }
    const f = (h, m) => {
        t && c([h, m, r])
      },
      d = [...o, ...i]
    return {
      arrows: d,
      newArrow: l,
      clearArrows: u,
      drawNewArrow: f,
      setArrows: a,
      onArrowDrawEnd: (h, m) => {
        if (h === m || !t) return
        let b
        const y = [h, m, r]
        d.every(([S, T]) => !(S === h && T === m))
          ? (b = [...o, y])
          : (b = o.filter(([S, T]) => !(S === h && T === m))),
          c(void 0),
          a(b)
      },
    }
  },
  E_ = w.createContext({}),
  Us = () => w.useContext(E_),
  pN = w.forwardRef(
    (
      {
        allowDragOutsideBoard: e = !0,
        animationDuration: t = 300,
        areArrowsAllowed: n = !0,
        arePiecesDraggable: r = !0,
        arePremovesAllowed: i = !1,
        autoPromoteToQueen: s = !1,
        boardOrientation: o = 'white',
        boardWidth: a,
        children: l,
        clearPremovesOnRightClick: c = !0,
        customArrows: u,
        customArrowColor: f = 'rgb(255,170,0)',
        customBoardStyle: d,
        customNotationStyle: p,
        customDarkSquareStyle: h = { backgroundColor: '#B58863' },
        customDropSquareStyle: m = { boxShadow: 'inset 0 0 1px 6px rgba(255,255,255,0.75)' },
        customLightSquareStyle: b = { backgroundColor: '#F0D9B5' },
        customPieces: y,
        customPremoveDarkSquareStyle: v = { backgroundColor: '#A42323' },
        customPremoveLightSquareStyle: S = { backgroundColor: '#BD2828' },
        customSquare: T = 'div',
        customSquareStyles: A,
        dropOffBoardAction: I = 'snapback',
        id: k = 0,
        isDraggablePiece: D = () => !0,
        getPositionObject: F = () => {},
        onArrowsChange: V = () => {},
        onDragOverSquare: ie = () => {},
        onMouseOutSquare: de = () => {},
        onMouseOverSquare: xe = () => {},
        onPieceClick: we = () => {},
        onPieceDragBegin: Pe = () => {},
        onPieceDragEnd: We = () => {},
        onPieceDrop: Me = () => !0,
        onPromotionCheck: K = (Ze, _t, gn) =>
          ((gn === 'wP' && Ze[1] === '7' && _t[1] === '8') ||
            (gn === 'bP' && Ze[1] === '2' && _t[1] === '1')) &&
          Math.abs(Ze.charCodeAt(0) - _t.charCodeAt(0)) <= 1,
        onPromotionPieceSelect: H = () => !0,
        onSquareClick: oe = () => {},
        onSquareRightClick: Ae = () => {},
        position: Ie = 'start',
        promotionDialogVariant: fe = 'default',
        promotionToSquare: _e = null,
        showBoardNotation: re = !0,
        showPromotionDialog: Z = !1,
        snapToCursor: it = !0,
      },
      wt
    ) => {
      const [Ze, _t] = w.useState(F2(Ie)),
        [gn, bt] = w.useState({ removed: {}, added: {} }),
        [Jn, hr] = w.useState(void 0),
        [si, Tn] = w.useState(Z && !s),
        [Vs, ls] = w.useState(null),
        [pr, Ir] = w.useState(_e),
        [Dr, gr] = w.useState([]),
        mn = w.useRef(Dr),
        [oi, Nr] = w.useState(),
        [Bn, ai] = w.useState(Object.assign(Object.assign({}, L2), y)),
        [Hs, Mr] = w.useState(!1),
        [Go, er] = w.useState(),
        [li, jr] = w.useState(!1),
        [ji, Li] = w.useState(null)
      w.useImperativeHandle(wt, () => ({
        clearPremoves(ne = !0) {
          cs(ne)
        },
      })),
        w.useEffect(() => {
          ai(Object.assign(Object.assign({}, L2), y))
        }, [y]),
        w.useEffect(() => {
          Tn(Z), Ir(_e)
        }, [_e, Z]),
        w.useEffect(() => {
          var ne, Te, le
          Un()
          const se = F2(Ie),
            x = lN(Ze, se),
            C =
              ((ne = Object.keys(x.added)) === null || ne === void 0 ? void 0 : ne.length) <= 2
                ? (le =
                    (Te = Object.entries(x.added)) === null || Te === void 0 ? void 0 : Te[0]) ===
                    null || le === void 0
                  ? void 0
                  : le[1][0]
                : void 0
          if (li) _t(se), jr(!1), i && Xo(C), Go && clearTimeout(Go)
          else if (Hs) _t(se), jr(!1), i && Xo(C)
          else {
            $2(se) && Jn !== void 0 ? hr(C) : $2(se) ? hr(void 0) : hr('b'), bt(x), jr(!0)
            const _ = setTimeout(() => {
              _t(se), jr(!1), i && Xo(C)
            }, t)
            er(_)
          }
          return (
            Mr(!1),
            F(se),
            Lr(),
            () => {
              clearTimeout(Go)
            }
          )
        }, [Ie])
      const {
        arrows: $i,
        newArrow: ci,
        clearArrows: Lr,
        drawNewArrow: ui,
        onArrowDrawEnd: Yo,
      } = hN(u, n, V, f)
      function Qo(ne, Te, le, se) {
        if (ne === Te) return
        if (
          (Lr(),
          (i && li) ||
            (i && (Jn === le[0] || mn.current.filter((C) => C.piece[0] === le[0]).length > 0)))
        ) {
          const C = [...mn.current]
          C.push({ sourceSq: ne, targetSq: Te, piece: le }), (mn.current = C), gr([...C]), Un()
          return
        }
        if (!i && li) return
        const x = Object.assign({}, Ze)
        Mr(!!se),
          hr(le[0]),
          Me.length
            ? Me(ne, Te, le) || (cs(), Mr(!1))
            : (I === 'trash' && !Te && delete x[ne], delete x[ne], (x[Te] = le), _t(x)),
          Un(),
          F(x)
      }
      function Xo(ne) {
        if (mn.current.length === 0) return
        const Te = mn.current[0]
        if (Te.piece[0] !== void 0 && Te.piece[0] !== ne && Me.length)
          if ((hr(Te.piece[0]), Mr(!0), Me(Te.sourceSq, Te.targetSq, Te.piece))) {
            const se = [...mn.current]
            se.shift(), (mn.current = se), gr([...se])
          } else cs()
      }
      function cs(ne = !0) {
        ne && hr(void 0), (mn.current = []), gr([])
      }
      function Un() {
        ls(null), Ir(null), Tn(!1)
      }
      function j(ne) {
        Nr(ne)
      }
      function $(ne) {
        if (oi) {
          if (oi === ne) {
            Nr(void 0), c && cs(!1), Ae(ne)
            return
          }
        } else Nr(void 0)
      }
      function W() {
        Nr(void 0)
      }
      const te = {
        animationDuration: t,
        arePiecesDraggable: r,
        arePremovesAllowed: i,
        boardOrientation: o,
        boardWidth: a,
        customArrowColor: f,
        customBoardStyle: d,
        customNotationStyle: p,
        customDarkSquareStyle: h,
        customDropSquareStyle: m,
        customLightSquareStyle: b,
        customPremoveDarkSquareStyle: v,
        customPremoveLightSquareStyle: S,
        customSquare: T,
        customSquareStyles: A,
        id: k,
        isDraggablePiece: D,
        onDragOverSquare: ie,
        onMouseOutSquare: de,
        onMouseOverSquare: xe,
        onPieceClick: we,
        onPieceDragBegin: Pe,
        onPieceDragEnd: We,
        onPieceDrop: Me,
        onPromotionCheck: K,
        onPromotionPieceSelect: H,
        onSquareClick: oe,
        showBoardNotation: re,
        snapToCursor: it,
        promotionDialogVariant: fe,
        allowDragOutsideBoard: e,
        arrows: $i,
        newArrow: ci,
        onArrowDrawEnd: Yo,
        chessPieces: Bn,
        clearArrows: Lr,
        drawNewArrow: ui,
        clearCurrentRightClickDown: W,
        currentPosition: Ze,
        handleSetPosition: Qo,
        isWaitingForAnimation: li,
        lastPieceColour: Jn,
        onRightClickDown: j,
        onRightClickUp: $,
        positionDifferences: gn,
        promoteFromSquare: Vs,
        promoteToSquare: pr,
        premoves: Dr,
        setPromoteFromSquare: ls,
        setPromoteToSquare: Ir,
        setShowPromoteDialog: Tn,
        showPromoteDialog: si,
        autoPromoteToQueen: s,
        currentRightClickDown: oi,
        lastSquareDraggedOver: ji,
        setLastSquareDraggedOver: Li,
      }
      return E.jsx(E_.Provider, Object.assign({ value: te }, { children: l }))
    }
  )
function gN({ row: e, col: t }) {
  const {
      boardOrientation: n,
      boardWidth: r,
      customDarkSquareStyle: i,
      customLightSquareStyle: s,
      customNotationStyle: o,
    } = Us(),
    a = s.backgroundColor,
    l = i.backgroundColor,
    c = t === 0,
    u = e === 7,
    f = c && u
  function d() {
    return n === 'white' ? 8 - e : e + 1
  }
  function p() {
    return n === 'black' ? mf[7 - t] : mf[t]
  }
  function h() {
    return E.jsxs(E.Fragment, {
      children: [
        E.jsx(
          'div',
          Object.assign(
            {
              style: Object.assign(
                Object.assign({ zIndex: 3, position: 'absolute' }, { color: a }),
                U2(r, o)
              ),
            },
            { children: d() }
          )
        ),
        E.jsx(
          'div',
          Object.assign(
            {
              style: Object.assign(
                Object.assign({ zIndex: 3, position: 'absolute' }, { color: a }),
                B2(r, o)
              ),
            },
            { children: p() }
          )
        ),
      ],
    })
  }
  function m() {
    return E.jsx(
      'div',
      Object.assign(
        {
          style: Object.assign(
            Object.assign(
              { userSelect: 'none', zIndex: 3, position: 'absolute' },
              { color: t % 2 !== 0 ? l : a }
            ),
            B2(r, o)
          ),
        },
        { children: p() }
      )
    )
  }
  function b() {
    return E.jsx(
      'div',
      Object.assign(
        {
          style: Object.assign(
            Object.assign(
              { userSelect: 'none', zIndex: 3, position: 'absolute' },
              n === 'black' ? { color: e % 2 === 0 ? l : a } : { color: e % 2 === 0 ? l : a }
            ),
            U2(r, o)
          ),
        },
        { children: d() }
      )
    )
  }
  return f ? h() : u ? m() : c ? b() : null
}
const B2 = (e, t) =>
    Object.assign({ alignSelf: 'flex-end', paddingLeft: e / 8 - e / 48, fontSize: e / 48 }, t),
  U2 = (e, t) =>
    Object.assign({ alignSelf: 'flex-start', paddingRight: e / 8 - e / 48, fontSize: e / 48 }, t)
function z2({ isPremovedPiece: e = !1, piece: t, square: n, squares: r }) {
  const {
      animationDuration: i,
      arePiecesDraggable: s,
      boardWidth: o,
      boardOrientation: a,
      chessPieces: l,
      currentPosition: c,
      id: u,
      isDraggablePiece: f,
      isWaitingForAnimation: d,
      onPieceClick: p,
      onPieceDragBegin: h,
      onPieceDragEnd: m,
      positionDifferences: b,
      onPromotionCheck: y,
    } = Us(),
    [v, S] = w.useState({
      opacity: 1,
      zIndex: 5,
      touchAction: 'none',
      cursor: s && f({ piece: t, sourceSquare: n }) ? '-webkit-grab' : 'default',
    }),
    [{ canDrag: T, isDragging: A }, I, k] = ED(
      () => ({
        type: 'piece',
        item: () => (h(t, n), { piece: t, square: n, id: u }),
        end: () => m(t, n),
        collect: (F) => ({
          canDrag: f({ piece: t, sourceSquare: n }),
          isDragging: !!F.isDragging(),
        }),
      }),
      [t, n, c, u]
    )
  k(qD(), { captureDraggingState: !0 }),
    w.useEffect(() => {
      S((F) => Object.assign(Object.assign({}, F), { opacity: A ? 0 : 1 }))
    }, [A]),
    w.useEffect(() => {
      var F
      const V = (F = b.removed) === null || F === void 0 ? void 0 : F[n]
      if (!b.added || !V) return
      const ie = Object.entries(b.added).find(([de, xe]) => xe === V || y(n, de, V))
      if (d && V && ie && !e) {
        const de = n,
          xe = ie[0]
        if (de && xe) {
          const we = o / 8
          S((Pe) =>
            Object.assign(Object.assign({}, Pe), {
              transform: `translate(${
                (a === 'black' ? -1 : 1) * (xe.charCodeAt(0) - de.charCodeAt(0)) * we
              }px, ${(a === 'black' ? -1 : 1) * (Number(de[1]) - Number(xe[1])) * we}px)`,
              transition: `transform ${i}ms`,
              zIndex: 6,
            })
          )
        }
      }
    }, [b]),
    w.useEffect(() => {
      const { sourceSq: F } = D()
      F &&
        S((V) =>
          Object.assign(Object.assign({}, V), {
            transform: 'translate(0px, 0px)',
            transition: 'transform 0ms',
          })
        )
    }, [c]),
    w.useEffect(() => {
      S((F) =>
        Object.assign(Object.assign({}, F), {
          cursor: s && f({ piece: t, sourceSquare: n }) ? '-webkit-grab' : 'default',
        })
      )
    }, [n, c, s])
  function D() {
    return { sourceSq: r[n] }
  }
  return E.jsx(
    'div',
    Object.assign(
      { ref: s && T ? I : null, onClick: () => p(t, n), 'data-piece': t, style: v },
      {
        children:
          typeof l[t] == 'function'
            ? l[t]({ squareWidth: o / 8, isDragging: A, square: n })
            : E.jsx(
                'svg',
                Object.assign(
                  {
                    viewBox: '1 1 43 43',
                    width: o / 8,
                    height: o / 8,
                    style: { display: 'block' },
                  },
                  { children: E.jsx('g', { children: l[t] }) }
                )
              ),
      }
    )
  )
}
function mN({ square: e, squareColor: t, setSquares: n, squareHasPremove: r, children: i }) {
  const s = w.useRef(null),
    {
      autoPromoteToQueen: o,
      boardWidth: a,
      boardOrientation: l,
      clearArrows: c,
      currentPosition: u,
      currentRightClickDown: f,
      customBoardStyle: d,
      customDarkSquareStyle: p,
      customDropSquareStyle: h,
      customLightSquareStyle: m,
      customPremoveDarkSquareStyle: b,
      customPremoveLightSquareStyle: y,
      customSquare: v,
      customSquareStyles: S,
      drawNewArrow: T,
      handleSetPosition: A,
      isWaitingForAnimation: I,
      lastPieceColour: k,
      lastSquareDraggedOver: D,
      onArrowDrawEnd: F,
      onDragOverSquare: V,
      onMouseOutSquare: ie,
      onMouseOverSquare: de,
      onPieceDrop: xe,
      onPromotionCheck: we,
      onRightClickDown: Pe,
      onRightClickUp: We,
      onSquareClick: Me,
      setLastSquareDraggedOver: K,
      setPromoteFromSquare: H,
      setPromoteToSquare: oe,
      setShowPromoteDialog: Ae,
    } = Us(),
    [{ isOver: Ie }, fe] = ID(
      () => ({ accept: 'piece', drop: _e, collect: (Z) => ({ isOver: !!Z.isOver() }) }),
      [e, u, xe, I, k]
    )
  function _e(Z) {
    we(Z.square, e, Z.piece)
      ? o
        ? A(Z.square, e, Z.piece[0] === 'w' ? 'wQ' : 'bQ')
        : (H(Z.square), oe(e), Ae(!0))
      : A(Z.square, e, Z.piece, !0)
  }
  w.useEffect(() => {
    if (s.current) {
      const { x: Z, y: it } = s.current.getBoundingClientRect()
      n((wt) => Object.assign(Object.assign({}, wt), { [e]: { x: Z, y: it } }))
    }
  }, [a, l])
  const re = Object.assign(
    Object.assign(
      Object.assign(Object.assign({}, yN(e, l, d)), t === 'black' ? p : m),
      r && (t === 'black' ? b : y)
    ),
    Ie && h
  )
  return E.jsx(
    'div',
    Object.assign(
      {
        ref: fe,
        style: re,
        'data-square-color': t,
        'data-square': e,
        onTouchMove: (Z) => {
          var it
          const wt = Z.touches[0],
            Ze = document.elementsFromPoint(wt.clientX, wt.clientY),
            _t =
              (it = Ze == null ? void 0 : Ze.find((gn) => gn.getAttribute('data-square'))) ===
                null || it === void 0
                ? void 0
                : it.getAttribute('data-square')
          _t && _t !== D && (K(_t), V(_t))
        },
        onMouseOver: (Z) => {
          Z.buttons === 2 && f && T(f, e),
            !(Z.relatedTarget && Z.currentTarget.contains(Z.relatedTarget)) && de(e)
        },
        onMouseOut: (Z) => {
          ;(Z.relatedTarget && Z.currentTarget.contains(Z.relatedTarget)) || ie(e)
        },
        onMouseDown: (Z) => {
          Z.button === 2 && Pe(e)
        },
        onMouseUp: (Z) => {
          Z.button === 2 && (f && F(f, e), We(e))
        },
        onDragEnter: () => V(e),
        onClick: () => {
          const Z = u[e]
          Me(e, Z), c()
        },
        onContextMenu: (Z) => {
          Z.preventDefault()
        },
      },
      {
        children:
          typeof v == 'string'
            ? E.jsx(
                v,
                Object.assign(
                  {
                    ref: s,
                    style: Object.assign(
                      Object.assign(Object.assign({}, V2(a)), W2),
                      !r && (S == null ? void 0 : S[e])
                    ),
                  },
                  { children: i }
                )
              )
            : E.jsx(
                v,
                Object.assign(
                  {
                    ref: s,
                    square: e,
                    squareColor: t,
                    style: Object.assign(
                      Object.assign(Object.assign({}, V2(a)), W2),
                      !r && (S == null ? void 0 : S[e])
                    ),
                  },
                  { children: i }
                )
              ),
      }
    )
  )
}
const W2 = { display: 'flex', justifyContent: 'center' },
  V2 = (e) => ({ width: e / 8, height: e / 8 }),
  yN = (e, t, n) =>
    n != null && n.borderRadius
      ? e === 'a1'
        ? t === 'white'
          ? { borderBottomLeftRadius: n.borderRadius }
          : { borderTopRightRadius: n.borderRadius }
        : e === 'a8'
        ? t === 'white'
          ? { borderTopLeftRadius: n.borderRadius }
          : { borderBottomRightRadius: n.borderRadius }
        : e === 'h1'
        ? t === 'white'
          ? { borderBottomRightRadius: n.borderRadius }
          : { borderTopLeftRadius: n.borderRadius }
        : e === 'h8'
        ? t === 'white'
          ? { borderTopRightRadius: n.borderRadius }
          : { borderBottomLeftRadius: n.borderRadius }
        : {}
      : {}
function vN() {
  const [e, t] = w.useState({}),
    {
      arePremovesAllowed: n,
      boardOrientation: r,
      boardWidth: i,
      currentPosition: s,
      id: o,
      premoves: a,
      showBoardNotation: l,
    } = Us(),
    c = w.useMemo(() => {
      const u = []
      return n
        ? (a.forEach((f, d) => {
            const { sourceSq: p, targetSq: h, piece: m } = f,
              b = u.find((y) => {
                var v
                return (
                  y.piece === m &&
                  ((v = y.premovesRoute.at(-1)) === null || v === void 0 ? void 0 : v.targetSq) ===
                    p
                )
              })
            b
              ? b.premovesRoute.push({ sourceSq: p, targetSq: h, index: d })
              : u.push({ piece: m, premovesRoute: [{ sourceSq: p, targetSq: h, index: d }] })
          }),
          u)
        : []
    }, [a])
  return E.jsx(
    'div',
    Object.assign(
      { 'data-boardid': o },
      {
        children: [...Array(8)].map((u, f) =>
          E.jsx(
            'div',
            Object.assign(
              { style: { display: 'flex', flexWrap: 'nowrap', width: i } },
              {
                children: [...Array(8)].map((d, p) => {
                  const h = r === 'black' ? mf[7 - p] + (f + 1) : mf[p] + (8 - f),
                    m = p % 2 === f % 2 ? 'white' : 'black',
                    b = a.find((v) => v.sourceSq === h || v.targetSq === h),
                    y = c
                      .filter(({ premovesRoute: v }) => {
                        var S
                        return ((S = v.at(-1)) === null || S === void 0 ? void 0 : S.targetSq) === h
                      })
                      .sort((v, S) => {
                        var T, A
                        return (
                          ((T = S.premovesRoute.at(-1)) === null || T === void 0
                            ? void 0
                            : T.index) -
                          ((A = v.premovesRoute.at(-1)) === null || A === void 0 ? void 0 : A.index)
                        )
                      })
                      .at(0)
                  return E.jsxs(
                    mN,
                    Object.assign(
                      { square: h, squareColor: m, setSquares: t, squareHasPremove: !!b },
                      {
                        children: [
                          !b && s[h] && E.jsx(z2, { piece: s[h], square: h, squares: e }),
                          y &&
                            E.jsx(z2, {
                              isPremovedPiece: !0,
                              piece: y.piece,
                              square: h,
                              squares: e,
                            }),
                          l && E.jsx(gN, { row: f, col: p }),
                        ],
                      }
                    ),
                    `${p}${f}`
                  )
                }),
              }
            ),
            f.toString()
          )
        ),
      }
    )
  )
}
const wN = () => {
  const { arrows: e, newArrow: t, boardOrientation: n, boardWidth: r, customArrowColor: i } = Us(),
    s = [...e, t].filter(Boolean)
  return E.jsx(
    'svg',
    Object.assign(
      {
        width: r,
        height: r,
        style: { position: 'absolute', top: '0', left: '0', pointerEvents: 'none', zIndex: '10' },
      },
      {
        children: s.map((o, a) => {
          const [l, c, u] = o
          if (l === c) return null
          const f = Yy(n, r, l),
            d = Yy(n, r, c)
          let p = r / 32
          const h = a === e.length
          e.some((S) => S[0] !== l && S[1] === c) && !h && (p = r / 16)
          const m = d.x - f.x,
            b = d.y - f.y,
            y = Math.hypot(b, m),
            v = { x: f.x + (m * (y - p)) / y, y: f.y + (b * (y - p)) / y }
          return E.jsxs(
            w.Fragment,
            {
              children: [
                E.jsx(
                  'marker',
                  Object.assign(
                    {
                      id: `arrowhead-${a}`,
                      markerWidth: '2',
                      markerHeight: '2.5',
                      refX: '1.25',
                      refY: '1.25',
                      orient: 'auto',
                    },
                    {
                      children: E.jsx('polygon', {
                        points: '0.3 0, 2 1.25, 0.3 2.5',
                        fill: u ?? i,
                      }),
                    }
                  )
                ),
                E.jsx('line', {
                  x1: f.x,
                  y1: f.y,
                  x2: v.x,
                  y2: v.y,
                  opacity: h ? '0.5' : '0.65',
                  stroke: u ?? i,
                  strokeWidth: h ? (0.9 * r) / 40 : r / 40,
                  markerEnd: `url(#arrowhead-${a})`,
                }),
              ],
            },
            `${l}-${c}${h ? '-active' : ''}`
          )
        }),
      }
    )
  )
}
function bN({ option: e }) {
  const [t, n] = w.useState(!1),
    {
      boardWidth: r,
      chessPieces: i,
      customDarkSquareStyle: s,
      customLightSquareStyle: o,
      handleSetPosition: a,
      onPromotionPieceSelect: l,
      promoteFromSquare: c,
      promoteToSquare: u,
      promotionDialogVariant: f,
    } = Us(),
    d = () => {
      switch (e[1]) {
        case 'Q':
          return s.backgroundColor
        case 'R':
          return o.backgroundColor
        case 'N':
          return f === 'default' ? o.backgroundColor : s.backgroundColor
        case 'B':
          return f === 'default' ? s.backgroundColor : o.backgroundColor
      }
    }
  return E.jsx(
    'div',
    Object.assign(
      {
        onClick: () => {
          l(e, c ?? void 0, u ?? void 0) && a(c, u, e, !0)
        },
        onMouseOver: () => n(!0),
        onMouseOut: () => n(!1),
        'data-piece': e,
        style: {
          cursor: 'pointer',
          backgroundColor: t ? d() : `${d()}aa`,
          borderRadius: '4px',
          transition: 'all 0.1s ease-out',
        },
      },
      {
        children:
          typeof i[e] == 'function'
            ? E.jsx(
                'div',
                Object.assign(
                  {
                    style: {
                      transition: 'all 0.1s ease-out',
                      transform: t ? 'scale(1)' : 'scale(0.85)',
                    },
                  },
                  { children: i[e]({ squareWidth: r / 8, isDragging: !1 }) }
                )
              )
            : E.jsx(
                'svg',
                Object.assign(
                  {
                    viewBox: '1 1 43 43',
                    width: r / 8,
                    height: r / 8,
                    style: {
                      transition: 'all 0.1s ease-out',
                      transform: t ? 'scale(1)' : 'scale(0.85)',
                    },
                  },
                  { children: E.jsx('g', { children: i[e] }) }
                )
              ),
      }
    )
  )
}
function xN() {
  const {
      boardOrientation: e,
      boardWidth: t,
      promotionDialogVariant: n,
      promoteToSquare: r,
    } = Us(),
    i = (r == null ? void 0 : r[1]) === '1' ? 'b' : 'w',
    s = [`${i ?? 'w'}Q`, `${i ?? 'w'}R`, `${i ?? 'w'}N`, `${i ?? 'w'}B`],
    o = {
      default: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        transform: `translate(${-t / 8}px, ${-t / 8}px)`,
      },
      vertical: { transform: `translate(${-t / 16}px, ${-t / 16}px)` },
      modal: {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(0px, ${(3 * t) / 8}px)`,
        width: '100%',
        height: `${t / 4}px`,
        top: 0,
        backgroundColor: 'white',
        left: 0,
      },
    },
    a = Yy(e, t, r || 'a8')
  return E.jsx(
    'div',
    Object.assign(
      {
        style: Object.assign(
          {
            position: 'absolute',
            top: `${a == null ? void 0 : a.y}px`,
            left: `${a == null ? void 0 : a.x}px`,
            zIndex: 1e3,
          },
          o[n]
        ),
        title: 'Choose promotion piece',
      },
      { children: s.map((l) => E.jsx(bN, { option: l }, l)) }
    )
  )
}
const SN = {
  whiteKing: E.jsx(
    'svg',
    Object.assign(
      {
        xmlns: 'http://www.w3.org/2000/svg',
        version: '1.1',
        style: {
          shapeRendering: 'geometricPrecision',
          textRendering: 'geometricPrecision',
          imageRendering: 'crisp-edges',
        },
        viewBox: '0 0 4210 12970',
        x: '0px',
        y: '0px',
        fillRule: 'evenodd',
        clipRule: 'evenodd',
        width: '250',
        height: '250',
      },
      {
        children: E.jsx('g', {
          children: E.jsx('path', {
            style: { fill: 'black', fillRule: 'nonzero' },
            d: 'M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z',
          }),
        }),
      }
    )
  ),
}
function EN({ children: e }) {
  try {
    return E.jsx(E.Fragment, { children: e })
  } catch (t) {
    return console.log(t), E.jsx(C_, { showError: !0 })
  }
}
function C_({ showError: e = !1 }) {
  return E.jsxs(
    'div',
    Object.assign(
      {
        style: {
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          flexDirection: 'column',
        },
      },
      {
        children: [
          E.jsx(
            'div',
            Object.assign(
              { style: { width: 250, height: 250, transform: 'rotate(90deg)' } },
              { children: SN.whiteKing }
            )
          ),
          e && E.jsx('h1', { children: 'Something went wrong' }),
        ],
      }
    )
  )
}
function CN() {
  const e = w.useRef(null),
    {
      boardWidth: t,
      clearCurrentRightClickDown: n,
      onPromotionPieceSelect: r,
      setShowPromoteDialog: i,
      showPromoteDialog: s,
      customBoardStyle: o,
    } = Us()
  return (
    w.useEffect(() => {
      function a(l) {
        e.current && !e.current.contains(l.target) && n()
      }
      return (
        document.addEventListener('mouseup', a),
        () => {
          document.removeEventListener('mouseup', a)
        }
      )
    }, []),
    t
      ? E.jsx(
          'div',
          Object.assign(
            { style: { perspective: '1000px' } },
            {
              children: E.jsxs(
                'div',
                Object.assign(
                  {
                    ref: e,
                    style: Object.assign(Object.assign({ position: 'relative' }, _N(t)), o),
                  },
                  {
                    children: [
                      E.jsx(vN, {}),
                      E.jsx(wN, {}),
                      s &&
                        E.jsxs(E.Fragment, {
                          children: [
                            E.jsx('div', {
                              onClick: () => {
                                i(!1), r == null || r()
                              },
                              style: {
                                position: 'absolute',
                                top: '0',
                                left: '0',
                                zIndex: '100',
                                backgroundColor: 'rgba(22,21,18,.7)',
                                width: t,
                                height: t,
                              },
                            }),
                            E.jsx(xN, {}),
                          ],
                        }),
                    ],
                  }
                )
              ),
            }
          )
        )
      : E.jsx(C_, {})
  )
}
const _N = (e) => ({ cursor: 'default', height: e, width: e })
function ON({ boardContainer: e }) {
  const { boardWidth: t, chessPieces: n, id: r, snapToCursor: i, allowDragOutsideBoard: s } = Us(),
    o = CD((d) => ({
      item: d.getItem(),
      clientOffset: d.getClientOffset(),
      sourceClientOffset: d.getSourceClientOffset(),
      isDragging: d.isDragging(),
    })),
    { isDragging: a, item: l, clientOffset: c, sourceClientOffset: u } = o,
    f = w.useCallback(
      (d, p) => {
        if (!d || !p) return { display: 'none' }
        let { x: h, y: m } = i ? d : p
        const b = t / 8 / 2
        if ((i && ((h -= b), (m -= b)), !s)) {
          const { left: v, top: S } = e,
            T = v - b,
            A = S - b,
            I = v + t - b,
            k = S + t - b
          ;(h = Math.max(T, Math.min(h, I))), (m = Math.max(A, Math.min(m, k)))
        }
        const y = `translate(${h}px, ${m}px)`
        return { transform: y, WebkitTransform: y, touchAction: 'none' }
      },
      [t, s, i, e]
    )
  return a && l.id === r
    ? E.jsx(
        'div',
        Object.assign(
          { style: { position: 'fixed', pointerEvents: 'none', zIndex: 10, left: 0, top: 0 } },
          {
            children: E.jsx(
              'div',
              Object.assign(
                { style: f(c, u) },
                {
                  children:
                    typeof n[l.piece] == 'function'
                      ? n[l.piece]({ squareWidth: t / 8, isDragging: !0 })
                      : E.jsx(
                          'svg',
                          Object.assign(
                            { viewBox: '1 1 43 43', width: t / 8, height: t / 8 },
                            { children: E.jsx('g', { children: n[l.piece] }) }
                          )
                        ),
                }
              )
            ),
          }
        )
      )
    : null
}
const kN = w.forwardRef((e, t) => {
    const { customDndBackend: n, customDndBackendOptions: r } = e,
      i = $I(e, ['customDndBackend', 'customDndBackendOptions']),
      [s, o] = w.useState(),
      [a, l] = w.useState(!1),
      [c, u] = w.useState(!1),
      [f, d] = w.useState(e.boardWidth),
      p = w.useRef(null),
      h = w.useRef(null),
      [m, b] = w.useState({ left: 0, top: 0 }),
      y = w.useMemo(() => {
        var S
        return (S = p.current) === null || S === void 0 ? void 0 : S.getBoundingClientRect()
      }, [p.current])
    w.useEffect(() => {
      b({
        left: y != null && y.left ? (y == null ? void 0 : y.left) : 0,
        top: y != null && y.top ? (y == null ? void 0 : y.top) : 0,
      })
    }, [y]),
      w.useEffect(() => {
        u('ontouchstart' in window), l(!0), o(window)
      }, []),
      w.useEffect(() => {
        var S
        if (
          e.boardWidth === void 0 &&
          !((S = p.current) === null || S === void 0) &&
          S.offsetWidth
        ) {
          const T = new ResizeObserver(() => {
            var A
            d((A = p.current) === null || A === void 0 ? void 0 : A.offsetWidth)
          })
          return (
            T.observe(p.current),
            () => {
              T.disconnect()
            }
          )
        }
      }, [p.current, s])
    const v = n || (c ? rN : KD)
    return a && s
      ? E.jsx(EN, {
          children: E.jsxs(
            'div',
            Object.assign(
              { ref: h, style: { display: 'flex', flexDirection: 'column', width: '100%' } },
              {
                children: [
                  E.jsx('div', { ref: p, style: { width: '100%' } }),
                  E.jsx(
                    tD,
                    Object.assign(
                      { backend: v, context: s, options: n ? r : void 0 },
                      {
                        children:
                          f &&
                          E.jsxs(
                            pN,
                            Object.assign(
                              { boardWidth: f },
                              i,
                              { ref: t },
                              { children: [E.jsx(ON, { boardContainer: m }), E.jsx(CN, {})] }
                            )
                          ),
                      }
                    )
                  ),
                ],
              }
            )
          ),
        })
      : null
  }),
  TN = /^((?:.){4}).+((?:.){4})$/,
  hs = (e, t) => {
    const n = e.match(TN)
    return n ? `${n[1]}...${n[2]}` : t ? e : n
  }
function __(e, t) {
  return function () {
    return e.apply(t, arguments)
  }
}
const { toString: AN } = Object.prototype,
  { getPrototypeOf: Ew } = Object,
  V0 = ((e) => (t) => {
    const n = AN.call(t)
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
  })(Object.create(null)),
  Mi = (e) => ((e = e.toLowerCase()), (t) => V0(t) === e),
  H0 = (e) => (t) => typeof t === e,
  { isArray: Lc } = Array,
  yf = H0('undefined')
function RN(e) {
  return (
    e !== null &&
    !yf(e) &&
    e.constructor !== null &&
    !yf(e.constructor) &&
    Jr(e.constructor.isBuffer) &&
    e.constructor.isBuffer(e)
  )
}
const O_ = Mi('ArrayBuffer')
function PN(e) {
  let t
  return (
    typeof ArrayBuffer < 'u' && ArrayBuffer.isView
      ? (t = ArrayBuffer.isView(e))
      : (t = e && e.buffer && O_(e.buffer)),
    t
  )
}
const IN = H0('string'),
  Jr = H0('function'),
  k_ = H0('number'),
  q0 = (e) => e !== null && typeof e == 'object',
  DN = (e) => e === !0 || e === !1,
  bh = (e) => {
    if (V0(e) !== 'object') return !1
    const t = Ew(e)
    return (
      (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) &&
      !(Symbol.toStringTag in e) &&
      !(Symbol.iterator in e)
    )
  },
  NN = Mi('Date'),
  MN = Mi('File'),
  jN = Mi('Blob'),
  LN = Mi('FileList'),
  $N = (e) => q0(e) && Jr(e.pipe),
  FN = (e) => {
    let t
    return (
      e &&
      ((typeof FormData == 'function' && e instanceof FormData) ||
        (Jr(e.append) &&
          ((t = V0(e)) === 'formdata' ||
            (t === 'object' && Jr(e.toString) && e.toString() === '[object FormData]'))))
    )
  },
  BN = Mi('URLSearchParams'),
  [UN, zN, WN, VN] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(Mi),
  HN = (e) => (e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''))
function Jf(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > 'u') return
  let r, i
  if ((typeof e != 'object' && (e = [e]), Lc(e)))
    for (r = 0, i = e.length; r < i; r++) t.call(null, e[r], r, e)
  else {
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e),
      o = s.length
    let a
    for (r = 0; r < o; r++) (a = s[r]), t.call(null, e[a], a, e)
  }
}
function T_(e, t) {
  t = t.toLowerCase()
  const n = Object.keys(e)
  let r = n.length,
    i
  for (; r-- > 0; ) if (((i = n[r]), t === i.toLowerCase())) return i
  return null
}
const A_ = (() =>
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
      ? self
      : typeof window < 'u'
      ? window
      : global)(),
  R_ = (e) => !yf(e) && e !== A_
function Qy() {
  const { caseless: e } = (R_(this) && this) || {},
    t = {},
    n = (r, i) => {
      const s = (e && T_(t, i)) || i
      bh(t[s]) && bh(r)
        ? (t[s] = Qy(t[s], r))
        : bh(r)
        ? (t[s] = Qy({}, r))
        : Lc(r)
        ? (t[s] = r.slice())
        : (t[s] = r)
    }
  for (let r = 0, i = arguments.length; r < i; r++) arguments[r] && Jf(arguments[r], n)
  return t
}
const qN = (e, t, n, { allOwnKeys: r } = {}) => (
    Jf(
      t,
      (i, s) => {
        n && Jr(i) ? (e[s] = __(i, n)) : (e[s] = i)
      },
      { allOwnKeys: r }
    ),
    e
  ),
  KN = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e),
  GN = (e, t, n, r) => {
    ;(e.prototype = Object.create(t.prototype, r)),
      (e.prototype.constructor = e),
      Object.defineProperty(e, 'super', { value: t.prototype }),
      n && Object.assign(e.prototype, n)
  },
  YN = (e, t, n, r) => {
    let i, s, o
    const a = {}
    if (((t = t || {}), e == null)) return t
    do {
      for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
        (o = i[s]), (!r || r(o, e, t)) && !a[o] && ((t[o] = e[o]), (a[o] = !0))
      e = n !== !1 && Ew(e)
    } while (e && (!n || n(e, t)) && e !== Object.prototype)
    return t
  },
  QN = (e, t, n) => {
    ;(e = String(e)), (n === void 0 || n > e.length) && (n = e.length), (n -= t.length)
    const r = e.indexOf(t, n)
    return r !== -1 && r === n
  },
  XN = (e) => {
    if (!e) return null
    if (Lc(e)) return e
    let t = e.length
    if (!k_(t)) return null
    const n = new Array(t)
    for (; t-- > 0; ) n[t] = e[t]
    return n
  },
  ZN = (
    (e) => (t) =>
      e && t instanceof e
  )(typeof Uint8Array < 'u' && Ew(Uint8Array)),
  JN = (e, t) => {
    const r = (e && e[Symbol.iterator]).call(e)
    let i
    for (; (i = r.next()) && !i.done; ) {
      const s = i.value
      t.call(e, s[0], s[1])
    }
  },
  eM = (e, t) => {
    let n
    const r = []
    for (; (n = e.exec(t)) !== null; ) r.push(n)
    return r
  },
  tM = Mi('HTMLFormElement'),
  nM = (e) =>
    e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, r, i) {
      return r.toUpperCase() + i
    }),
  H2 = (
    ({ hasOwnProperty: e }) =>
    (t, n) =>
      e.call(t, n)
  )(Object.prototype),
  rM = Mi('RegExp'),
  P_ = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e),
      r = {}
    Jf(n, (i, s) => {
      let o
      ;(o = t(i, s, e)) !== !1 && (r[s] = o || i)
    }),
      Object.defineProperties(e, r)
  },
  iM = (e) => {
    P_(e, (t, n) => {
      if (Jr(e) && ['arguments', 'caller', 'callee'].indexOf(n) !== -1) return !1
      const r = e[n]
      if (Jr(r)) {
        if (((t.enumerable = !1), 'writable' in t)) {
          t.writable = !1
          return
        }
        t.set ||
          (t.set = () => {
            throw Error("Can not rewrite read-only method '" + n + "'")
          })
      }
    })
  },
  sM = (e, t) => {
    const n = {},
      r = (i) => {
        i.forEach((s) => {
          n[s] = !0
        })
      }
    return Lc(e) ? r(e) : r(String(e).split(t)), n
  },
  oM = () => {},
  aM = (e, t) => (e != null && Number.isFinite((e = +e)) ? e : t),
  lm = 'abcdefghijklmnopqrstuvwxyz',
  q2 = '0123456789',
  I_ = { DIGIT: q2, ALPHA: lm, ALPHA_DIGIT: lm + lm.toUpperCase() + q2 },
  lM = (e = 16, t = I_.ALPHA_DIGIT) => {
    let n = ''
    const { length: r } = t
    for (; e--; ) n += t[(Math.random() * r) | 0]
    return n
  }
function cM(e) {
  return !!(e && Jr(e.append) && e[Symbol.toStringTag] === 'FormData' && e[Symbol.iterator])
}
const uM = (e) => {
    const t = new Array(10),
      n = (r, i) => {
        if (q0(r)) {
          if (t.indexOf(r) >= 0) return
          if (!('toJSON' in r)) {
            t[i] = r
            const s = Lc(r) ? [] : {}
            return (
              Jf(r, (o, a) => {
                const l = n(o, i + 1)
                !yf(l) && (s[a] = l)
              }),
              (t[i] = void 0),
              s
            )
          }
        }
        return r
      }
    return n(e, 0)
  },
  fM = Mi('AsyncFunction'),
  dM = (e) => e && (q0(e) || Jr(e)) && Jr(e.then) && Jr(e.catch),
  z = {
    isArray: Lc,
    isArrayBuffer: O_,
    isBuffer: RN,
    isFormData: FN,
    isArrayBufferView: PN,
    isString: IN,
    isNumber: k_,
    isBoolean: DN,
    isObject: q0,
    isPlainObject: bh,
    isReadableStream: UN,
    isRequest: zN,
    isResponse: WN,
    isHeaders: VN,
    isUndefined: yf,
    isDate: NN,
    isFile: MN,
    isBlob: jN,
    isRegExp: rM,
    isFunction: Jr,
    isStream: $N,
    isURLSearchParams: BN,
    isTypedArray: ZN,
    isFileList: LN,
    forEach: Jf,
    merge: Qy,
    extend: qN,
    trim: HN,
    stripBOM: KN,
    inherits: GN,
    toFlatObject: YN,
    kindOf: V0,
    kindOfTest: Mi,
    endsWith: QN,
    toArray: XN,
    forEachEntry: JN,
    matchAll: eM,
    isHTMLForm: tM,
    hasOwnProperty: H2,
    hasOwnProp: H2,
    reduceDescriptors: P_,
    freezeMethods: iM,
    toObjectSet: sM,
    toCamelCase: nM,
    noop: oM,
    toFiniteNumber: aM,
    findKey: T_,
    global: A_,
    isContextDefined: R_,
    ALPHABET: I_,
    generateString: lM,
    isSpecCompliantForm: cM,
    toJSONObject: uM,
    isAsyncFn: fM,
    isThenable: dM,
  }
function Xe(e, t, n, r, i) {
  Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = e),
    (this.name = 'AxiosError'),
    t && (this.code = t),
    n && (this.config = n),
    r && (this.request = r),
    i && (this.response = i)
}
z.inherits(Xe, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: z.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null,
    }
  },
})
const D_ = Xe.prototype,
  N_ = {}
;[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL',
].forEach((e) => {
  N_[e] = { value: e }
})
Object.defineProperties(Xe, N_)
Object.defineProperty(D_, 'isAxiosError', { value: !0 })
Xe.from = (e, t, n, r, i, s) => {
  const o = Object.create(D_)
  return (
    z.toFlatObject(
      e,
      o,
      function (l) {
        return l !== Error.prototype
      },
      (a) => a !== 'isAxiosError'
    ),
    Xe.call(o, e.message, t, n, r, i),
    (o.cause = e),
    (o.name = e.name),
    s && Object.assign(o, s),
    o
  )
}
const hM = null
function Xy(e) {
  return z.isPlainObject(e) || z.isArray(e)
}
function M_(e) {
  return z.endsWith(e, '[]') ? e.slice(0, -2) : e
}
function K2(e, t, n) {
  return e
    ? e
        .concat(t)
        .map(function (i, s) {
          return (i = M_(i)), !n && s ? '[' + i + ']' : i
        })
        .join(n ? '.' : '')
    : t
}
function pM(e) {
  return z.isArray(e) && !e.some(Xy)
}
const gM = z.toFlatObject(z, {}, null, function (t) {
  return /^is[A-Z]/.test(t)
})
function K0(e, t, n) {
  if (!z.isObject(e)) throw new TypeError('target must be an object')
  ;(t = t || new FormData()),
    (n = z.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (m, b) {
      return !z.isUndefined(b[m])
    }))
  const r = n.metaTokens,
    i = n.visitor || u,
    s = n.dots,
    o = n.indexes,
    l = (n.Blob || (typeof Blob < 'u' && Blob)) && z.isSpecCompliantForm(t)
  if (!z.isFunction(i)) throw new TypeError('visitor must be a function')
  function c(h) {
    if (h === null) return ''
    if (z.isDate(h)) return h.toISOString()
    if (!l && z.isBlob(h)) throw new Xe('Blob is not supported. Use a Buffer instead.')
    return z.isArrayBuffer(h) || z.isTypedArray(h)
      ? l && typeof Blob == 'function'
        ? new Blob([h])
        : Buffer.from(h)
      : h
  }
  function u(h, m, b) {
    let y = h
    if (h && !b && typeof h == 'object') {
      if (z.endsWith(m, '{}')) (m = r ? m : m.slice(0, -2)), (h = JSON.stringify(h))
      else if (
        (z.isArray(h) && pM(h)) ||
        ((z.isFileList(h) || z.endsWith(m, '[]')) && (y = z.toArray(h)))
      )
        return (
          (m = M_(m)),
          y.forEach(function (S, T) {
            !(z.isUndefined(S) || S === null) &&
              t.append(o === !0 ? K2([m], T, s) : o === null ? m : m + '[]', c(S))
          }),
          !1
        )
    }
    return Xy(h) ? !0 : (t.append(K2(b, m, s), c(h)), !1)
  }
  const f = [],
    d = Object.assign(gM, { defaultVisitor: u, convertValue: c, isVisitable: Xy })
  function p(h, m) {
    if (!z.isUndefined(h)) {
      if (f.indexOf(h) !== -1) throw Error('Circular reference detected in ' + m.join('.'))
      f.push(h),
        z.forEach(h, function (y, v) {
          ;(!(z.isUndefined(y) || y === null) &&
            i.call(t, y, z.isString(v) ? v.trim() : v, m, d)) === !0 && p(y, m ? m.concat(v) : [v])
        }),
        f.pop()
    }
  }
  if (!z.isObject(e)) throw new TypeError('data must be an object')
  return p(e), t
}
function G2(e) {
  const t = { '!': '%21', "'": '%27', '(': '%28', ')': '%29', '~': '%7E', '%20': '+', '%00': '\0' }
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (r) {
    return t[r]
  })
}
function Cw(e, t) {
  ;(this._pairs = []), e && K0(e, this, t)
}
const j_ = Cw.prototype
j_.append = function (t, n) {
  this._pairs.push([t, n])
}
j_.toString = function (t) {
  const n = t
    ? function (r) {
        return t.call(this, r, G2)
      }
    : G2
  return this._pairs
    .map(function (i) {
      return n(i[0]) + '=' + n(i[1])
    }, '')
    .join('&')
}
function mM(e) {
  return encodeURIComponent(e)
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+')
    .replace(/%5B/gi, '[')
    .replace(/%5D/gi, ']')
}
function L_(e, t, n) {
  if (!t) return e
  const r = (n && n.encode) || mM,
    i = n && n.serialize
  let s
  if (
    (i ? (s = i(t, n)) : (s = z.isURLSearchParams(t) ? t.toString() : new Cw(t, n).toString(r)), s)
  ) {
    const o = e.indexOf('#')
    o !== -1 && (e = e.slice(0, o)), (e += (e.indexOf('?') === -1 ? '?' : '&') + s)
  }
  return e
}
class yM {
  constructor() {
    this.handlers = []
  }
  use(t, n, r) {
    return (
      this.handlers.push({
        fulfilled: t,
        rejected: n,
        synchronous: r ? r.synchronous : !1,
        runWhen: r ? r.runWhen : null,
      }),
      this.handlers.length - 1
    )
  }
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null)
  }
  clear() {
    this.handlers && (this.handlers = [])
  }
  forEach(t) {
    z.forEach(this.handlers, function (r) {
      r !== null && t(r)
    })
  }
}
const Y2 = yM,
  $_ = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 },
  vM = typeof URLSearchParams < 'u' ? URLSearchParams : Cw,
  wM = typeof FormData < 'u' ? FormData : null,
  bM = typeof Blob < 'u' ? Blob : null,
  xM = {
    isBrowser: !0,
    classes: { URLSearchParams: vM, FormData: wM, Blob: bM },
    protocols: ['http', 'https', 'file', 'blob', 'url', 'data'],
  },
  _w = typeof window < 'u' && typeof document < 'u',
  SM = ((e) => _w && ['ReactNative', 'NativeScript', 'NS'].indexOf(e) < 0)(
    typeof navigator < 'u' && navigator.product
  ),
  EM = (() =>
    typeof WorkerGlobalScope < 'u' &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == 'function')(),
  CM = (_w && window.location.href) || 'http://localhost',
  _M = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        hasBrowserEnv: _w,
        hasStandardBrowserEnv: SM,
        hasStandardBrowserWebWorkerEnv: EM,
        origin: CM,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  Ti = { ..._M, ...xM }
function OM(e, t) {
  return K0(
    e,
    new Ti.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (n, r, i, s) {
          return Ti.isNode && z.isBuffer(n)
            ? (this.append(r, n.toString('base64')), !1)
            : s.defaultVisitor.apply(this, arguments)
        },
      },
      t
    )
  )
}
function kM(e) {
  return z.matchAll(/\w+|\[(\w*)]/g, e).map((t) => (t[0] === '[]' ? '' : t[1] || t[0]))
}
function TM(e) {
  const t = {},
    n = Object.keys(e)
  let r
  const i = n.length
  let s
  for (r = 0; r < i; r++) (s = n[r]), (t[s] = e[s])
  return t
}
function F_(e) {
  function t(n, r, i, s) {
    let o = n[s++]
    if (o === '__proto__') return !0
    const a = Number.isFinite(+o),
      l = s >= n.length
    return (
      (o = !o && z.isArray(i) ? i.length : o),
      l
        ? (z.hasOwnProp(i, o) ? (i[o] = [i[o], r]) : (i[o] = r), !a)
        : ((!i[o] || !z.isObject(i[o])) && (i[o] = []),
          t(n, r, i[o], s) && z.isArray(i[o]) && (i[o] = TM(i[o])),
          !a)
    )
  }
  if (z.isFormData(e) && z.isFunction(e.entries)) {
    const n = {}
    return (
      z.forEachEntry(e, (r, i) => {
        t(kM(r), i, n, 0)
      }),
      n
    )
  }
  return null
}
function AM(e, t, n) {
  if (z.isString(e))
    try {
      return (t || JSON.parse)(e), z.trim(e)
    } catch (r) {
      if (r.name !== 'SyntaxError') throw r
    }
  return (n || JSON.stringify)(e)
}
const Ow = {
  transitional: $_,
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [
    function (t, n) {
      const r = n.getContentType() || '',
        i = r.indexOf('application/json') > -1,
        s = z.isObject(t)
      if ((s && z.isHTMLForm(t) && (t = new FormData(t)), z.isFormData(t)))
        return i ? JSON.stringify(F_(t)) : t
      if (
        z.isArrayBuffer(t) ||
        z.isBuffer(t) ||
        z.isStream(t) ||
        z.isFile(t) ||
        z.isBlob(t) ||
        z.isReadableStream(t)
      )
        return t
      if (z.isArrayBufferView(t)) return t.buffer
      if (z.isURLSearchParams(t))
        return n.setContentType('application/x-www-form-urlencoded;charset=utf-8', !1), t.toString()
      let a
      if (s) {
        if (r.indexOf('application/x-www-form-urlencoded') > -1)
          return OM(t, this.formSerializer).toString()
        if ((a = z.isFileList(t)) || r.indexOf('multipart/form-data') > -1) {
          const l = this.env && this.env.FormData
          return K0(a ? { 'files[]': t } : t, l && new l(), this.formSerializer)
        }
      }
      return s || i ? (n.setContentType('application/json', !1), AM(t)) : t
    },
  ],
  transformResponse: [
    function (t) {
      const n = this.transitional || Ow.transitional,
        r = n && n.forcedJSONParsing,
        i = this.responseType === 'json'
      if (z.isResponse(t) || z.isReadableStream(t)) return t
      if (t && z.isString(t) && ((r && !this.responseType) || i)) {
        const o = !(n && n.silentJSONParsing) && i
        try {
          return JSON.parse(t)
        } catch (a) {
          if (o)
            throw a.name === 'SyntaxError'
              ? Xe.from(a, Xe.ERR_BAD_RESPONSE, this, null, this.response)
              : a
        }
      }
      return t
    },
  ],
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: Ti.classes.FormData, Blob: Ti.classes.Blob },
  validateStatus: function (t) {
    return t >= 200 && t < 300
  },
  headers: { common: { Accept: 'application/json, text/plain, */*', 'Content-Type': void 0 } },
}
z.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (e) => {
  Ow.headers[e] = {}
})
const kw = Ow,
  RM = z.toObjectSet([
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent',
  ]),
  PM = (e) => {
    const t = {}
    let n, r, i
    return (
      e &&
        e
          .split(
            `
`
          )
          .forEach(function (o) {
            ;(i = o.indexOf(':')),
              (n = o.substring(0, i).trim().toLowerCase()),
              (r = o.substring(i + 1).trim()),
              !(!n || (t[n] && RM[n])) &&
                (n === 'set-cookie'
                  ? t[n]
                    ? t[n].push(r)
                    : (t[n] = [r])
                  : (t[n] = t[n] ? t[n] + ', ' + r : r))
          }),
      t
    )
  },
  Q2 = Symbol('internals')
function cu(e) {
  return e && String(e).trim().toLowerCase()
}
function xh(e) {
  return e === !1 || e == null ? e : z.isArray(e) ? e.map(xh) : String(e)
}
function IM(e) {
  const t = Object.create(null),
    n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g
  let r
  for (; (r = n.exec(e)); ) t[r[1]] = r[2]
  return t
}
const DM = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())
function cm(e, t, n, r, i) {
  if (z.isFunction(r)) return r.call(this, t, n)
  if ((i && (t = n), !!z.isString(t))) {
    if (z.isString(r)) return t.indexOf(r) !== -1
    if (z.isRegExp(r)) return r.test(t)
  }
}
function NM(e) {
  return e
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r)
}
function MM(e, t) {
  const n = z.toCamelCase(' ' + t)
  ;['get', 'set', 'has'].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function (i, s, o) {
        return this[r].call(this, t, i, s, o)
      },
      configurable: !0,
    })
  })
}
class G0 {
  constructor(t) {
    t && this.set(t)
  }
  set(t, n, r) {
    const i = this
    function s(a, l, c) {
      const u = cu(l)
      if (!u) throw new Error('header name must be a non-empty string')
      const f = z.findKey(i, u)
      ;(!f || i[f] === void 0 || c === !0 || (c === void 0 && i[f] !== !1)) && (i[f || l] = xh(a))
    }
    const o = (a, l) => z.forEach(a, (c, u) => s(c, u, l))
    if (z.isPlainObject(t) || t instanceof this.constructor) o(t, n)
    else if (z.isString(t) && (t = t.trim()) && !DM(t)) o(PM(t), n)
    else if (z.isHeaders(t)) for (const [a, l] of t.entries()) s(l, a, r)
    else t != null && s(n, t, r)
    return this
  }
  get(t, n) {
    if (((t = cu(t)), t)) {
      const r = z.findKey(this, t)
      if (r) {
        const i = this[r]
        if (!n) return i
        if (n === !0) return IM(i)
        if (z.isFunction(n)) return n.call(this, i, r)
        if (z.isRegExp(n)) return n.exec(i)
        throw new TypeError('parser must be boolean|regexp|function')
      }
    }
  }
  has(t, n) {
    if (((t = cu(t)), t)) {
      const r = z.findKey(this, t)
      return !!(r && this[r] !== void 0 && (!n || cm(this, this[r], r, n)))
    }
    return !1
  }
  delete(t, n) {
    const r = this
    let i = !1
    function s(o) {
      if (((o = cu(o)), o)) {
        const a = z.findKey(r, o)
        a && (!n || cm(r, r[a], a, n)) && (delete r[a], (i = !0))
      }
    }
    return z.isArray(t) ? t.forEach(s) : s(t), i
  }
  clear(t) {
    const n = Object.keys(this)
    let r = n.length,
      i = !1
    for (; r--; ) {
      const s = n[r]
      ;(!t || cm(this, this[s], s, t, !0)) && (delete this[s], (i = !0))
    }
    return i
  }
  normalize(t) {
    const n = this,
      r = {}
    return (
      z.forEach(this, (i, s) => {
        const o = z.findKey(r, s)
        if (o) {
          ;(n[o] = xh(i)), delete n[s]
          return
        }
        const a = t ? NM(s) : String(s).trim()
        a !== s && delete n[s], (n[a] = xh(i)), (r[a] = !0)
      }),
      this
    )
  }
  concat(...t) {
    return this.constructor.concat(this, ...t)
  }
  toJSON(t) {
    const n = Object.create(null)
    return (
      z.forEach(this, (r, i) => {
        r != null && r !== !1 && (n[i] = t && z.isArray(r) ? r.join(', ') : r)
      }),
      n
    )
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]()
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ': ' + n).join(`
`)
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders'
  }
  static from(t) {
    return t instanceof this ? t : new this(t)
  }
  static concat(t, ...n) {
    const r = new this(t)
    return n.forEach((i) => r.set(i)), r
  }
  static accessor(t) {
    const r = (this[Q2] = this[Q2] = { accessors: {} }).accessors,
      i = this.prototype
    function s(o) {
      const a = cu(o)
      r[a] || (MM(i, o), (r[a] = !0))
    }
    return z.isArray(t) ? t.forEach(s) : s(t), this
  }
}
G0.accessor([
  'Content-Type',
  'Content-Length',
  'Accept',
  'Accept-Encoding',
  'User-Agent',
  'Authorization',
])
z.reduceDescriptors(G0.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1)
  return {
    get: () => e,
    set(r) {
      this[n] = r
    },
  }
})
z.freezeMethods(G0)
const Ai = G0
function um(e, t) {
  const n = this || kw,
    r = t || n,
    i = Ai.from(r.headers)
  let s = r.data
  return (
    z.forEach(e, function (a) {
      s = a.call(n, s, i.normalize(), t ? t.status : void 0)
    }),
    i.normalize(),
    s
  )
}
function B_(e) {
  return !!(e && e.__CANCEL__)
}
function $c(e, t, n) {
  Xe.call(this, e ?? 'canceled', Xe.ERR_CANCELED, t, n), (this.name = 'CanceledError')
}
z.inherits($c, Xe, { __CANCEL__: !0 })
function U_(e, t, n) {
  const r = n.config.validateStatus
  !n.status || !r || r(n.status)
    ? e(n)
    : t(
        new Xe(
          'Request failed with status code ' + n.status,
          [Xe.ERR_BAD_REQUEST, Xe.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
          n.config,
          n.request,
          n
        )
      )
}
function jM(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e)
  return (t && t[1]) || ''
}
function LM(e, t) {
  e = e || 10
  const n = new Array(e),
    r = new Array(e)
  let i = 0,
    s = 0,
    o
  return (
    (t = t !== void 0 ? t : 1e3),
    function (l) {
      const c = Date.now(),
        u = r[s]
      o || (o = c), (n[i] = l), (r[i] = c)
      let f = s,
        d = 0
      for (; f !== i; ) (d += n[f++]), (f = f % e)
      if (((i = (i + 1) % e), i === s && (s = (s + 1) % e), c - o < t)) return
      const p = u && c - u
      return p ? Math.round((d * 1e3) / p) : void 0
    }
  )
}
function $M(e, t) {
  let n = 0
  const r = 1e3 / t
  let i = null
  return function () {
    const o = this === !0,
      a = Date.now()
    if (o || a - n > r) return i && (clearTimeout(i), (i = null)), (n = a), e.apply(null, arguments)
    i ||
      (i = setTimeout(() => ((i = null), (n = Date.now()), e.apply(null, arguments)), r - (a - n)))
  }
}
const Lp = (e, t, n = 3) => {
    let r = 0
    const i = LM(50, 250)
    return $M((s) => {
      const o = s.loaded,
        a = s.lengthComputable ? s.total : void 0,
        l = o - r,
        c = i(l),
        u = o <= a
      r = o
      const f = {
        loaded: o,
        total: a,
        progress: a ? o / a : void 0,
        bytes: l,
        rate: c || void 0,
        estimated: c && a && u ? (a - o) / c : void 0,
        event: s,
        lengthComputable: a != null,
      }
      ;(f[t ? 'download' : 'upload'] = !0), e(f)
    }, n)
  },
  FM = Ti.hasStandardBrowserEnv
    ? (function () {
        const t = /(msie|trident)/i.test(navigator.userAgent),
          n = document.createElement('a')
        let r
        function i(s) {
          let o = s
          return (
            t && (n.setAttribute('href', o), (o = n.href)),
            n.setAttribute('href', o),
            {
              href: n.href,
              protocol: n.protocol ? n.protocol.replace(/:$/, '') : '',
              host: n.host,
              search: n.search ? n.search.replace(/^\?/, '') : '',
              hash: n.hash ? n.hash.replace(/^#/, '') : '',
              hostname: n.hostname,
              port: n.port,
              pathname: n.pathname.charAt(0) === '/' ? n.pathname : '/' + n.pathname,
            }
          )
        }
        return (
          (r = i(window.location.href)),
          function (o) {
            const a = z.isString(o) ? i(o) : o
            return a.protocol === r.protocol && a.host === r.host
          }
        )
      })()
    : (function () {
        return function () {
          return !0
        }
      })(),
  BM = Ti.hasStandardBrowserEnv
    ? {
        write(e, t, n, r, i, s) {
          const o = [e + '=' + encodeURIComponent(t)]
          z.isNumber(n) && o.push('expires=' + new Date(n).toGMTString()),
            z.isString(r) && o.push('path=' + r),
            z.isString(i) && o.push('domain=' + i),
            s === !0 && o.push('secure'),
            (document.cookie = o.join('; '))
        },
        read(e) {
          const t = document.cookie.match(new RegExp('(^|;\\s*)(' + e + ')=([^;]*)'))
          return t ? decodeURIComponent(t[3]) : null
        },
        remove(e) {
          this.write(e, '', Date.now() - 864e5)
        },
      }
    : {
        write() {},
        read() {
          return null
        },
        remove() {},
      }
function UM(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}
function zM(e, t) {
  return t ? e.replace(/\/?\/$/, '') + '/' + t.replace(/^\/+/, '') : e
}
function z_(e, t) {
  return e && !UM(t) ? zM(e, t) : t
}
const X2 = (e) => (e instanceof Ai ? { ...e } : e)
function Ba(e, t) {
  t = t || {}
  const n = {}
  function r(c, u, f) {
    return z.isPlainObject(c) && z.isPlainObject(u)
      ? z.merge.call({ caseless: f }, c, u)
      : z.isPlainObject(u)
      ? z.merge({}, u)
      : z.isArray(u)
      ? u.slice()
      : u
  }
  function i(c, u, f) {
    if (z.isUndefined(u)) {
      if (!z.isUndefined(c)) return r(void 0, c, f)
    } else return r(c, u, f)
  }
  function s(c, u) {
    if (!z.isUndefined(u)) return r(void 0, u)
  }
  function o(c, u) {
    if (z.isUndefined(u)) {
      if (!z.isUndefined(c)) return r(void 0, c)
    } else return r(void 0, u)
  }
  function a(c, u, f) {
    if (f in t) return r(c, u)
    if (f in e) return r(void 0, c)
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, u) => i(X2(c), X2(u), !0),
  }
  return (
    z.forEach(Object.keys(Object.assign({}, e, t)), function (u) {
      const f = l[u] || i,
        d = f(e[u], t[u], u)
      ;(z.isUndefined(d) && f !== a) || (n[u] = d)
    }),
    n
  )
}
const W_ = (e) => {
    const t = Ba({}, e)
    let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = t
    ;(t.headers = o = Ai.from(o)),
      (t.url = L_(z_(t.baseURL, t.url), e.params, e.paramsSerializer)),
      a &&
        o.set(
          'Authorization',
          'Basic ' +
            btoa(
              (a.username || '') +
                ':' +
                (a.password ? unescape(encodeURIComponent(a.password)) : '')
            )
        )
    let l
    if (z.isFormData(n)) {
      if (Ti.hasStandardBrowserEnv || Ti.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0)
      else if ((l = o.getContentType()) !== !1) {
        const [c, ...u] = l
          ? l
              .split(';')
              .map((f) => f.trim())
              .filter(Boolean)
          : []
        o.setContentType([c || 'multipart/form-data', ...u].join('; '))
      }
    }
    if (
      Ti.hasStandardBrowserEnv &&
      (r && z.isFunction(r) && (r = r(t)), r || (r !== !1 && FM(t.url)))
    ) {
      const c = i && s && BM.read(s)
      c && o.set(i, c)
    }
    return t
  },
  WM = typeof XMLHttpRequest < 'u',
  VM =
    WM &&
    function (e) {
      return new Promise(function (n, r) {
        const i = W_(e)
        let s = i.data
        const o = Ai.from(i.headers).normalize()
        let { responseType: a } = i,
          l
        function c() {
          i.cancelToken && i.cancelToken.unsubscribe(l),
            i.signal && i.signal.removeEventListener('abort', l)
        }
        let u = new XMLHttpRequest()
        u.open(i.method.toUpperCase(), i.url, !0), (u.timeout = i.timeout)
        function f() {
          if (!u) return
          const p = Ai.from('getAllResponseHeaders' in u && u.getAllResponseHeaders()),
            m = {
              data: !a || a === 'text' || a === 'json' ? u.responseText : u.response,
              status: u.status,
              statusText: u.statusText,
              headers: p,
              config: e,
              request: u,
            }
          U_(
            function (y) {
              n(y), c()
            },
            function (y) {
              r(y), c()
            },
            m
          ),
            (u = null)
        }
        'onloadend' in u
          ? (u.onloadend = f)
          : (u.onreadystatechange = function () {
              !u ||
                u.readyState !== 4 ||
                (u.status === 0 && !(u.responseURL && u.responseURL.indexOf('file:') === 0)) ||
                setTimeout(f)
            }),
          (u.onabort = function () {
            u && (r(new Xe('Request aborted', Xe.ECONNABORTED, i, u)), (u = null))
          }),
          (u.onerror = function () {
            r(new Xe('Network Error', Xe.ERR_NETWORK, i, u)), (u = null)
          }),
          (u.ontimeout = function () {
            let h = i.timeout ? 'timeout of ' + i.timeout + 'ms exceeded' : 'timeout exceeded'
            const m = i.transitional || $_
            i.timeoutErrorMessage && (h = i.timeoutErrorMessage),
              r(new Xe(h, m.clarifyTimeoutError ? Xe.ETIMEDOUT : Xe.ECONNABORTED, i, u)),
              (u = null)
          }),
          s === void 0 && o.setContentType(null),
          'setRequestHeader' in u &&
            z.forEach(o.toJSON(), function (h, m) {
              u.setRequestHeader(m, h)
            }),
          z.isUndefined(i.withCredentials) || (u.withCredentials = !!i.withCredentials),
          a && a !== 'json' && (u.responseType = i.responseType),
          typeof i.onDownloadProgress == 'function' &&
            u.addEventListener('progress', Lp(i.onDownloadProgress, !0)),
          typeof i.onUploadProgress == 'function' &&
            u.upload &&
            u.upload.addEventListener('progress', Lp(i.onUploadProgress)),
          (i.cancelToken || i.signal) &&
            ((l = (p) => {
              u && (r(!p || p.type ? new $c(null, e, u) : p), u.abort(), (u = null))
            }),
            i.cancelToken && i.cancelToken.subscribe(l),
            i.signal && (i.signal.aborted ? l() : i.signal.addEventListener('abort', l)))
        const d = jM(i.url)
        if (d && Ti.protocols.indexOf(d) === -1) {
          r(new Xe('Unsupported protocol ' + d + ':', Xe.ERR_BAD_REQUEST, e))
          return
        }
        u.send(s || null)
      })
    },
  HM = (e, t) => {
    let n = new AbortController(),
      r
    const i = function (l) {
      if (!r) {
        ;(r = !0), o()
        const c = l instanceof Error ? l : this.reason
        n.abort(c instanceof Xe ? c : new $c(c instanceof Error ? c.message : c))
      }
    }
    let s =
      t &&
      setTimeout(() => {
        i(new Xe(`timeout ${t} of ms exceeded`, Xe.ETIMEDOUT))
      }, t)
    const o = () => {
      e &&
        (s && clearTimeout(s),
        (s = null),
        e.forEach((l) => {
          l && (l.removeEventListener ? l.removeEventListener('abort', i) : l.unsubscribe(i))
        }),
        (e = null))
    }
    e.forEach((l) => l && l.addEventListener && l.addEventListener('abort', i))
    const { signal: a } = n
    return (
      (a.unsubscribe = o),
      [
        a,
        () => {
          s && clearTimeout(s), (s = null)
        },
      ]
    )
  },
  qM = HM,
  KM = function* (e, t) {
    let n = e.byteLength
    if (!t || n < t) {
      yield e
      return
    }
    let r = 0,
      i
    for (; r < n; ) (i = r + t), yield e.slice(r, i), (r = i)
  },
  GM = async function* (e, t, n) {
    for await (const r of e) yield* KM(ArrayBuffer.isView(r) ? r : await n(String(r)), t)
  },
  Z2 = (e, t, n, r, i) => {
    const s = GM(e, t, i)
    let o = 0
    return new ReadableStream(
      {
        type: 'bytes',
        async pull(a) {
          const { done: l, value: c } = await s.next()
          if (l) {
            a.close(), r()
            return
          }
          let u = c.byteLength
          n && n((o += u)), a.enqueue(new Uint8Array(c))
        },
        cancel(a) {
          return r(a), s.return()
        },
      },
      { highWaterMark: 2 }
    )
  },
  J2 = (e, t) => {
    const n = e != null
    return (r) => setTimeout(() => t({ lengthComputable: n, total: e, loaded: r }))
  },
  Y0 = typeof fetch == 'function' && typeof Request == 'function' && typeof Response == 'function',
  V_ = Y0 && typeof ReadableStream == 'function',
  Zy =
    Y0 &&
    (typeof TextEncoder == 'function'
      ? (
          (e) => (t) =>
            e.encode(t)
        )(new TextEncoder())
      : async (e) => new Uint8Array(await new Response(e).arrayBuffer())),
  YM =
    V_ &&
    (() => {
      let e = !1
      const t = new Request(Ti.origin, {
        body: new ReadableStream(),
        method: 'POST',
        get duplex() {
          return (e = !0), 'half'
        },
      }).headers.has('Content-Type')
      return e && !t
    })(),
  eS = 64 * 1024,
  Jy =
    V_ &&
    !!(() => {
      try {
        return z.isReadableStream(new Response('').body)
      } catch {}
    })(),
  $p = { stream: Jy && ((e) => e.body) }
Y0 &&
  ((e) => {
    ;['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach((t) => {
      !$p[t] &&
        ($p[t] = z.isFunction(e[t])
          ? (n) => n[t]()
          : (n, r) => {
              throw new Xe(`Response type '${t}' is not supported`, Xe.ERR_NOT_SUPPORT, r)
            })
    })
  })(new Response())
const QM = async (e) => {
    if (e == null) return 0
    if (z.isBlob(e)) return e.size
    if (z.isSpecCompliantForm(e)) return (await new Request(e).arrayBuffer()).byteLength
    if (z.isArrayBufferView(e)) return e.byteLength
    if ((z.isURLSearchParams(e) && (e = e + ''), z.isString(e))) return (await Zy(e)).byteLength
  },
  XM = async (e, t) => {
    const n = z.toFiniteNumber(e.getContentLength())
    return n ?? QM(t)
  },
  ZM =
    Y0 &&
    (async (e) => {
      let {
        url: t,
        method: n,
        data: r,
        signal: i,
        cancelToken: s,
        timeout: o,
        onDownloadProgress: a,
        onUploadProgress: l,
        responseType: c,
        headers: u,
        withCredentials: f = 'same-origin',
        fetchOptions: d,
      } = W_(e)
      c = c ? (c + '').toLowerCase() : 'text'
      let [p, h] = i || s || o ? qM([i, s], o) : [],
        m,
        b
      const y = () => {
        !m &&
          setTimeout(() => {
            p && p.unsubscribe()
          }),
          (m = !0)
      }
      let v
      try {
        if (l && YM && n !== 'get' && n !== 'head' && (v = await XM(u, r)) !== 0) {
          let I = new Request(t, { method: 'POST', body: r, duplex: 'half' }),
            k
          z.isFormData(r) && (k = I.headers.get('content-type')) && u.setContentType(k),
            I.body && (r = Z2(I.body, eS, J2(v, Lp(l)), null, Zy))
        }
        z.isString(f) || (f = f ? 'cors' : 'omit'),
          (b = new Request(t, {
            ...d,
            signal: p,
            method: n.toUpperCase(),
            headers: u.normalize().toJSON(),
            body: r,
            duplex: 'half',
            withCredentials: f,
          }))
        let S = await fetch(b)
        const T = Jy && (c === 'stream' || c === 'response')
        if (Jy && (a || T)) {
          const I = {}
          ;['status', 'statusText', 'headers'].forEach((D) => {
            I[D] = S[D]
          })
          const k = z.toFiniteNumber(S.headers.get('content-length'))
          S = new Response(Z2(S.body, eS, a && J2(k, Lp(a, !0)), T && y, Zy), I)
        }
        c = c || 'text'
        let A = await $p[z.findKey($p, c) || 'text'](S, e)
        return (
          !T && y(),
          h && h(),
          await new Promise((I, k) => {
            U_(I, k, {
              data: A,
              headers: Ai.from(S.headers),
              status: S.status,
              statusText: S.statusText,
              config: e,
              request: b,
            })
          })
        )
      } catch (S) {
        throw (
          (y(),
          S && S.name === 'TypeError' && /fetch/i.test(S.message)
            ? Object.assign(new Xe('Network Error', Xe.ERR_NETWORK, e, b), { cause: S.cause || S })
            : Xe.from(S, S && S.code, e, b))
        )
      }
    }),
  ev = { http: hM, xhr: VM, fetch: ZM }
z.forEach(ev, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, 'name', { value: t })
    } catch {}
    Object.defineProperty(e, 'adapterName', { value: t })
  }
})
const tS = (e) => `- ${e}`,
  JM = (e) => z.isFunction(e) || e === null || e === !1,
  H_ = {
    getAdapter: (e) => {
      e = z.isArray(e) ? e : [e]
      const { length: t } = e
      let n, r
      const i = {}
      for (let s = 0; s < t; s++) {
        n = e[s]
        let o
        if (((r = n), !JM(n) && ((r = ev[(o = String(n)).toLowerCase()]), r === void 0)))
          throw new Xe(`Unknown adapter '${o}'`)
        if (r) break
        i[o || '#' + s] = r
      }
      if (!r) {
        const s = Object.entries(i).map(
          ([a, l]) =>
            `adapter ${a} ` +
            (l === !1 ? 'is not supported by the environment' : 'is not available in the build')
        )
        let o = t
          ? s.length > 1
            ? `since :
` +
              s.map(tS).join(`
`)
            : ' ' + tS(s[0])
          : 'as no adapter specified'
        throw new Xe('There is no suitable adapter to dispatch the request ' + o, 'ERR_NOT_SUPPORT')
      }
      return r
    },
    adapters: ev,
  }
function fm(e) {
  if ((e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted))
    throw new $c(null, e)
}
function nS(e) {
  return (
    fm(e),
    (e.headers = Ai.from(e.headers)),
    (e.data = um.call(e, e.transformRequest)),
    ['post', 'put', 'patch'].indexOf(e.method) !== -1 &&
      e.headers.setContentType('application/x-www-form-urlencoded', !1),
    H_.getAdapter(e.adapter || kw.adapter)(e).then(
      function (r) {
        return (
          fm(e), (r.data = um.call(e, e.transformResponse, r)), (r.headers = Ai.from(r.headers)), r
        )
      },
      function (r) {
        return (
          B_(r) ||
            (fm(e),
            r &&
              r.response &&
              ((r.response.data = um.call(e, e.transformResponse, r.response)),
              (r.response.headers = Ai.from(r.response.headers)))),
          Promise.reject(r)
        )
      }
    )
  )
}
const q_ = '1.7.2',
  Tw = {}
;['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((e, t) => {
  Tw[e] = function (r) {
    return typeof r === e || 'a' + (t < 1 ? 'n ' : ' ') + e
  }
})
const rS = {}
Tw.transitional = function (t, n, r) {
  function i(s, o) {
    return '[Axios v' + q_ + "] Transitional option '" + s + "'" + o + (r ? '. ' + r : '')
  }
  return (s, o, a) => {
    if (t === !1) throw new Xe(i(o, ' has been removed' + (n ? ' in ' + n : '')), Xe.ERR_DEPRECATED)
    return (
      n &&
        !rS[o] &&
        ((rS[o] = !0),
        console.warn(
          i(o, ' has been deprecated since v' + n + ' and will be removed in the near future')
        )),
      t ? t(s, o, a) : !0
    )
  }
}
function ej(e, t, n) {
  if (typeof e != 'object') throw new Xe('options must be an object', Xe.ERR_BAD_OPTION_VALUE)
  const r = Object.keys(e)
  let i = r.length
  for (; i-- > 0; ) {
    const s = r[i],
      o = t[s]
    if (o) {
      const a = e[s],
        l = a === void 0 || o(a, s, e)
      if (l !== !0) throw new Xe('option ' + s + ' must be ' + l, Xe.ERR_BAD_OPTION_VALUE)
      continue
    }
    if (n !== !0) throw new Xe('Unknown option ' + s, Xe.ERR_BAD_OPTION)
  }
}
const tv = { assertOptions: ej, validators: Tw },
  Ys = tv.validators
class Fp {
  constructor(t) {
    ;(this.defaults = t), (this.interceptors = { request: new Y2(), response: new Y2() })
  }
  async request(t, n) {
    try {
      return await this._request(t, n)
    } catch (r) {
      if (r instanceof Error) {
        let i
        Error.captureStackTrace ? Error.captureStackTrace((i = {})) : (i = new Error())
        const s = i.stack ? i.stack.replace(/^.+\n/, '') : ''
        try {
          r.stack
            ? s &&
              !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, '')) &&
              (r.stack +=
                `
` + s)
            : (r.stack = s)
        } catch {}
      }
      throw r
    }
  }
  _request(t, n) {
    typeof t == 'string' ? ((n = n || {}), (n.url = t)) : (n = t || {}), (n = Ba(this.defaults, n))
    const { transitional: r, paramsSerializer: i, headers: s } = n
    r !== void 0 &&
      tv.assertOptions(
        r,
        {
          silentJSONParsing: Ys.transitional(Ys.boolean),
          forcedJSONParsing: Ys.transitional(Ys.boolean),
          clarifyTimeoutError: Ys.transitional(Ys.boolean),
        },
        !1
      ),
      i != null &&
        (z.isFunction(i)
          ? (n.paramsSerializer = { serialize: i })
          : tv.assertOptions(i, { encode: Ys.function, serialize: Ys.function }, !0)),
      (n.method = (n.method || this.defaults.method || 'get').toLowerCase())
    let o = s && z.merge(s.common, s[n.method])
    s &&
      z.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], (h) => {
        delete s[h]
      }),
      (n.headers = Ai.concat(o, s))
    const a = []
    let l = !0
    this.interceptors.request.forEach(function (m) {
      ;(typeof m.runWhen == 'function' && m.runWhen(n) === !1) ||
        ((l = l && m.synchronous), a.unshift(m.fulfilled, m.rejected))
    })
    const c = []
    this.interceptors.response.forEach(function (m) {
      c.push(m.fulfilled, m.rejected)
    })
    let u,
      f = 0,
      d
    if (!l) {
      const h = [nS.bind(this), void 0]
      for (h.unshift.apply(h, a), h.push.apply(h, c), d = h.length, u = Promise.resolve(n); f < d; )
        u = u.then(h[f++], h[f++])
      return u
    }
    d = a.length
    let p = n
    for (f = 0; f < d; ) {
      const h = a[f++],
        m = a[f++]
      try {
        p = h(p)
      } catch (b) {
        m.call(this, b)
        break
      }
    }
    try {
      u = nS.call(this, p)
    } catch (h) {
      return Promise.reject(h)
    }
    for (f = 0, d = c.length; f < d; ) u = u.then(c[f++], c[f++])
    return u
  }
  getUri(t) {
    t = Ba(this.defaults, t)
    const n = z_(t.baseURL, t.url)
    return L_(n, t.params, t.paramsSerializer)
  }
}
z.forEach(['delete', 'get', 'head', 'options'], function (t) {
  Fp.prototype[t] = function (n, r) {
    return this.request(Ba(r || {}, { method: t, url: n, data: (r || {}).data }))
  }
})
z.forEach(['post', 'put', 'patch'], function (t) {
  function n(r) {
    return function (s, o, a) {
      return this.request(
        Ba(a || {}, {
          method: t,
          headers: r ? { 'Content-Type': 'multipart/form-data' } : {},
          url: s,
          data: o,
        })
      )
    }
  }
  ;(Fp.prototype[t] = n()), (Fp.prototype[t + 'Form'] = n(!0))
})
const Sh = Fp
class Aw {
  constructor(t) {
    if (typeof t != 'function') throw new TypeError('executor must be a function.')
    let n
    this.promise = new Promise(function (s) {
      n = s
    })
    const r = this
    this.promise.then((i) => {
      if (!r._listeners) return
      let s = r._listeners.length
      for (; s-- > 0; ) r._listeners[s](i)
      r._listeners = null
    }),
      (this.promise.then = (i) => {
        let s
        const o = new Promise((a) => {
          r.subscribe(a), (s = a)
        }).then(i)
        return (
          (o.cancel = function () {
            r.unsubscribe(s)
          }),
          o
        )
      }),
      t(function (s, o, a) {
        r.reason || ((r.reason = new $c(s, o, a)), n(r.reason))
      })
  }
  throwIfRequested() {
    if (this.reason) throw this.reason
  }
  subscribe(t) {
    if (this.reason) {
      t(this.reason)
      return
    }
    this._listeners ? this._listeners.push(t) : (this._listeners = [t])
  }
  unsubscribe(t) {
    if (!this._listeners) return
    const n = this._listeners.indexOf(t)
    n !== -1 && this._listeners.splice(n, 1)
  }
  static source() {
    let t
    return {
      token: new Aw(function (i) {
        t = i
      }),
      cancel: t,
    }
  }
}
const tj = Aw
function nj(e) {
  return function (n) {
    return e.apply(null, n)
  }
}
function rj(e) {
  return z.isObject(e) && e.isAxiosError === !0
}
const nv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
}
Object.entries(nv).forEach(([e, t]) => {
  nv[t] = e
})
const ij = nv
function K_(e) {
  const t = new Sh(e),
    n = __(Sh.prototype.request, t)
  return (
    z.extend(n, Sh.prototype, t, { allOwnKeys: !0 }),
    z.extend(n, t, null, { allOwnKeys: !0 }),
    (n.create = function (i) {
      return K_(Ba(e, i))
    }),
    n
  )
}
const on = K_(kw)
on.Axios = Sh
on.CanceledError = $c
on.CancelToken = tj
on.isCancel = B_
on.VERSION = q_
on.toFormData = K0
on.AxiosError = Xe
on.Cancel = on.CanceledError
on.all = function (t) {
  return Promise.all(t)
}
on.spread = nj
on.isAxiosError = rj
on.mergeConfig = Ba
on.AxiosHeaders = Ai
on.formToJSON = (e) => F_(z.isHTMLForm(e) ? new FormData(e) : e)
on.getAdapter = H_.getAdapter
on.HttpStatusCode = ij
on.default = on
const rv = on,
  sj = (e) => {
    e
      ? (rv.defaults.headers.common.Authorization = `Bearer ${e}`)
      : delete rv.defaults.headers.common.Authorization
  },
  G_ = { Authorization: `Bearer ${localStorage.getItem('token')}` }
var En = []
for (var dm = 0; dm < 256; ++dm) En.push((dm + 256).toString(16).slice(1))
function oj(e, t = 0) {
  return (
    En[e[t + 0]] +
    En[e[t + 1]] +
    En[e[t + 2]] +
    En[e[t + 3]] +
    '-' +
    En[e[t + 4]] +
    En[e[t + 5]] +
    '-' +
    En[e[t + 6]] +
    En[e[t + 7]] +
    '-' +
    En[e[t + 8]] +
    En[e[t + 9]] +
    '-' +
    En[e[t + 10]] +
    En[e[t + 11]] +
    En[e[t + 12]] +
    En[e[t + 13]] +
    En[e[t + 14]] +
    En[e[t + 15]]
  ).toLowerCase()
}
var Id,
  aj = new Uint8Array(16)
function lj() {
  if (
    !Id &&
    ((Id = typeof crypto < 'u' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)),
    !Id)
  )
    throw new Error(
      'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
    )
  return Id(aj)
}
var cj = typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto)
const iS = { randomUUID: cj }
function uj(e, t, n) {
  if (iS.randomUUID && !t && !e) return iS.randomUUID()
  e = e || {}
  var r = e.random || (e.rng || lj)()
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    n = n || 0
    for (var i = 0; i < 16; ++i) t[n + i] = r[i]
    return t
  }
  return oj(r)
}
const Y_ = w.createContext({ addPopup: () => '', removePopup: () => {}, removeAll: () => {} }),
  Rw = () => {
    const { addPopup: e, removePopup: t, removeAll: n } = w.useContext(Y_)
    return { addPopup: e, removePopup: t, removeAll: n }
  },
  { Provider: fj } = Y_,
  Q_ = ({ children: e }) => {
    const [t, n] = w.useState([]),
      r = w.useRef(null),
      i = ({ Component: l, callback: c, removeCallback: u, closeWhenClickOutside: f }) => {
        const d = uj()
        return n([...t, { key: d, Component: l, closeWhenClickOutside: f }]), c && c(d), d
      },
      s = (l) => {
        n(t.filter((c) => c.key !== l))
      },
      o = () => {
        n([])
      },
      a = t.length > 0 ? t[t.length - 1].Component : () => E.jsx(E.Fragment, {})
    return E.jsxs(fj, {
      value: { addPopup: i, removePopup: s, removeAll: o },
      children: [
        e,
        t.length > 0 &&
          E.jsx('div', {
            className: 'fixed z-40 inset-0 overflow-y-auto',
            onClick: (l) => {
              l.target === r.current &&
                t[t.length - 1].closeWhenClickOutside !== !1 &&
                (s(t[t.length - 1].key), o())
            },
            children: E.jsxs('div', {
              className:
                'flex items-center justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0',
              children: [
                E.jsx('div', {
                  className: 'fixed inset-0 transition-opacity',
                  'aria-hidden': 'true',
                  children: E.jsx('div', {
                    ref: r,
                    className: 'absolute inset-0 popup-background',
                  }),
                }),
                E.jsx('span', {
                  className: 'sm:inline-block sm:align-middle sm:h-screen',
                  'aria-hidden': 'true',
                  children: '',
                }),
                E.jsx(a, {}),
              ],
            }),
          }),
      ],
    })
  },
  ed = rv.create({ baseURL: 'http://localhost:3001' })
function He() {
  return (
    (He = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    He.apply(null, arguments)
  )
}
function St(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (i) {
    if ((e == null || e(i), n === !1 || !i.defaultPrevented)) return t == null ? void 0 : t(i)
  }
}
function dj(e, t) {
  typeof e == 'function' ? e(t) : e != null && (e.current = t)
}
function Pw(...e) {
  return (t) => e.forEach((n) => dj(n, t))
}
function Qn(...e) {
  return w.useCallback(Pw(...e), e)
}
function Fc(e, t = []) {
  let n = []
  function r(s, o) {
    const a = w.createContext(o),
      l = n.length
    n = [...n, o]
    function c(f) {
      const { scope: d, children: p, ...h } = f,
        m = (d == null ? void 0 : d[e][l]) || a,
        b = w.useMemo(() => h, Object.values(h))
      return w.createElement(m.Provider, { value: b }, p)
    }
    function u(f, d) {
      const p = (d == null ? void 0 : d[e][l]) || a,
        h = w.useContext(p)
      if (h) return h
      if (o !== void 0) return o
      throw new Error(`\`${f}\` must be used within \`${s}\``)
    }
    return (c.displayName = s + 'Provider'), [c, u]
  }
  const i = () => {
    const s = n.map((o) => w.createContext(o))
    return function (a) {
      const l = (a == null ? void 0 : a[e]) || s
      return w.useMemo(() => ({ [`__scope${e}`]: { ...a, [e]: l } }), [a, l])
    }
  }
  return (i.scopeName = e), [r, hj(i, ...t)]
}
function hj(...e) {
  const t = e[0]
  if (e.length === 1) return t
  const n = () => {
    const r = e.map((i) => ({ useScope: i(), scopeName: i.scopeName }))
    return function (s) {
      const o = r.reduce((a, { useScope: l, scopeName: c }) => {
        const f = l(s)[`__scope${c}`]
        return { ...a, ...f }
      }, {})
      return w.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o])
    }
  }
  return (n.scopeName = t.scopeName), n
}
const wc = globalThis != null && globalThis.document ? w.useLayoutEffect : () => {},
  pj = cp['useId'.toString()] || (() => {})
let gj = 0
function Bl(e) {
  const [t, n] = w.useState(pj())
  return (
    wc(() => {
      e || n((r) => r ?? String(gj++))
    }, [e]),
    e || (t ? `radix-${t}` : '')
  )
}
function ns(e) {
  const t = w.useRef(e)
  return (
    w.useEffect(() => {
      t.current = e
    }),
    w.useMemo(
      () =>
        (...n) => {
          var r
          return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n)
        },
      []
    )
  )
}
function Iw({ prop: e, defaultProp: t, onChange: n = () => {} }) {
  const [r, i] = mj({ defaultProp: t, onChange: n }),
    s = e !== void 0,
    o = s ? e : r,
    a = ns(n),
    l = w.useCallback(
      (c) => {
        if (s) {
          const f = typeof c == 'function' ? c(e) : c
          f !== e && a(f)
        } else i(c)
      },
      [s, e, i, a]
    )
  return [o, l]
}
function mj({ defaultProp: e, onChange: t }) {
  const n = w.useState(e),
    [r] = n,
    i = w.useRef(r),
    s = ns(t)
  return (
    w.useEffect(() => {
      i.current !== r && (s(r), (i.current = r))
    }, [r, i, s]),
    n
  )
}
const Ii = w.forwardRef((e, t) => {
  const { children: n, ...r } = e,
    i = w.Children.toArray(n),
    s = i.find(vj)
  if (s) {
    const o = s.props.children,
      a = i.map((l) =>
        l === s
          ? w.Children.count(o) > 1
            ? w.Children.only(null)
            : w.isValidElement(o)
            ? o.props.children
            : null
          : l
      )
    return w.createElement(
      iv,
      He({}, r, { ref: t }),
      w.isValidElement(o) ? w.cloneElement(o, void 0, a) : null
    )
  }
  return w.createElement(iv, He({}, r, { ref: t }), n)
})
Ii.displayName = 'Slot'
const iv = w.forwardRef((e, t) => {
  const { children: n, ...r } = e
  return w.isValidElement(n)
    ? w.cloneElement(n, { ...wj(r, n.props), ref: t ? Pw(t, n.ref) : n.ref })
    : w.Children.count(n) > 1
    ? w.Children.only(null)
    : null
})
iv.displayName = 'SlotClone'
const yj = ({ children: e }) => w.createElement(w.Fragment, null, e)
function vj(e) {
  return w.isValidElement(e) && e.type === yj
}
function wj(e, t) {
  const n = { ...t }
  for (const r in t) {
    const i = e[r],
      s = t[r]
    ;/^on[A-Z]/.test(r)
      ? i && s
        ? (n[r] = (...a) => {
            s(...a), i(...a)
          })
        : i && (n[r] = i)
      : r === 'style'
      ? (n[r] = { ...i, ...s })
      : r === 'className' && (n[r] = [i, s].filter(Boolean).join(' '))
  }
  return { ...e, ...n }
}
const bj = [
    'a',
    'button',
    'div',
    'form',
    'h2',
    'h3',
    'img',
    'input',
    'label',
    'li',
    'nav',
    'ol',
    'p',
    'span',
    'svg',
    'ul',
  ],
  dr = bj.reduce((e, t) => {
    const n = w.forwardRef((r, i) => {
      const { asChild: s, ...o } = r,
        a = s ? Ii : t
      return (
        w.useEffect(() => {
          window[Symbol.for('radix-ui')] = !0
        }, []),
        w.createElement(a, He({}, o, { ref: i }))
      )
    })
    return (n.displayName = `Primitive.${t}`), { ...e, [t]: n }
  }, {})
function X_(e, t) {
  e && jc.flushSync(() => e.dispatchEvent(t))
}
function xj(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ns(e)
  w.useEffect(() => {
    const r = (i) => {
      i.key === 'Escape' && n(i)
    }
    return t.addEventListener('keydown', r), () => t.removeEventListener('keydown', r)
  }, [n, t])
}
const sv = 'dismissableLayer.update',
  Sj = 'dismissableLayer.pointerDownOutside',
  Ej = 'dismissableLayer.focusOutside'
let sS
const Cj = w.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  Z_ = w.forwardRef((e, t) => {
    var n
    const {
        disableOutsidePointerEvents: r = !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: s,
        onFocusOutside: o,
        onInteractOutside: a,
        onDismiss: l,
        ...c
      } = e,
      u = w.useContext(Cj),
      [f, d] = w.useState(null),
      p =
        (n = f == null ? void 0 : f.ownerDocument) !== null && n !== void 0
          ? n
          : globalThis == null
          ? void 0
          : globalThis.document,
      [, h] = w.useState({}),
      m = Qn(t, (D) => d(D)),
      b = Array.from(u.layers),
      [y] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1),
      v = b.indexOf(y),
      S = f ? b.indexOf(f) : -1,
      T = u.layersWithOutsidePointerEventsDisabled.size > 0,
      A = S >= v,
      I = _j((D) => {
        const F = D.target,
          V = [...u.branches].some((ie) => ie.contains(F))
        !A || V || (s == null || s(D), a == null || a(D), D.defaultPrevented || l == null || l())
      }, p),
      k = Oj((D) => {
        const F = D.target
        ;[...u.branches].some((ie) => ie.contains(F)) ||
          (o == null || o(D), a == null || a(D), D.defaultPrevented || l == null || l())
      }, p)
    return (
      xj((D) => {
        S === u.layers.size - 1 &&
          (i == null || i(D), !D.defaultPrevented && l && (D.preventDefault(), l()))
      }, p),
      w.useEffect(() => {
        if (f)
          return (
            r &&
              (u.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((sS = p.body.style.pointerEvents), (p.body.style.pointerEvents = 'none')),
              u.layersWithOutsidePointerEventsDisabled.add(f)),
            u.layers.add(f),
            oS(),
            () => {
              r &&
                u.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (p.body.style.pointerEvents = sS)
            }
          )
      }, [f, p, r, u]),
      w.useEffect(
        () => () => {
          f && (u.layers.delete(f), u.layersWithOutsidePointerEventsDisabled.delete(f), oS())
        },
        [f, u]
      ),
      w.useEffect(() => {
        const D = () => h({})
        return document.addEventListener(sv, D), () => document.removeEventListener(sv, D)
      }, []),
      w.createElement(
        dr.div,
        He({}, c, {
          ref: m,
          style: { pointerEvents: T ? (A ? 'auto' : 'none') : void 0, ...e.style },
          onFocusCapture: St(e.onFocusCapture, k.onFocusCapture),
          onBlurCapture: St(e.onBlurCapture, k.onBlurCapture),
          onPointerDownCapture: St(e.onPointerDownCapture, I.onPointerDownCapture),
        })
      )
    )
  })
function _j(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ns(e),
    r = w.useRef(!1),
    i = w.useRef(() => {})
  return (
    w.useEffect(() => {
      const s = (a) => {
          if (a.target && !r.current) {
            let u = function () {
              J_(Sj, n, c, { discrete: !0 })
            }
            var l = u
            const c = { originalEvent: a }
            a.pointerType === 'touch'
              ? (t.removeEventListener('click', i.current),
                (i.current = u),
                t.addEventListener('click', i.current, { once: !0 }))
              : u()
          } else t.removeEventListener('click', i.current)
          r.current = !1
        },
        o = window.setTimeout(() => {
          t.addEventListener('pointerdown', s)
        }, 0)
      return () => {
        window.clearTimeout(o),
          t.removeEventListener('pointerdown', s),
          t.removeEventListener('click', i.current)
      }
    }, [t, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  )
}
function Oj(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ns(e),
    r = w.useRef(!1)
  return (
    w.useEffect(() => {
      const i = (s) => {
        s.target && !r.current && J_(Ej, n, { originalEvent: s }, { discrete: !1 })
      }
      return t.addEventListener('focusin', i), () => t.removeEventListener('focusin', i)
    }, [t, n]),
    { onFocusCapture: () => (r.current = !0), onBlurCapture: () => (r.current = !1) }
  )
}
function oS() {
  const e = new CustomEvent(sv)
  document.dispatchEvent(e)
}
function J_(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target,
    s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n })
  t && i.addEventListener(e, t, { once: !0 }), r ? X_(i, s) : i.dispatchEvent(s)
}
const hm = 'focusScope.autoFocusOnMount',
  pm = 'focusScope.autoFocusOnUnmount',
  aS = { bubbles: !1, cancelable: !0 },
  eO = w.forwardRef((e, t) => {
    const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: s, ...o } = e,
      [a, l] = w.useState(null),
      c = ns(i),
      u = ns(s),
      f = w.useRef(null),
      d = Qn(t, (m) => l(m)),
      p = w.useRef({
        paused: !1,
        pause() {
          this.paused = !0
        },
        resume() {
          this.paused = !1
        },
      }).current
    w.useEffect(() => {
      if (r) {
        let v = function (I) {
            if (p.paused || !a) return
            const k = I.target
            a.contains(k) ? (f.current = k) : io(f.current, { select: !0 })
          },
          S = function (I) {
            if (p.paused || !a) return
            const k = I.relatedTarget
            k !== null && (a.contains(k) || io(f.current, { select: !0 }))
          },
          T = function (I) {
            if (document.activeElement === document.body)
              for (const D of I) D.removedNodes.length > 0 && io(a)
          }
        var m = v,
          b = S,
          y = T
        document.addEventListener('focusin', v), document.addEventListener('focusout', S)
        const A = new MutationObserver(T)
        return (
          a && A.observe(a, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener('focusin', v),
              document.removeEventListener('focusout', S),
              A.disconnect()
          }
        )
      }
    }, [r, a, p.paused]),
      w.useEffect(() => {
        if (a) {
          cS.add(p)
          const m = document.activeElement
          if (!a.contains(m)) {
            const y = new CustomEvent(hm, aS)
            a.addEventListener(hm, c),
              a.dispatchEvent(y),
              y.defaultPrevented ||
                (kj(Ij(tO(a)), { select: !0 }), document.activeElement === m && io(a))
          }
          return () => {
            a.removeEventListener(hm, c),
              setTimeout(() => {
                const y = new CustomEvent(pm, aS)
                a.addEventListener(pm, u),
                  a.dispatchEvent(y),
                  y.defaultPrevented || io(m ?? document.body, { select: !0 }),
                  a.removeEventListener(pm, u),
                  cS.remove(p)
              }, 0)
          }
        }
      }, [a, c, u, p])
    const h = w.useCallback(
      (m) => {
        if ((!n && !r) || p.paused) return
        const b = m.key === 'Tab' && !m.altKey && !m.ctrlKey && !m.metaKey,
          y = document.activeElement
        if (b && y) {
          const v = m.currentTarget,
            [S, T] = Tj(v)
          S && T
            ? !m.shiftKey && y === T
              ? (m.preventDefault(), n && io(S, { select: !0 }))
              : m.shiftKey && y === S && (m.preventDefault(), n && io(T, { select: !0 }))
            : y === v && m.preventDefault()
        }
      },
      [n, r, p.paused]
    )
    return w.createElement(dr.div, He({ tabIndex: -1 }, o, { ref: d, onKeyDown: h }))
  })
function kj(e, { select: t = !1 } = {}) {
  const n = document.activeElement
  for (const r of e) if ((io(r, { select: t }), document.activeElement !== n)) return
}
function Tj(e) {
  const t = tO(e),
    n = lS(t, e),
    r = lS(t.reverse(), e)
  return [n, r]
}
function tO(e) {
  const t = [],
    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === 'INPUT' && r.type === 'hidden'
        return r.disabled || r.hidden || i
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP
      },
    })
  for (; n.nextNode(); ) t.push(n.currentNode)
  return t
}
function lS(e, t) {
  for (const n of e) if (!Aj(n, { upTo: t })) return n
}
function Aj(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === 'hidden') return !0
  for (; e; ) {
    if (t !== void 0 && e === t) return !1
    if (getComputedStyle(e).display === 'none') return !0
    e = e.parentElement
  }
  return !1
}
function Rj(e) {
  return e instanceof HTMLInputElement && 'select' in e
}
function io(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement
    e.focus({ preventScroll: !0 }), e !== n && Rj(e) && t && e.select()
  }
}
const cS = Pj()
function Pj() {
  let e = []
  return {
    add(t) {
      const n = e[0]
      t !== n && (n == null || n.pause()), (e = uS(e, t)), e.unshift(t)
    },
    remove(t) {
      var n
      ;(e = uS(e, t)), (n = e[0]) === null || n === void 0 || n.resume()
    },
  }
}
function uS(e, t) {
  const n = [...e],
    r = n.indexOf(t)
  return r !== -1 && n.splice(r, 1), n
}
function Ij(e) {
  return e.filter((t) => t.tagName !== 'A')
}
const nO = w.forwardRef((e, t) => {
  var n
  const {
    container: r = globalThis == null || (n = globalThis.document) === null || n === void 0
      ? void 0
      : n.body,
    ...i
  } = e
  return r ? L5.createPortal(w.createElement(dr.div, He({}, i, { ref: t })), r) : null
})
function Dj(e, t) {
  return w.useReducer((n, r) => {
    const i = t[n][r]
    return i ?? n
  }, e)
}
const Bc = (e) => {
  const { present: t, children: n } = e,
    r = Nj(t),
    i = typeof n == 'function' ? n({ present: r.isPresent }) : w.Children.only(n),
    s = Qn(r.ref, i.ref)
  return typeof n == 'function' || r.isPresent ? w.cloneElement(i, { ref: s }) : null
}
Bc.displayName = 'Presence'
function Nj(e) {
  const [t, n] = w.useState(),
    r = w.useRef({}),
    i = w.useRef(e),
    s = w.useRef('none'),
    o = e ? 'mounted' : 'unmounted',
    [a, l] = Dj(o, {
      mounted: { UNMOUNT: 'unmounted', ANIMATION_OUT: 'unmountSuspended' },
      unmountSuspended: { MOUNT: 'mounted', ANIMATION_END: 'unmounted' },
      unmounted: { MOUNT: 'mounted' },
    })
  return (
    w.useEffect(() => {
      const c = Dd(r.current)
      s.current = a === 'mounted' ? c : 'none'
    }, [a]),
    wc(() => {
      const c = r.current,
        u = i.current
      if (u !== e) {
        const d = s.current,
          p = Dd(c)
        e
          ? l('MOUNT')
          : p === 'none' || (c == null ? void 0 : c.display) === 'none'
          ? l('UNMOUNT')
          : l(u && d !== p ? 'ANIMATION_OUT' : 'UNMOUNT'),
          (i.current = e)
      }
    }, [e, l]),
    wc(() => {
      if (t) {
        const c = (f) => {
            const p = Dd(r.current).includes(f.animationName)
            f.target === t && p && jc.flushSync(() => l('ANIMATION_END'))
          },
          u = (f) => {
            f.target === t && (s.current = Dd(r.current))
          }
        return (
          t.addEventListener('animationstart', u),
          t.addEventListener('animationcancel', c),
          t.addEventListener('animationend', c),
          () => {
            t.removeEventListener('animationstart', u),
              t.removeEventListener('animationcancel', c),
              t.removeEventListener('animationend', c)
          }
        )
      } else l('ANIMATION_END')
    }, [t, l]),
    {
      isPresent: ['mounted', 'unmountSuspended'].includes(a),
      ref: w.useCallback((c) => {
        c && (r.current = getComputedStyle(c)), n(c)
      }, []),
    }
  )
}
function Dd(e) {
  return (e == null ? void 0 : e.animationName) || 'none'
}
let gm = 0
function rO() {
  w.useEffect(() => {
    var e, t
    const n = document.querySelectorAll('[data-radix-focus-guard]')
    return (
      document.body.insertAdjacentElement(
        'afterbegin',
        (e = n[0]) !== null && e !== void 0 ? e : fS()
      ),
      document.body.insertAdjacentElement(
        'beforeend',
        (t = n[1]) !== null && t !== void 0 ? t : fS()
      ),
      gm++,
      () => {
        gm === 1 &&
          document.querySelectorAll('[data-radix-focus-guard]').forEach((r) => r.remove()),
          gm--
      }
    )
  }, [])
}
function fS() {
  const e = document.createElement('span')
  return (
    e.setAttribute('data-radix-focus-guard', ''),
    (e.tabIndex = 0),
    (e.style.cssText = 'outline: none; opacity: 0; position: fixed; pointer-events: none'),
    e
  )
}
var Yi = function () {
  return (
    (Yi =
      Object.assign ||
      function (t) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r]
          for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s])
        }
        return t
      }),
    Yi.apply(this, arguments)
  )
}
function iO(e, t) {
  var n = {}
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
        (n[r[i]] = e[r[i]])
  return n
}
function Mj(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, s; r < i; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), (s[r] = t[r]))
  return e.concat(s || Array.prototype.slice.call(t))
}
var Eh = 'right-scroll-bar-position',
  Ch = 'width-before-scroll-bar',
  jj = 'with-scroll-bars-hidden',
  Lj = '--removed-body-scroll-bar-size'
function mm(e, t) {
  return typeof e == 'function' ? e(t) : e && (e.current = t), e
}
function $j(e, t) {
  var n = w.useState(function () {
    return {
      value: e,
      callback: t,
      facade: {
        get current() {
          return n.value
        },
        set current(r) {
          var i = n.value
          i !== r && ((n.value = r), n.callback(r, i))
        },
      },
    }
  })[0]
  return (n.callback = t), n.facade
}
var Fj = typeof window < 'u' ? w.useLayoutEffect : w.useEffect,
  dS = new WeakMap()
function Bj(e, t) {
  var n = $j(t || null, function (r) {
    return e.forEach(function (i) {
      return mm(i, r)
    })
  })
  return (
    Fj(
      function () {
        var r = dS.get(n)
        if (r) {
          var i = new Set(r),
            s = new Set(e),
            o = n.current
          i.forEach(function (a) {
            s.has(a) || mm(a, null)
          }),
            s.forEach(function (a) {
              i.has(a) || mm(a, o)
            })
        }
        dS.set(n, e)
      },
      [e]
    ),
    n
  )
}
function Uj(e) {
  return e
}
function zj(e, t) {
  t === void 0 && (t = Uj)
  var n = [],
    r = !1,
    i = {
      read: function () {
        if (r)
          throw new Error(
            'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.'
          )
        return n.length ? n[n.length - 1] : e
      },
      useMedium: function (s) {
        var o = t(s, r)
        return (
          n.push(o),
          function () {
            n = n.filter(function (a) {
              return a !== o
            })
          }
        )
      },
      assignSyncMedium: function (s) {
        for (r = !0; n.length; ) {
          var o = n
          ;(n = []), o.forEach(s)
        }
        n = {
          push: function (a) {
            return s(a)
          },
          filter: function () {
            return n
          },
        }
      },
      assignMedium: function (s) {
        r = !0
        var o = []
        if (n.length) {
          var a = n
          ;(n = []), a.forEach(s), (o = n)
        }
        var l = function () {
            var u = o
            ;(o = []), u.forEach(s)
          },
          c = function () {
            return Promise.resolve().then(l)
          }
        c(),
          (n = {
            push: function (u) {
              o.push(u), c()
            },
            filter: function (u) {
              return (o = o.filter(u)), n
            },
          })
      },
    }
  return i
}
function Wj(e) {
  e === void 0 && (e = {})
  var t = zj(null)
  return (t.options = Yi({ async: !0, ssr: !1 }, e)), t
}
var sO = function (e) {
  var t = e.sideCar,
    n = iO(e, ['sideCar'])
  if (!t) throw new Error('Sidecar: please provide `sideCar` property to import the right car')
  var r = t.read()
  if (!r) throw new Error('Sidecar medium not found')
  return w.createElement(r, Yi({}, n))
}
sO.isSideCarExport = !0
function Vj(e, t) {
  return e.useMedium(t), sO
}
var oO = Wj(),
  ym = function () {},
  Q0 = w.forwardRef(function (e, t) {
    var n = w.useRef(null),
      r = w.useState({ onScrollCapture: ym, onWheelCapture: ym, onTouchMoveCapture: ym }),
      i = r[0],
      s = r[1],
      o = e.forwardProps,
      a = e.children,
      l = e.className,
      c = e.removeScrollBar,
      u = e.enabled,
      f = e.shards,
      d = e.sideCar,
      p = e.noIsolation,
      h = e.inert,
      m = e.allowPinchZoom,
      b = e.as,
      y = b === void 0 ? 'div' : b,
      v = iO(e, [
        'forwardProps',
        'children',
        'className',
        'removeScrollBar',
        'enabled',
        'shards',
        'sideCar',
        'noIsolation',
        'inert',
        'allowPinchZoom',
        'as',
      ]),
      S = d,
      T = Bj([n, t]),
      A = Yi(Yi({}, v), i)
    return w.createElement(
      w.Fragment,
      null,
      u &&
        w.createElement(S, {
          sideCar: oO,
          removeScrollBar: c,
          shards: f,
          noIsolation: p,
          inert: h,
          setCallbacks: s,
          allowPinchZoom: !!m,
          lockRef: n,
        }),
      o
        ? w.cloneElement(w.Children.only(a), Yi(Yi({}, A), { ref: T }))
        : w.createElement(y, Yi({}, A, { className: l, ref: T }), a)
    )
  })
Q0.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }
Q0.classNames = { fullWidth: Ch, zeroRight: Eh }
var hS,
  Hj = function () {
    if (hS) return hS
    if (typeof __webpack_nonce__ < 'u') return __webpack_nonce__
  }
function qj() {
  if (!document) return null
  var e = document.createElement('style')
  e.type = 'text/css'
  var t = Hj()
  return t && e.setAttribute('nonce', t), e
}
function Kj(e, t) {
  e.styleSheet ? (e.styleSheet.cssText = t) : e.appendChild(document.createTextNode(t))
}
function Gj(e) {
  var t = document.head || document.getElementsByTagName('head')[0]
  t.appendChild(e)
}
var Yj = function () {
    var e = 0,
      t = null
    return {
      add: function (n) {
        e == 0 && (t = qj()) && (Kj(t, n), Gj(t)), e++
      },
      remove: function () {
        e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), (t = null))
      },
    }
  },
  Qj = function () {
    var e = Yj()
    return function (t, n) {
      w.useEffect(
        function () {
          return (
            e.add(t),
            function () {
              e.remove()
            }
          )
        },
        [t && n]
      )
    }
  },
  aO = function () {
    var e = Qj(),
      t = function (n) {
        var r = n.styles,
          i = n.dynamic
        return e(r, i), null
      }
    return t
  },
  Xj = { left: 0, top: 0, right: 0, gap: 0 },
  vm = function (e) {
    return parseInt(e || '', 10) || 0
  },
  Zj = function (e) {
    var t = window.getComputedStyle(document.body),
      n = t[e === 'padding' ? 'paddingLeft' : 'marginLeft'],
      r = t[e === 'padding' ? 'paddingTop' : 'marginTop'],
      i = t[e === 'padding' ? 'paddingRight' : 'marginRight']
    return [vm(n), vm(r), vm(i)]
  },
  Jj = function (e) {
    if ((e === void 0 && (e = 'margin'), typeof window > 'u')) return Xj
    var t = Zj(e),
      n = document.documentElement.clientWidth,
      r = window.innerWidth
    return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, r - n + t[2] - t[0]) }
  },
  eL = aO(),
  Ul = 'data-scroll-locked',
  tL = function (e, t, n, r) {
    var i = e.left,
      s = e.top,
      o = e.right,
      a = e.gap
    return (
      n === void 0 && (n = 'margin'),
      `
  .`
        .concat(
          jj,
          ` {
   overflow: hidden `
        )
        .concat(
          r,
          `;
   padding-right: `
        )
        .concat(a, 'px ')
        .concat(
          r,
          `;
  }
  body[`
        )
        .concat(
          Ul,
          `] {
    overflow: hidden `
        )
        .concat(
          r,
          `;
    overscroll-behavior: contain;
    `
        )
        .concat(
          [
            t && 'position: relative '.concat(r, ';'),
            n === 'margin' &&
              `
    padding-left: `
                .concat(
                  i,
                  `px;
    padding-top: `
                )
                .concat(
                  s,
                  `px;
    padding-right: `
                )
                .concat(
                  o,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                )
                .concat(a, 'px ')
                .concat(
                  r,
                  `;
    `
                ),
            n === 'padding' && 'padding-right: '.concat(a, 'px ').concat(r, ';'),
          ]
            .filter(Boolean)
            .join(''),
          `
  }
  
  .`
        )
        .concat(
          Eh,
          ` {
    right: `
        )
        .concat(a, 'px ')
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(
          Ch,
          ` {
    margin-right: `
        )
        .concat(a, 'px ')
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(Eh, ' .')
        .concat(
          Eh,
          ` {
    right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(Ch, ' .')
        .concat(
          Ch,
          ` {
    margin-right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  body[`
        )
        .concat(
          Ul,
          `] {
    `
        )
        .concat(Lj, ': ')
        .concat(
          a,
          `px;
  }
`
        )
    )
  },
  pS = function () {
    var e = parseInt(document.body.getAttribute(Ul) || '0', 10)
    return isFinite(e) ? e : 0
  },
  nL = function () {
    w.useEffect(function () {
      return (
        document.body.setAttribute(Ul, (pS() + 1).toString()),
        function () {
          var e = pS() - 1
          e <= 0 ? document.body.removeAttribute(Ul) : document.body.setAttribute(Ul, e.toString())
        }
      )
    }, [])
  },
  rL = function (e) {
    var t = e.noRelative,
      n = e.noImportant,
      r = e.gapMode,
      i = r === void 0 ? 'margin' : r
    nL()
    var s = w.useMemo(
      function () {
        return Jj(i)
      },
      [i]
    )
    return w.createElement(eL, { styles: tL(s, !t, i, n ? '' : '!important') })
  },
  ov = !1
if (typeof window < 'u')
  try {
    var Nd = Object.defineProperty({}, 'passive', {
      get: function () {
        return (ov = !0), !0
      },
    })
    window.addEventListener('test', Nd, Nd), window.removeEventListener('test', Nd, Nd)
  } catch {
    ov = !1
  }
var tl = ov ? { passive: !1 } : !1,
  iL = function (e) {
    return e.tagName === 'TEXTAREA'
  },
  lO = function (e, t) {
    var n = window.getComputedStyle(e)
    return n[t] !== 'hidden' && !(n.overflowY === n.overflowX && !iL(e) && n[t] === 'visible')
  },
  sL = function (e) {
    return lO(e, 'overflowY')
  },
  oL = function (e) {
    return lO(e, 'overflowX')
  },
  gS = function (e, t) {
    var n = t
    do {
      typeof ShadowRoot < 'u' && n instanceof ShadowRoot && (n = n.host)
      var r = cO(e, n)
      if (r) {
        var i = uO(e, n),
          s = i[1],
          o = i[2]
        if (s > o) return !0
      }
      n = n.parentNode
    } while (n && n !== document.body)
    return !1
  },
  aL = function (e) {
    var t = e.scrollTop,
      n = e.scrollHeight,
      r = e.clientHeight
    return [t, n, r]
  },
  lL = function (e) {
    var t = e.scrollLeft,
      n = e.scrollWidth,
      r = e.clientWidth
    return [t, n, r]
  },
  cO = function (e, t) {
    return e === 'v' ? sL(t) : oL(t)
  },
  uO = function (e, t) {
    return e === 'v' ? aL(t) : lL(t)
  },
  cL = function (e, t) {
    return e === 'h' && t === 'rtl' ? -1 : 1
  },
  uL = function (e, t, n, r, i) {
    var s = cL(e, window.getComputedStyle(t).direction),
      o = s * r,
      a = n.target,
      l = t.contains(a),
      c = !1,
      u = o > 0,
      f = 0,
      d = 0
    do {
      var p = uO(e, a),
        h = p[0],
        m = p[1],
        b = p[2],
        y = m - b - s * h
      ;(h || y) && cO(e, a) && ((f += y), (d += h)), (a = a.parentNode)
    } while ((!l && a !== document.body) || (l && (t.contains(a) || t === a)))
    return (
      ((u && ((i && f === 0) || (!i && o > f))) || (!u && ((i && d === 0) || (!i && -o > d)))) &&
        (c = !0),
      c
    )
  },
  Md = function (e) {
    return 'changedTouches' in e
      ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY]
      : [0, 0]
  },
  mS = function (e) {
    return [e.deltaX, e.deltaY]
  },
  yS = function (e) {
    return e && 'current' in e ? e.current : e
  },
  fL = function (e, t) {
    return e[0] === t[0] && e[1] === t[1]
  },
  dL = function (e) {
    return `
  .block-interactivity-`
      .concat(
        e,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        e,
        ` {pointer-events: all;}
`
      )
  },
  hL = 0,
  nl = []
function pL(e) {
  var t = w.useRef([]),
    n = w.useRef([0, 0]),
    r = w.useRef(),
    i = w.useState(hL++)[0],
    s = w.useState(function () {
      return aO()
    })[0],
    o = w.useRef(e)
  w.useEffect(
    function () {
      o.current = e
    },
    [e]
  ),
    w.useEffect(
      function () {
        if (e.inert) {
          document.body.classList.add('block-interactivity-'.concat(i))
          var m = Mj([e.lockRef.current], (e.shards || []).map(yS), !0).filter(Boolean)
          return (
            m.forEach(function (b) {
              return b.classList.add('allow-interactivity-'.concat(i))
            }),
            function () {
              document.body.classList.remove('block-interactivity-'.concat(i)),
                m.forEach(function (b) {
                  return b.classList.remove('allow-interactivity-'.concat(i))
                })
            }
          )
        }
      },
      [e.inert, e.lockRef.current, e.shards]
    )
  var a = w.useCallback(function (m, b) {
      if ('touches' in m && m.touches.length === 2) return !o.current.allowPinchZoom
      var y = Md(m),
        v = n.current,
        S = 'deltaX' in m ? m.deltaX : v[0] - y[0],
        T = 'deltaY' in m ? m.deltaY : v[1] - y[1],
        A,
        I = m.target,
        k = Math.abs(S) > Math.abs(T) ? 'h' : 'v'
      if ('touches' in m && k === 'h' && I.type === 'range') return !1
      var D = gS(k, I)
      if (!D) return !0
      if ((D ? (A = k) : ((A = k === 'v' ? 'h' : 'v'), (D = gS(k, I))), !D)) return !1
      if ((!r.current && 'changedTouches' in m && (S || T) && (r.current = A), !A)) return !0
      var F = r.current || A
      return uL(F, b, m, F === 'h' ? S : T, !0)
    }, []),
    l = w.useCallback(function (m) {
      var b = m
      if (!(!nl.length || nl[nl.length - 1] !== s)) {
        var y = 'deltaY' in b ? mS(b) : Md(b),
          v = t.current.filter(function (A) {
            return A.name === b.type && A.target === b.target && fL(A.delta, y)
          })[0]
        if (v && v.should) {
          b.cancelable && b.preventDefault()
          return
        }
        if (!v) {
          var S = (o.current.shards || [])
              .map(yS)
              .filter(Boolean)
              .filter(function (A) {
                return A.contains(b.target)
              }),
            T = S.length > 0 ? a(b, S[0]) : !o.current.noIsolation
          T && b.cancelable && b.preventDefault()
        }
      }
    }, []),
    c = w.useCallback(function (m, b, y, v) {
      var S = { name: m, delta: b, target: y, should: v }
      t.current.push(S),
        setTimeout(function () {
          t.current = t.current.filter(function (T) {
            return T !== S
          })
        }, 1)
    }, []),
    u = w.useCallback(function (m) {
      ;(n.current = Md(m)), (r.current = void 0)
    }, []),
    f = w.useCallback(function (m) {
      c(m.type, mS(m), m.target, a(m, e.lockRef.current))
    }, []),
    d = w.useCallback(function (m) {
      c(m.type, Md(m), m.target, a(m, e.lockRef.current))
    }, [])
  w.useEffect(function () {
    return (
      nl.push(s),
      e.setCallbacks({ onScrollCapture: f, onWheelCapture: f, onTouchMoveCapture: d }),
      document.addEventListener('wheel', l, tl),
      document.addEventListener('touchmove', l, tl),
      document.addEventListener('touchstart', u, tl),
      function () {
        ;(nl = nl.filter(function (m) {
          return m !== s
        })),
          document.removeEventListener('wheel', l, tl),
          document.removeEventListener('touchmove', l, tl),
          document.removeEventListener('touchstart', u, tl)
      }
    )
  }, [])
  var p = e.removeScrollBar,
    h = e.inert
  return w.createElement(
    w.Fragment,
    null,
    h ? w.createElement(s, { styles: dL(i) }) : null,
    p ? w.createElement(rL, { gapMode: 'margin' }) : null
  )
}
const gL = Vj(oO, pL)
var fO = w.forwardRef(function (e, t) {
  return w.createElement(Q0, Yi({}, e, { ref: t, sideCar: gL }))
})
fO.classNames = Q0.classNames
const dO = fO
var mL = function (e) {
    if (typeof document > 'u') return null
    var t = Array.isArray(e) ? e[0] : e
    return t.ownerDocument.body
  },
  rl = new WeakMap(),
  jd = new WeakMap(),
  Ld = {},
  wm = 0,
  hO = function (e) {
    return e && (e.host || hO(e.parentNode))
  },
  yL = function (e, t) {
    return t
      .map(function (n) {
        if (e.contains(n)) return n
        var r = hO(n)
        return r && e.contains(r)
          ? r
          : (console.error('aria-hidden', n, 'in not contained inside', e, '. Doing nothing'), null)
      })
      .filter(function (n) {
        return !!n
      })
  },
  vL = function (e, t, n, r) {
    var i = yL(t, Array.isArray(e) ? e : [e])
    Ld[n] || (Ld[n] = new WeakMap())
    var s = Ld[n],
      o = [],
      a = new Set(),
      l = new Set(i),
      c = function (f) {
        !f || a.has(f) || (a.add(f), c(f.parentNode))
      }
    i.forEach(c)
    var u = function (f) {
      !f ||
        l.has(f) ||
        Array.prototype.forEach.call(f.children, function (d) {
          if (a.has(d)) u(d)
          else
            try {
              var p = d.getAttribute(r),
                h = p !== null && p !== 'false',
                m = (rl.get(d) || 0) + 1,
                b = (s.get(d) || 0) + 1
              rl.set(d, m),
                s.set(d, b),
                o.push(d),
                m === 1 && h && jd.set(d, !0),
                b === 1 && d.setAttribute(n, 'true'),
                h || d.setAttribute(r, 'true')
            } catch (y) {
              console.error('aria-hidden: cannot operate on ', d, y)
            }
        })
    }
    return (
      u(t),
      a.clear(),
      wm++,
      function () {
        o.forEach(function (f) {
          var d = rl.get(f) - 1,
            p = s.get(f) - 1
          rl.set(f, d),
            s.set(f, p),
            d || (jd.has(f) || f.removeAttribute(r), jd.delete(f)),
            p || f.removeAttribute(n)
        }),
          wm--,
          wm || ((rl = new WeakMap()), (rl = new WeakMap()), (jd = new WeakMap()), (Ld = {}))
      }
    )
  },
  pO = function (e, t, n) {
    n === void 0 && (n = 'data-aria-hidden')
    var r = Array.from(Array.isArray(e) ? e : [e]),
      i = t || mL(e)
    return i
      ? (r.push.apply(r, Array.from(i.querySelectorAll('[aria-live]'))), vL(r, i, n, 'aria-hidden'))
      : function () {
          return null
        }
  }
const gO = 'Dialog',
  [mO, wQ] = Fc(gO),
  [wL, os] = mO(gO),
  bL = (e) => {
    const {
        __scopeDialog: t,
        children: n,
        open: r,
        defaultOpen: i,
        onOpenChange: s,
        modal: o = !0,
      } = e,
      a = w.useRef(null),
      l = w.useRef(null),
      [c = !1, u] = Iw({ prop: r, defaultProp: i, onChange: s })
    return w.createElement(
      wL,
      {
        scope: t,
        triggerRef: a,
        contentRef: l,
        contentId: Bl(),
        titleId: Bl(),
        descriptionId: Bl(),
        open: c,
        onOpenChange: u,
        onOpenToggle: w.useCallback(() => u((f) => !f), [u]),
        modal: o,
      },
      n
    )
  },
  xL = 'DialogTrigger',
  SL = w.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = os(xL, n),
      s = Qn(t, i.triggerRef)
    return w.createElement(
      dr.button,
      He(
        {
          type: 'button',
          'aria-haspopup': 'dialog',
          'aria-expanded': i.open,
          'aria-controls': i.contentId,
          'data-state': Dw(i.open),
        },
        r,
        { ref: s, onClick: St(e.onClick, i.onOpenToggle) }
      )
    )
  }),
  yO = 'DialogPortal',
  [EL, vO] = mO(yO, { forceMount: void 0 }),
  CL = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: i } = e,
      s = os(yO, t)
    return w.createElement(
      EL,
      { scope: t, forceMount: n },
      w.Children.map(r, (o) =>
        w.createElement(
          Bc,
          { present: n || s.open },
          w.createElement(nO, { asChild: !0, container: i }, o)
        )
      )
    )
  },
  av = 'DialogOverlay',
  _L = w.forwardRef((e, t) => {
    const n = vO(av, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...i } = e,
      s = os(av, e.__scopeDialog)
    return s.modal
      ? w.createElement(Bc, { present: r || s.open }, w.createElement(OL, He({}, i, { ref: t })))
      : null
  }),
  OL = w.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = os(av, n)
    return w.createElement(
      dO,
      { as: Ii, allowPinchZoom: !0, shards: [i.contentRef] },
      w.createElement(
        dr.div,
        He({ 'data-state': Dw(i.open) }, r, {
          ref: t,
          style: { pointerEvents: 'auto', ...r.style },
        })
      )
    )
  }),
  vf = 'DialogContent',
  kL = w.forwardRef((e, t) => {
    const n = vO(vf, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...i } = e,
      s = os(vf, e.__scopeDialog)
    return w.createElement(
      Bc,
      { present: r || s.open },
      s.modal
        ? w.createElement(TL, He({}, i, { ref: t }))
        : w.createElement(AL, He({}, i, { ref: t }))
    )
  }),
  TL = w.forwardRef((e, t) => {
    const n = os(vf, e.__scopeDialog),
      r = w.useRef(null),
      i = Qn(t, n.contentRef, r)
    return (
      w.useEffect(() => {
        const s = r.current
        if (s) return pO(s)
      }, []),
      w.createElement(
        wO,
        He({}, e, {
          ref: i,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: St(e.onCloseAutoFocus, (s) => {
            var o
            s.preventDefault(), (o = n.triggerRef.current) === null || o === void 0 || o.focus()
          }),
          onPointerDownOutside: St(e.onPointerDownOutside, (s) => {
            const o = s.detail.originalEvent,
              a = o.button === 0 && o.ctrlKey === !0
            ;(o.button === 2 || a) && s.preventDefault()
          }),
          onFocusOutside: St(e.onFocusOutside, (s) => s.preventDefault()),
        })
      )
    )
  }),
  AL = w.forwardRef((e, t) => {
    const n = os(vf, e.__scopeDialog),
      r = w.useRef(!1),
      i = w.useRef(!1)
    return w.createElement(
      wO,
      He({}, e, {
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var o
          if (
            ((o = e.onCloseAutoFocus) === null || o === void 0 || o.call(e, s), !s.defaultPrevented)
          ) {
            var a
            r.current || (a = n.triggerRef.current) === null || a === void 0 || a.focus(),
              s.preventDefault()
          }
          ;(r.current = !1), (i.current = !1)
        },
        onInteractOutside: (s) => {
          var o, a
          ;(o = e.onInteractOutside) === null || o === void 0 || o.call(e, s),
            s.defaultPrevented ||
              ((r.current = !0), s.detail.originalEvent.type === 'pointerdown' && (i.current = !0))
          const l = s.target
          ;((a = n.triggerRef.current) === null || a === void 0 ? void 0 : a.contains(l)) &&
            s.preventDefault(),
            s.detail.originalEvent.type === 'focusin' && i.current && s.preventDefault()
        },
      })
    )
  }),
  wO = w.forwardRef((e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: s, ...o } = e,
      a = os(vf, n),
      l = w.useRef(null),
      c = Qn(t, l)
    return (
      rO(),
      w.createElement(
        w.Fragment,
        null,
        w.createElement(
          eO,
          { asChild: !0, loop: !0, trapped: r, onMountAutoFocus: i, onUnmountAutoFocus: s },
          w.createElement(
            Z_,
            He(
              {
                role: 'dialog',
                id: a.contentId,
                'aria-describedby': a.descriptionId,
                'aria-labelledby': a.titleId,
                'data-state': Dw(a.open),
              },
              o,
              { ref: c, onDismiss: () => a.onOpenChange(!1) }
            )
          )
        ),
        !1
      )
    )
  }),
  RL = 'DialogTitle',
  PL = w.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = os(RL, n)
    return w.createElement(dr.h2, He({ id: i.titleId }, r, { ref: t }))
  }),
  IL = 'DialogClose',
  DL = w.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = os(IL, n)
    return w.createElement(
      dr.button,
      He({ type: 'button' }, r, { ref: t, onClick: St(e.onClick, () => i.onOpenChange(!1)) })
    )
  })
function Dw(e) {
  return e ? 'open' : 'closed'
}
const NL = bL,
  ML = SL,
  jL = CL,
  LL = _L,
  $L = kL,
  FL = PL,
  BL = DL
function bO(e) {
  var t,
    n,
    r = ''
  if (typeof e == 'string' || typeof e == 'number') r += e
  else if (typeof e == 'object')
    if (Array.isArray(e)) {
      var i = e.length
      for (t = 0; t < i; t++) e[t] && (n = bO(e[t])) && (r && (r += ' '), (r += n))
    } else for (n in e) e[n] && (r && (r += ' '), (r += n))
  return r
}
function Ms() {
  for (var e, t, n = 0, r = '', i = arguments.length; n < i; n++)
    (e = arguments[n]) && (t = bO(e)) && (r && (r += ' '), (r += t))
  return r
}
var Uc = class {
    constructor() {
      ;(this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this))
    }
    subscribe(e) {
      return (
        this.listeners.add(e),
        this.onSubscribe(),
        () => {
          this.listeners.delete(e), this.onUnsubscribe()
        }
      )
    }
    hasListeners() {
      return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  bc = typeof window > 'u' || 'Deno' in globalThis
function zr() {}
function UL(e, t) {
  return typeof e == 'function' ? e(t) : e
}
function lv(e) {
  return typeof e == 'number' && e >= 0 && e !== 1 / 0
}
function xO(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0)
}
function vS(e, t) {
  const { type: n = 'all', exact: r, fetchStatus: i, predicate: s, queryKey: o, stale: a } = e
  if (o) {
    if (r) {
      if (t.queryHash !== Nw(o, t.options)) return !1
    } else if (!wf(t.queryKey, o)) return !1
  }
  if (n !== 'all') {
    const l = t.isActive()
    if ((n === 'active' && !l) || (n === 'inactive' && l)) return !1
  }
  return !(
    (typeof a == 'boolean' && t.isStale() !== a) ||
    (i && i !== t.state.fetchStatus) ||
    (s && !s(t))
  )
}
function wS(e, t) {
  const { exact: n, status: r, predicate: i, mutationKey: s } = e
  if (s) {
    if (!t.options.mutationKey) return !1
    if (n) {
      if (Ua(t.options.mutationKey) !== Ua(s)) return !1
    } else if (!wf(t.options.mutationKey, s)) return !1
  }
  return !((r && t.state.status !== r) || (i && !i(t)))
}
function Nw(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Ua)(e)
}
function Ua(e) {
  return JSON.stringify(e, (t, n) =>
    cv(n)
      ? Object.keys(n)
          .sort()
          .reduce((r, i) => ((r[i] = n[i]), r), {})
      : n
  )
}
function wf(e, t) {
  return e === t
    ? !0
    : typeof e != typeof t
    ? !1
    : e && t && typeof e == 'object' && typeof t == 'object'
    ? !Object.keys(t).some((n) => !wf(e[n], t[n]))
    : !1
}
function SO(e, t) {
  if (e === t) return e
  const n = bS(e) && bS(t)
  if (n || (cv(e) && cv(t))) {
    const r = n ? e : Object.keys(e),
      i = r.length,
      s = n ? t : Object.keys(t),
      o = s.length,
      a = n ? [] : {}
    let l = 0
    for (let c = 0; c < o; c++) {
      const u = n ? c : s[c]
      ;((!n && r.includes(u)) || n) && e[u] === void 0 && t[u] === void 0
        ? ((a[u] = void 0), l++)
        : ((a[u] = SO(e[u], t[u])), a[u] === e[u] && e[u] !== void 0 && l++)
    }
    return i === o && l === i ? e : a
  }
  return t
}
function Bp(e, t) {
  if (!t || Object.keys(e).length !== Object.keys(t).length) return !1
  for (const n in e) if (e[n] !== t[n]) return !1
  return !0
}
function bS(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}
function cv(e) {
  if (!xS(e)) return !1
  const t = e.constructor
  if (t === void 0) return !0
  const n = t.prototype
  return !(
    !xS(n) ||
    !n.hasOwnProperty('isPrototypeOf') ||
    Object.getPrototypeOf(e) !== Object.prototype
  )
}
function xS(e) {
  return Object.prototype.toString.call(e) === '[object Object]'
}
function zL(e) {
  return new Promise((t) => {
    setTimeout(t, e)
  })
}
function uv(e, t, n) {
  return typeof n.structuralSharing == 'function'
    ? n.structuralSharing(e, t)
    : n.structuralSharing !== !1
    ? SO(e, t)
    : t
}
function WL(e, t, n = 0) {
  const r = [...e, t]
  return n && r.length > n ? r.slice(1) : r
}
function VL(e, t, n = 0) {
  const r = [t, ...e]
  return n && r.length > n ? r.slice(0, -1) : r
}
var EO = Symbol(),
  CO = (e, t) =>
    !e.queryFn && t != null && t.initialPromise
      ? () => t.initialPromise
      : !e.queryFn || e.queryFn === EO
      ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`))
      : e.queryFn,
  wa,
  go,
  Ql,
  hC,
  HL =
    ((hC = class extends Uc {
      constructor() {
        super()
        De(this, wa, void 0)
        De(this, go, void 0)
        De(this, Ql, void 0)
        ve(this, Ql, (t) => {
          if (!bc && window.addEventListener) {
            const n = () => t()
            return (
              window.addEventListener('visibilitychange', n, !1),
              () => {
                window.removeEventListener('visibilitychange', n)
              }
            )
          }
        })
      }
      onSubscribe() {
        M(this, go) || this.setEventListener(M(this, Ql))
      }
      onUnsubscribe() {
        var t
        this.hasListeners() || ((t = M(this, go)) == null || t.call(this), ve(this, go, void 0))
      }
      setEventListener(t) {
        var n
        ve(this, Ql, t),
          (n = M(this, go)) == null || n.call(this),
          ve(
            this,
            go,
            t((r) => {
              typeof r == 'boolean' ? this.setFocused(r) : this.onFocus()
            })
          )
      }
      setFocused(t) {
        M(this, wa) !== t && (ve(this, wa, t), this.onFocus())
      }
      onFocus() {
        const t = this.isFocused()
        this.listeners.forEach((n) => {
          n(t)
        })
      }
      isFocused() {
        var t
        return typeof M(this, wa) == 'boolean'
          ? M(this, wa)
          : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== 'hidden'
      }
    }),
    (wa = new WeakMap()),
    (go = new WeakMap()),
    (Ql = new WeakMap()),
    hC),
  Mw = new HL(),
  Xl,
  mo,
  Zl,
  pC,
  qL =
    ((pC = class extends Uc {
      constructor() {
        super()
        De(this, Xl, !0)
        De(this, mo, void 0)
        De(this, Zl, void 0)
        ve(this, Zl, (t) => {
          if (!bc && window.addEventListener) {
            const n = () => t(!0),
              r = () => t(!1)
            return (
              window.addEventListener('online', n, !1),
              window.addEventListener('offline', r, !1),
              () => {
                window.removeEventListener('online', n), window.removeEventListener('offline', r)
              }
            )
          }
        })
      }
      onSubscribe() {
        M(this, mo) || this.setEventListener(M(this, Zl))
      }
      onUnsubscribe() {
        var t
        this.hasListeners() || ((t = M(this, mo)) == null || t.call(this), ve(this, mo, void 0))
      }
      setEventListener(t) {
        var n
        ve(this, Zl, t),
          (n = M(this, mo)) == null || n.call(this),
          ve(this, mo, t(this.setOnline.bind(this)))
      }
      setOnline(t) {
        M(this, Xl) !== t &&
          (ve(this, Xl, t),
          this.listeners.forEach((r) => {
            r(t)
          }))
      }
      isOnline() {
        return M(this, Xl)
      }
    }),
    (Xl = new WeakMap()),
    (mo = new WeakMap()),
    (Zl = new WeakMap()),
    pC),
  Up = new qL()
function KL(e) {
  return Math.min(1e3 * 2 ** e, 3e4)
}
function _O(e) {
  return (e ?? 'online') === 'online' ? Up.isOnline() : !0
}
var OO = class {
  constructor(e) {
    ;(this.revert = e == null ? void 0 : e.revert), (this.silent = e == null ? void 0 : e.silent)
  }
}
function bm(e) {
  return e instanceof OO
}
function kO(e) {
  let t = !1,
    n = 0,
    r = !1,
    i,
    s,
    o
  const a = new Promise((y, v) => {
      ;(s = y), (o = v)
    }),
    l = (y) => {
      var v
      r || (h(new OO(y)), (v = e.abort) == null || v.call(e))
    },
    c = () => {
      t = !0
    },
    u = () => {
      t = !1
    },
    f = () => Mw.isFocused() && (e.networkMode === 'always' || Up.isOnline()) && e.canRun(),
    d = () => _O(e.networkMode) && e.canRun(),
    p = (y) => {
      var v
      r || ((r = !0), (v = e.onSuccess) == null || v.call(e, y), i == null || i(), s(y))
    },
    h = (y) => {
      var v
      r || ((r = !0), (v = e.onError) == null || v.call(e, y), i == null || i(), o(y))
    },
    m = () =>
      new Promise((y) => {
        var v
        ;(i = (S) => {
          ;(r || f()) && y(S)
        }),
          (v = e.onPause) == null || v.call(e)
      }).then(() => {
        var y
        ;(i = void 0), r || (y = e.onContinue) == null || y.call(e)
      }),
    b = () => {
      if (r) return
      let y
      const v = n === 0 ? e.initialPromise : void 0
      try {
        y = v ?? e.fn()
      } catch (S) {
        y = Promise.reject(S)
      }
      Promise.resolve(y)
        .then(p)
        .catch((S) => {
          var D
          if (r) return
          const T = e.retry ?? (bc ? 0 : 3),
            A = e.retryDelay ?? KL,
            I = typeof A == 'function' ? A(n, S) : A,
            k = T === !0 || (typeof T == 'number' && n < T) || (typeof T == 'function' && T(n, S))
          if (t || !k) {
            h(S)
            return
          }
          n++,
            (D = e.onFail) == null || D.call(e, n, S),
            zL(I)
              .then(() => (f() ? void 0 : m()))
              .then(() => {
                t ? h(S) : b()
              })
        })
    }
  return {
    promise: a,
    cancel: l,
    continue: () => (i == null || i(), a),
    cancelRetry: c,
    continueRetry: u,
    canStart: d,
    start: () => (d() ? b() : m().then(b), a),
  }
}
function GL() {
  let e = [],
    t = 0,
    n = (d) => {
      d()
    },
    r = (d) => {
      d()
    },
    i = (d) => setTimeout(d, 0)
  const s = (d) => {
      i = d
    },
    o = (d) => {
      let p
      t++
      try {
        p = d()
      } finally {
        t--, t || c()
      }
      return p
    },
    a = (d) => {
      t
        ? e.push(d)
        : i(() => {
            n(d)
          })
    },
    l =
      (d) =>
      (...p) => {
        a(() => {
          d(...p)
        })
      },
    c = () => {
      const d = e
      ;(e = []),
        d.length &&
          i(() => {
            r(() => {
              d.forEach((p) => {
                n(p)
              })
            })
          })
    }
  return {
    batch: o,
    batchCalls: l,
    schedule: a,
    setNotifyFunction: (d) => {
      n = d
    },
    setBatchNotifyFunction: (d) => {
      r = d
    },
    setScheduler: s,
  }
}
var hn = GL(),
  ba,
  gC,
  TO =
    ((gC = class {
      constructor() {
        De(this, ba, void 0)
      }
      destroy() {
        this.clearGcTimeout()
      }
      scheduleGc() {
        this.clearGcTimeout(),
          lv(this.gcTime) &&
            ve(
              this,
              ba,
              setTimeout(() => {
                this.optionalRemove()
              }, this.gcTime)
            )
      }
      updateGcTime(e) {
        this.gcTime = Math.max(this.gcTime || 0, e ?? (bc ? 1 / 0 : 5 * 60 * 1e3))
      }
      clearGcTimeout() {
        M(this, ba) && (clearTimeout(M(this, ba)), ve(this, ba, void 0))
      }
    }),
    (ba = new WeakMap()),
    gC),
  Jl,
  ec,
  Br,
  Mn,
  Df,
  xa,
  mi,
  ps,
  mC,
  YL =
    ((mC = class extends TO {
      constructor(t) {
        super()
        De(this, mi)
        De(this, Jl, void 0)
        De(this, ec, void 0)
        De(this, Br, void 0)
        De(this, Mn, void 0)
        De(this, Df, void 0)
        De(this, xa, void 0)
        ve(this, xa, !1),
          ve(this, Df, t.defaultOptions),
          this.setOptions(t.options),
          (this.observers = []),
          ve(this, Br, t.cache),
          (this.queryKey = t.queryKey),
          (this.queryHash = t.queryHash),
          ve(this, Jl, t.state || QL(this.options)),
          (this.state = M(this, Jl)),
          this.scheduleGc()
      }
      get meta() {
        return this.options.meta
      }
      get promise() {
        var t
        return (t = M(this, Mn)) == null ? void 0 : t.promise
      }
      setOptions(t) {
        ;(this.options = { ...M(this, Df), ...t }), this.updateGcTime(this.options.gcTime)
      }
      optionalRemove() {
        !this.observers.length && this.state.fetchStatus === 'idle' && M(this, Br).remove(this)
      }
      setData(t, n) {
        const r = uv(this.state.data, t, this.options)
        return (
          nt(this, mi, ps).call(this, {
            data: r,
            type: 'success',
            dataUpdatedAt: n == null ? void 0 : n.updatedAt,
            manual: n == null ? void 0 : n.manual,
          }),
          r
        )
      }
      setState(t, n) {
        nt(this, mi, ps).call(this, { type: 'setState', state: t, setStateOptions: n })
      }
      cancel(t) {
        var r, i
        const n = (r = M(this, Mn)) == null ? void 0 : r.promise
        return (
          (i = M(this, Mn)) == null || i.cancel(t), n ? n.then(zr).catch(zr) : Promise.resolve()
        )
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 })
      }
      reset() {
        this.destroy(), this.setState(M(this, Jl))
      }
      isActive() {
        return this.observers.some((t) => t.options.enabled !== !1)
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive()
      }
      isStale() {
        return this.state.isInvalidated
          ? !0
          : this.getObserversCount() > 0
          ? this.observers.some((t) => t.getCurrentResult().isStale)
          : this.state.data === void 0
      }
      isStaleByTime(t = 0) {
        return (
          this.state.isInvalidated || this.state.data === void 0 || !xO(this.state.dataUpdatedAt, t)
        )
      }
      onFocus() {
        var n
        const t = this.observers.find((r) => r.shouldFetchOnWindowFocus())
        t == null || t.refetch({ cancelRefetch: !1 }), (n = M(this, Mn)) == null || n.continue()
      }
      onOnline() {
        var n
        const t = this.observers.find((r) => r.shouldFetchOnReconnect())
        t == null || t.refetch({ cancelRefetch: !1 }), (n = M(this, Mn)) == null || n.continue()
      }
      addObserver(t) {
        this.observers.includes(t) ||
          (this.observers.push(t),
          this.clearGcTimeout(),
          M(this, Br).notify({ type: 'observerAdded', query: this, observer: t }))
      }
      removeObserver(t) {
        this.observers.includes(t) &&
          ((this.observers = this.observers.filter((n) => n !== t)),
          this.observers.length ||
            (M(this, Mn) &&
              (M(this, xa) ? M(this, Mn).cancel({ revert: !0 }) : M(this, Mn).cancelRetry()),
            this.scheduleGc()),
          M(this, Br).notify({ type: 'observerRemoved', query: this, observer: t }))
      }
      getObserversCount() {
        return this.observers.length
      }
      invalidate() {
        this.state.isInvalidated || nt(this, mi, ps).call(this, { type: 'invalidate' })
      }
      fetch(t, n) {
        var l, c, u
        if (this.state.fetchStatus !== 'idle') {
          if (this.state.data !== void 0 && n != null && n.cancelRefetch)
            this.cancel({ silent: !0 })
          else if (M(this, Mn)) return M(this, Mn).continueRetry(), M(this, Mn).promise
        }
        if ((t && this.setOptions(t), !this.options.queryFn)) {
          const f = this.observers.find((d) => d.options.queryFn)
          f && this.setOptions(f.options)
        }
        const r = new AbortController(),
          i = (f) => {
            Object.defineProperty(f, 'signal', {
              enumerable: !0,
              get: () => (ve(this, xa, !0), r.signal),
            })
          },
          s = () => {
            const f = CO(this.options, n),
              d = { queryKey: this.queryKey, meta: this.meta }
            return (
              i(d),
              ve(this, xa, !1),
              this.options.persister ? this.options.persister(f, d, this) : f(d)
            )
          },
          o = {
            fetchOptions: n,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: s,
          }
        i(o),
          (l = this.options.behavior) == null || l.onFetch(o, this),
          ve(this, ec, this.state),
          (this.state.fetchStatus === 'idle' ||
            this.state.fetchMeta !== ((c = o.fetchOptions) == null ? void 0 : c.meta)) &&
            nt(this, mi, ps).call(this, {
              type: 'fetch',
              meta: (u = o.fetchOptions) == null ? void 0 : u.meta,
            })
        const a = (f) => {
          var d, p, h, m
          ;(bm(f) && f.silent) || nt(this, mi, ps).call(this, { type: 'error', error: f }),
            bm(f) ||
              ((p = (d = M(this, Br).config).onError) == null || p.call(d, f, this),
              (m = (h = M(this, Br).config).onSettled) == null ||
                m.call(h, this.state.data, f, this)),
            this.isFetchingOptimistic || this.scheduleGc(),
            (this.isFetchingOptimistic = !1)
        }
        return (
          ve(
            this,
            Mn,
            kO({
              initialPromise: n == null ? void 0 : n.initialPromise,
              fn: o.fetchFn,
              abort: r.abort.bind(r),
              onSuccess: (f) => {
                var d, p, h, m
                if (f === void 0) {
                  a(new Error(`${this.queryHash} data is undefined`))
                  return
                }
                this.setData(f),
                  (p = (d = M(this, Br).config).onSuccess) == null || p.call(d, f, this),
                  (m = (h = M(this, Br).config).onSettled) == null ||
                    m.call(h, f, this.state.error, this),
                  this.isFetchingOptimistic || this.scheduleGc(),
                  (this.isFetchingOptimistic = !1)
              },
              onError: a,
              onFail: (f, d) => {
                nt(this, mi, ps).call(this, { type: 'failed', failureCount: f, error: d })
              },
              onPause: () => {
                nt(this, mi, ps).call(this, { type: 'pause' })
              },
              onContinue: () => {
                nt(this, mi, ps).call(this, { type: 'continue' })
              },
              retry: o.options.retry,
              retryDelay: o.options.retryDelay,
              networkMode: o.options.networkMode,
              canRun: () => !0,
            })
          ),
          M(this, Mn).start()
        )
      }
    }),
    (Jl = new WeakMap()),
    (ec = new WeakMap()),
    (Br = new WeakMap()),
    (Mn = new WeakMap()),
    (Df = new WeakMap()),
    (xa = new WeakMap()),
    (mi = new WeakSet()),
    (ps = function (t) {
      const n = (r) => {
        switch (t.type) {
          case 'failed':
            return { ...r, fetchFailureCount: t.failureCount, fetchFailureReason: t.error }
          case 'pause':
            return { ...r, fetchStatus: 'paused' }
          case 'continue':
            return { ...r, fetchStatus: 'fetching' }
          case 'fetch':
            return { ...r, ...AO(r.data, this.options), fetchMeta: t.meta ?? null }
          case 'success':
            return {
              ...r,
              data: t.data,
              dataUpdateCount: r.dataUpdateCount + 1,
              dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: !1,
              status: 'success',
              ...(!t.manual && {
                fetchStatus: 'idle',
                fetchFailureCount: 0,
                fetchFailureReason: null,
              }),
            }
          case 'error':
            const i = t.error
            return bm(i) && i.revert && M(this, ec)
              ? { ...M(this, ec), fetchStatus: 'idle' }
              : {
                  ...r,
                  error: i,
                  errorUpdateCount: r.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: r.fetchFailureCount + 1,
                  fetchFailureReason: i,
                  fetchStatus: 'idle',
                  status: 'error',
                }
          case 'invalidate':
            return { ...r, isInvalidated: !0 }
          case 'setState':
            return { ...r, ...t.state }
        }
      }
      ;(this.state = n(this.state)),
        hn.batch(() => {
          this.observers.forEach((r) => {
            r.onQueryUpdate()
          }),
            M(this, Br).notify({ query: this, type: 'updated', action: t })
        })
    }),
    mC)
function AO(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: _O(t.networkMode) ? 'fetching' : 'paused',
    ...(e === void 0 && { error: null, status: 'pending' }),
  }
}
function QL(e) {
  const t = typeof e.initialData == 'function' ? e.initialData() : e.initialData,
    n = t !== void 0,
    r = n
      ? typeof e.initialDataUpdatedAt == 'function'
        ? e.initialDataUpdatedAt()
        : e.initialDataUpdatedAt
      : 0
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? 'success' : 'pending',
    fetchStatus: 'idle',
  }
}
var Wi,
  yC,
  XL =
    ((yC = class extends Uc {
      constructor(t = {}) {
        super()
        De(this, Wi, void 0)
        ;(this.config = t), ve(this, Wi, new Map())
      }
      build(t, n, r) {
        const i = n.queryKey,
          s = n.queryHash ?? Nw(i, n)
        let o = this.get(s)
        return (
          o ||
            ((o = new YL({
              cache: this,
              queryKey: i,
              queryHash: s,
              options: t.defaultQueryOptions(n),
              state: r,
              defaultOptions: t.getQueryDefaults(i),
            })),
            this.add(o)),
          o
        )
      }
      add(t) {
        M(this, Wi).has(t.queryHash) ||
          (M(this, Wi).set(t.queryHash, t), this.notify({ type: 'added', query: t }))
      }
      remove(t) {
        const n = M(this, Wi).get(t.queryHash)
        n &&
          (t.destroy(),
          n === t && M(this, Wi).delete(t.queryHash),
          this.notify({ type: 'removed', query: t }))
      }
      clear() {
        hn.batch(() => {
          this.getAll().forEach((t) => {
            this.remove(t)
          })
        })
      }
      get(t) {
        return M(this, Wi).get(t)
      }
      getAll() {
        return [...M(this, Wi).values()]
      }
      find(t) {
        const n = { exact: !0, ...t }
        return this.getAll().find((r) => vS(n, r))
      }
      findAll(t = {}) {
        const n = this.getAll()
        return Object.keys(t).length > 0 ? n.filter((r) => vS(t, r)) : n
      }
      notify(t) {
        hn.batch(() => {
          this.listeners.forEach((n) => {
            n(t)
          })
        })
      }
      onFocus() {
        hn.batch(() => {
          this.getAll().forEach((t) => {
            t.onFocus()
          })
        })
      }
      onOnline() {
        hn.batch(() => {
          this.getAll().forEach((t) => {
            t.onOnline()
          })
        })
      }
    }),
    (Wi = new WeakMap()),
    yC),
  Vi,
  Vn,
  Sa,
  Hi,
  so,
  vC,
  ZL =
    ((vC = class extends TO {
      constructor(t) {
        super()
        De(this, Hi)
        De(this, Vi, void 0)
        De(this, Vn, void 0)
        De(this, Sa, void 0)
        ;(this.mutationId = t.mutationId),
          ve(this, Vn, t.mutationCache),
          ve(this, Vi, []),
          (this.state = t.state || RO()),
          this.setOptions(t.options),
          this.scheduleGc()
      }
      setOptions(t) {
        ;(this.options = t), this.updateGcTime(this.options.gcTime)
      }
      get meta() {
        return this.options.meta
      }
      addObserver(t) {
        M(this, Vi).includes(t) ||
          (M(this, Vi).push(t),
          this.clearGcTimeout(),
          M(this, Vn).notify({ type: 'observerAdded', mutation: this, observer: t }))
      }
      removeObserver(t) {
        ve(
          this,
          Vi,
          M(this, Vi).filter((n) => n !== t)
        ),
          this.scheduleGc(),
          M(this, Vn).notify({ type: 'observerRemoved', mutation: this, observer: t })
      }
      optionalRemove() {
        M(this, Vi).length ||
          (this.state.status === 'pending' ? this.scheduleGc() : M(this, Vn).remove(this))
      }
      continue() {
        var t
        return (
          ((t = M(this, Sa)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables)
        )
      }
      async execute(t) {
        var i, s, o, a, l, c, u, f, d, p, h, m, b, y, v, S, T, A, I, k
        ve(
          this,
          Sa,
          kO({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(t)
                : Promise.reject(new Error('No mutationFn found')),
            onFail: (D, F) => {
              nt(this, Hi, so).call(this, { type: 'failed', failureCount: D, error: F })
            },
            onPause: () => {
              nt(this, Hi, so).call(this, { type: 'pause' })
            },
            onContinue: () => {
              nt(this, Hi, so).call(this, { type: 'continue' })
            },
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => M(this, Vn).canRun(this),
          })
        )
        const n = this.state.status === 'pending',
          r = !M(this, Sa).canStart()
        try {
          if (!n) {
            nt(this, Hi, so).call(this, { type: 'pending', variables: t, isPaused: r }),
              await ((s = (i = M(this, Vn).config).onMutate) == null ? void 0 : s.call(i, t, this))
            const F = await ((a = (o = this.options).onMutate) == null ? void 0 : a.call(o, t))
            F !== this.state.context &&
              nt(this, Hi, so).call(this, {
                type: 'pending',
                context: F,
                variables: t,
                isPaused: r,
              })
          }
          const D = await M(this, Sa).start()
          return (
            await ((c = (l = M(this, Vn).config).onSuccess) == null
              ? void 0
              : c.call(l, D, t, this.state.context, this)),
            await ((f = (u = this.options).onSuccess) == null
              ? void 0
              : f.call(u, D, t, this.state.context)),
            await ((p = (d = M(this, Vn).config).onSettled) == null
              ? void 0
              : p.call(d, D, null, this.state.variables, this.state.context, this)),
            await ((m = (h = this.options).onSettled) == null
              ? void 0
              : m.call(h, D, null, t, this.state.context)),
            nt(this, Hi, so).call(this, { type: 'success', data: D }),
            D
          )
        } catch (D) {
          try {
            throw (
              (await ((y = (b = M(this, Vn).config).onError) == null
                ? void 0
                : y.call(b, D, t, this.state.context, this)),
              await ((S = (v = this.options).onError) == null
                ? void 0
                : S.call(v, D, t, this.state.context)),
              await ((A = (T = M(this, Vn).config).onSettled) == null
                ? void 0
                : A.call(T, void 0, D, this.state.variables, this.state.context, this)),
              await ((k = (I = this.options).onSettled) == null
                ? void 0
                : k.call(I, void 0, D, t, this.state.context)),
              D)
            )
          } finally {
            nt(this, Hi, so).call(this, { type: 'error', error: D })
          }
        } finally {
          M(this, Vn).runNext(this)
        }
      }
    }),
    (Vi = new WeakMap()),
    (Vn = new WeakMap()),
    (Sa = new WeakMap()),
    (Hi = new WeakSet()),
    (so = function (t) {
      const n = (r) => {
        switch (t.type) {
          case 'failed':
            return { ...r, failureCount: t.failureCount, failureReason: t.error }
          case 'pause':
            return { ...r, isPaused: !0 }
          case 'continue':
            return { ...r, isPaused: !1 }
          case 'pending':
            return {
              ...r,
              context: t.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: t.isPaused,
              status: 'pending',
              variables: t.variables,
              submittedAt: Date.now(),
            }
          case 'success':
            return {
              ...r,
              data: t.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: 'success',
              isPaused: !1,
            }
          case 'error':
            return {
              ...r,
              data: void 0,
              error: t.error,
              failureCount: r.failureCount + 1,
              failureReason: t.error,
              isPaused: !1,
              status: 'error',
            }
        }
      }
      ;(this.state = n(this.state)),
        hn.batch(() => {
          M(this, Vi).forEach((r) => {
            r.onMutationUpdate(t)
          }),
            M(this, Vn).notify({ mutation: this, type: 'updated', action: t })
        })
    }),
    vC)
function RO() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: 'idle',
    variables: void 0,
    submittedAt: 0,
  }
}
var yr,
  Nf,
  wC,
  JL =
    ((wC = class extends Uc {
      constructor(t = {}) {
        super()
        De(this, yr, void 0)
        De(this, Nf, void 0)
        ;(this.config = t), ve(this, yr, new Map()), ve(this, Nf, Date.now())
      }
      build(t, n, r) {
        const i = new ZL({
          mutationCache: this,
          mutationId: ++ud(this, Nf)._,
          options: t.defaultMutationOptions(n),
          state: r,
        })
        return this.add(i), i
      }
      add(t) {
        const n = $d(t),
          r = M(this, yr).get(n) ?? []
        r.push(t), M(this, yr).set(n, r), this.notify({ type: 'added', mutation: t })
      }
      remove(t) {
        var r
        const n = $d(t)
        if (M(this, yr).has(n)) {
          const i = (r = M(this, yr).get(n)) == null ? void 0 : r.filter((s) => s !== t)
          i && (i.length === 0 ? M(this, yr).delete(n) : M(this, yr).set(n, i))
        }
        this.notify({ type: 'removed', mutation: t })
      }
      canRun(t) {
        var r
        const n =
          (r = M(this, yr).get($d(t))) == null
            ? void 0
            : r.find((i) => i.state.status === 'pending')
        return !n || n === t
      }
      runNext(t) {
        var r
        const n =
          (r = M(this, yr).get($d(t))) == null ? void 0 : r.find((i) => i !== t && i.state.isPaused)
        return (n == null ? void 0 : n.continue()) ?? Promise.resolve()
      }
      clear() {
        hn.batch(() => {
          this.getAll().forEach((t) => {
            this.remove(t)
          })
        })
      }
      getAll() {
        return [...M(this, yr).values()].flat()
      }
      find(t) {
        const n = { exact: !0, ...t }
        return this.getAll().find((r) => wS(n, r))
      }
      findAll(t = {}) {
        return this.getAll().filter((n) => wS(t, n))
      }
      notify(t) {
        hn.batch(() => {
          this.listeners.forEach((n) => {
            n(t)
          })
        })
      }
      resumePausedMutations() {
        const t = this.getAll().filter((n) => n.state.isPaused)
        return hn.batch(() => Promise.all(t.map((n) => n.continue().catch(zr))))
      }
    }),
    (yr = new WeakMap()),
    (Nf = new WeakMap()),
    wC)
function $d(e) {
  var t
  return ((t = e.options.scope) == null ? void 0 : t.id) ?? String(e.mutationId)
}
function e7(e) {
  return {
    onFetch: (t, n) => {
      const r = async () => {
        var h, m, b, y, v
        const i = t.options,
          s =
            (b =
              (m = (h = t.fetchOptions) == null ? void 0 : h.meta) == null
                ? void 0
                : m.fetchMore) == null
              ? void 0
              : b.direction,
          o = ((y = t.state.data) == null ? void 0 : y.pages) || [],
          a = ((v = t.state.data) == null ? void 0 : v.pageParams) || [],
          l = { pages: [], pageParams: [] }
        let c = !1
        const u = (S) => {
            Object.defineProperty(S, 'signal', {
              enumerable: !0,
              get: () => (
                t.signal.aborted
                  ? (c = !0)
                  : t.signal.addEventListener('abort', () => {
                      c = !0
                    }),
                t.signal
              ),
            })
          },
          f = CO(t.options, t.fetchOptions),
          d = async (S, T, A) => {
            if (c) return Promise.reject()
            if (T == null && S.pages.length) return Promise.resolve(S)
            const I = {
              queryKey: t.queryKey,
              pageParam: T,
              direction: A ? 'backward' : 'forward',
              meta: t.options.meta,
            }
            u(I)
            const k = await f(I),
              { maxPages: D } = t.options,
              F = A ? VL : WL
            return { pages: F(S.pages, k, D), pageParams: F(S.pageParams, T, D) }
          }
        let p
        if (s && o.length) {
          const S = s === 'backward',
            T = S ? t7 : SS,
            A = { pages: o, pageParams: a },
            I = T(i, A)
          p = await d(A, I, S)
        } else {
          p = await d(l, a[0] ?? i.initialPageParam)
          const S = e ?? o.length
          for (let T = 1; T < S; T++) {
            const A = SS(i, p)
            p = await d(p, A)
          }
        }
        return p
      }
      t.options.persister
        ? (t.fetchFn = () => {
            var i, s
            return (s = (i = t.options).persister) == null
              ? void 0
              : s.call(i, r, { queryKey: t.queryKey, meta: t.options.meta, signal: t.signal }, n)
          })
        : (t.fetchFn = r)
    },
  }
}
function SS(e, { pages: t, pageParams: n }) {
  const r = t.length - 1
  return e.getNextPageParam(t[r], t, n[r], n)
}
function t7(e, { pages: t, pageParams: n }) {
  var r
  return (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n)
}
var Kt,
  yo,
  vo,
  tc,
  nc,
  wo,
  rc,
  ic,
  bC,
  n7 =
    ((bC = class {
      constructor(e = {}) {
        De(this, Kt, void 0)
        De(this, yo, void 0)
        De(this, vo, void 0)
        De(this, tc, void 0)
        De(this, nc, void 0)
        De(this, wo, void 0)
        De(this, rc, void 0)
        De(this, ic, void 0)
        ve(this, Kt, e.queryCache || new XL()),
          ve(this, yo, e.mutationCache || new JL()),
          ve(this, vo, e.defaultOptions || {}),
          ve(this, tc, new Map()),
          ve(this, nc, new Map()),
          ve(this, wo, 0)
      }
      mount() {
        ud(this, wo)._++,
          M(this, wo) === 1 &&
            (ve(
              this,
              rc,
              Mw.subscribe(async (e) => {
                e && (await this.resumePausedMutations(), M(this, Kt).onFocus())
              })
            ),
            ve(
              this,
              ic,
              Up.subscribe(async (e) => {
                e && (await this.resumePausedMutations(), M(this, Kt).onOnline())
              })
            ))
      }
      unmount() {
        var e, t
        ud(this, wo)._--,
          M(this, wo) === 0 &&
            ((e = M(this, rc)) == null || e.call(this),
            ve(this, rc, void 0),
            (t = M(this, ic)) == null || t.call(this),
            ve(this, ic, void 0))
      }
      isFetching(e) {
        return M(this, Kt).findAll({ ...e, fetchStatus: 'fetching' }).length
      }
      isMutating(e) {
        return M(this, yo).findAll({ ...e, status: 'pending' }).length
      }
      getQueryData(e) {
        var n
        const t = this.defaultQueryOptions({ queryKey: e })
        return (n = M(this, Kt).get(t.queryHash)) == null ? void 0 : n.state.data
      }
      ensureQueryData(e) {
        const t = this.getQueryData(e.queryKey)
        if (t === void 0) return this.fetchQuery(e)
        {
          const n = this.defaultQueryOptions(e),
            r = M(this, Kt).build(this, n)
          return (
            e.revalidateIfStale && r.isStaleByTime(n.staleTime) && this.prefetchQuery(n),
            Promise.resolve(t)
          )
        }
      }
      getQueriesData(e) {
        return M(this, Kt)
          .findAll(e)
          .map(({ queryKey: t, state: n }) => {
            const r = n.data
            return [t, r]
          })
      }
      setQueryData(e, t, n) {
        const r = this.defaultQueryOptions({ queryKey: e }),
          i = M(this, Kt).get(r.queryHash),
          s = i == null ? void 0 : i.state.data,
          o = UL(t, s)
        if (o !== void 0)
          return M(this, Kt)
            .build(this, r)
            .setData(o, { ...n, manual: !0 })
      }
      setQueriesData(e, t, n) {
        return hn.batch(() =>
          M(this, Kt)
            .findAll(e)
            .map(({ queryKey: r }) => [r, this.setQueryData(r, t, n)])
        )
      }
      getQueryState(e) {
        var n
        const t = this.defaultQueryOptions({ queryKey: e })
        return (n = M(this, Kt).get(t.queryHash)) == null ? void 0 : n.state
      }
      removeQueries(e) {
        const t = M(this, Kt)
        hn.batch(() => {
          t.findAll(e).forEach((n) => {
            t.remove(n)
          })
        })
      }
      resetQueries(e, t) {
        const n = M(this, Kt),
          r = { type: 'active', ...e }
        return hn.batch(
          () => (
            n.findAll(e).forEach((i) => {
              i.reset()
            }),
            this.refetchQueries(r, t)
          )
        )
      }
      cancelQueries(e = {}, t = {}) {
        const n = { revert: !0, ...t },
          r = hn.batch(() =>
            M(this, Kt)
              .findAll(e)
              .map((i) => i.cancel(n))
          )
        return Promise.all(r).then(zr).catch(zr)
      }
      invalidateQueries(e = {}, t = {}) {
        return hn.batch(() => {
          if (
            (M(this, Kt)
              .findAll(e)
              .forEach((r) => {
                r.invalidate()
              }),
            e.refetchType === 'none')
          )
            return Promise.resolve()
          const n = { ...e, type: e.refetchType ?? e.type ?? 'active' }
          return this.refetchQueries(n, t)
        })
      }
      refetchQueries(e = {}, t) {
        const n = { ...t, cancelRefetch: (t == null ? void 0 : t.cancelRefetch) ?? !0 },
          r = hn.batch(() =>
            M(this, Kt)
              .findAll(e)
              .filter((i) => !i.isDisabled())
              .map((i) => {
                let s = i.fetch(void 0, n)
                return (
                  n.throwOnError || (s = s.catch(zr)),
                  i.state.fetchStatus === 'paused' ? Promise.resolve() : s
                )
              })
          )
        return Promise.all(r).then(zr)
      }
      fetchQuery(e) {
        const t = this.defaultQueryOptions(e)
        t.retry === void 0 && (t.retry = !1)
        const n = M(this, Kt).build(this, t)
        return n.isStaleByTime(t.staleTime) ? n.fetch(t) : Promise.resolve(n.state.data)
      }
      prefetchQuery(e) {
        return this.fetchQuery(e).then(zr).catch(zr)
      }
      fetchInfiniteQuery(e) {
        return (e.behavior = e7(e.pages)), this.fetchQuery(e)
      }
      prefetchInfiniteQuery(e) {
        return this.fetchInfiniteQuery(e).then(zr).catch(zr)
      }
      resumePausedMutations() {
        return Up.isOnline() ? M(this, yo).resumePausedMutations() : Promise.resolve()
      }
      getQueryCache() {
        return M(this, Kt)
      }
      getMutationCache() {
        return M(this, yo)
      }
      getDefaultOptions() {
        return M(this, vo)
      }
      setDefaultOptions(e) {
        ve(this, vo, e)
      }
      setQueryDefaults(e, t) {
        M(this, tc).set(Ua(e), { queryKey: e, defaultOptions: t })
      }
      getQueryDefaults(e) {
        const t = [...M(this, tc).values()]
        let n = {}
        return (
          t.forEach((r) => {
            wf(e, r.queryKey) && (n = { ...n, ...r.defaultOptions })
          }),
          n
        )
      }
      setMutationDefaults(e, t) {
        M(this, nc).set(Ua(e), { mutationKey: e, defaultOptions: t })
      }
      getMutationDefaults(e) {
        const t = [...M(this, nc).values()]
        let n = {}
        return (
          t.forEach((r) => {
            wf(e, r.mutationKey) && (n = { ...n, ...r.defaultOptions })
          }),
          n
        )
      }
      defaultQueryOptions(e) {
        if (e._defaulted) return e
        const t = {
          ...M(this, vo).queries,
          ...this.getQueryDefaults(e.queryKey),
          ...e,
          _defaulted: !0,
        }
        return (
          t.queryHash || (t.queryHash = Nw(t.queryKey, t)),
          t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== 'always'),
          t.throwOnError === void 0 && (t.throwOnError = !!t.suspense),
          !t.networkMode && t.persister && (t.networkMode = 'offlineFirst'),
          t.enabled !== !0 && t.queryFn === EO && (t.enabled = !1),
          t
        )
      }
      defaultMutationOptions(e) {
        return e != null && e._defaulted
          ? e
          : {
              ...M(this, vo).mutations,
              ...((e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey)),
              ...e,
              _defaulted: !0,
            }
      }
      clear() {
        M(this, Kt).clear(), M(this, yo).clear()
      }
    }),
    (Kt = new WeakMap()),
    (yo = new WeakMap()),
    (vo = new WeakMap()),
    (tc = new WeakMap()),
    (nc = new WeakMap()),
    (wo = new WeakMap()),
    (rc = new WeakMap()),
    (ic = new WeakMap()),
    bC),
  nr,
  At,
  Mf,
  Hn,
  Ea,
  sc,
  qi,
  jf,
  oc,
  ac,
  Ca,
  _a,
  bo,
  lc,
  Oa,
  bu,
  Lf,
  fv,
  $f,
  dv,
  Ff,
  hv,
  Bf,
  pv,
  Uf,
  gv,
  zf,
  mv,
  Wf,
  yv,
  m0,
  PO,
  xC,
  r7 =
    ((xC = class extends Uc {
      constructor(t, n) {
        super()
        De(this, Oa)
        De(this, Lf)
        De(this, $f)
        De(this, Ff)
        De(this, Bf)
        De(this, Uf)
        De(this, zf)
        De(this, Wf)
        De(this, m0)
        De(this, nr, void 0)
        De(this, At, void 0)
        De(this, Mf, void 0)
        De(this, Hn, void 0)
        De(this, Ea, void 0)
        De(this, sc, void 0)
        De(this, qi, void 0)
        De(this, jf, void 0)
        De(this, oc, void 0)
        De(this, ac, void 0)
        De(this, Ca, void 0)
        De(this, _a, void 0)
        De(this, bo, void 0)
        De(this, lc, new Set())
        ;(this.options = n),
          ve(this, nr, t),
          ve(this, qi, null),
          this.bindMethods(),
          this.setOptions(n)
      }
      bindMethods() {
        this.refetch = this.refetch.bind(this)
      }
      onSubscribe() {
        this.listeners.size === 1 &&
          (M(this, At).addObserver(this),
          ES(M(this, At), this.options) ? nt(this, Oa, bu).call(this) : this.updateResult(),
          nt(this, Bf, pv).call(this))
      }
      onUnsubscribe() {
        this.hasListeners() || this.destroy()
      }
      shouldFetchOnReconnect() {
        return vv(M(this, At), this.options, this.options.refetchOnReconnect)
      }
      shouldFetchOnWindowFocus() {
        return vv(M(this, At), this.options, this.options.refetchOnWindowFocus)
      }
      destroy() {
        ;(this.listeners = new Set()),
          nt(this, Uf, gv).call(this),
          nt(this, zf, mv).call(this),
          M(this, At).removeObserver(this)
      }
      setOptions(t, n) {
        const r = this.options,
          i = M(this, At)
        if (
          ((this.options = M(this, nr).defaultQueryOptions(t)),
          this.options.enabled !== void 0 && typeof this.options.enabled != 'boolean')
        )
          throw new Error('Expected enabled to be a boolean')
        nt(this, Wf, yv).call(this),
          M(this, At).setOptions(this.options),
          r._defaulted &&
            !Bp(this.options, r) &&
            M(this, nr)
              .getQueryCache()
              .notify({ type: 'observerOptionsUpdated', query: M(this, At), observer: this })
        const s = this.hasListeners()
        s && CS(M(this, At), i, this.options, r) && nt(this, Oa, bu).call(this),
          this.updateResult(n),
          s &&
            (M(this, At) !== i ||
              this.options.enabled !== r.enabled ||
              this.options.staleTime !== r.staleTime) &&
            nt(this, Lf, fv).call(this)
        const o = nt(this, $f, dv).call(this)
        s &&
          (M(this, At) !== i || this.options.enabled !== r.enabled || o !== M(this, bo)) &&
          nt(this, Ff, hv).call(this, o)
      }
      getOptimisticResult(t) {
        const n = M(this, nr).getQueryCache().build(M(this, nr), t),
          r = this.createResult(n, t)
        return (
          s7(this, r) &&
            (ve(this, Hn, r), ve(this, sc, this.options), ve(this, Ea, M(this, At).state)),
          r
        )
      }
      getCurrentResult() {
        return M(this, Hn)
      }
      trackResult(t, n) {
        const r = {}
        return (
          Object.keys(t).forEach((i) => {
            Object.defineProperty(r, i, {
              configurable: !1,
              enumerable: !0,
              get: () => (this.trackProp(i), n == null || n(i), t[i]),
            })
          }),
          r
        )
      }
      trackProp(t) {
        M(this, lc).add(t)
      }
      getCurrentQuery() {
        return M(this, At)
      }
      refetch({ ...t } = {}) {
        return this.fetch({ ...t })
      }
      fetchOptimistic(t) {
        const n = M(this, nr).defaultQueryOptions(t),
          r = M(this, nr).getQueryCache().build(M(this, nr), n)
        return (r.isFetchingOptimistic = !0), r.fetch().then(() => this.createResult(r, n))
      }
      fetch(t) {
        return nt(this, Oa, bu)
          .call(this, { ...t, cancelRefetch: t.cancelRefetch ?? !0 })
          .then(() => (this.updateResult(), M(this, Hn)))
      }
      createResult(t, n) {
        var k
        const r = M(this, At),
          i = this.options,
          s = M(this, Hn),
          o = M(this, Ea),
          a = M(this, sc),
          c = t !== r ? t.state : M(this, Mf),
          { state: u } = t
        let f = { ...u },
          d = !1,
          p
        if (n._optimisticResults) {
          const D = this.hasListeners(),
            F = !D && ES(t, n),
            V = D && CS(t, r, n, i)
          ;(F || V) && (f = { ...f, ...AO(u.data, t.options) }),
            n._optimisticResults === 'isRestoring' && (f.fetchStatus = 'idle')
        }
        let { error: h, errorUpdatedAt: m, status: b } = f
        if (n.select && f.data !== void 0)
          if (s && f.data === (o == null ? void 0 : o.data) && n.select === M(this, jf))
            p = M(this, oc)
          else
            try {
              ve(this, jf, n.select),
                (p = n.select(f.data)),
                (p = uv(s == null ? void 0 : s.data, p, n)),
                ve(this, oc, p),
                ve(this, qi, null)
            } catch (D) {
              ve(this, qi, D)
            }
        else p = f.data
        if (n.placeholderData !== void 0 && p === void 0 && b === 'pending') {
          let D
          if (
            s != null &&
            s.isPlaceholderData &&
            n.placeholderData === (a == null ? void 0 : a.placeholderData)
          )
            D = s.data
          else if (
            ((D =
              typeof n.placeholderData == 'function'
                ? n.placeholderData((k = M(this, ac)) == null ? void 0 : k.state.data, M(this, ac))
                : n.placeholderData),
            n.select && D !== void 0)
          )
            try {
              ;(D = n.select(D)), ve(this, qi, null)
            } catch (F) {
              ve(this, qi, F)
            }
          D !== void 0 && ((b = 'success'), (p = uv(s == null ? void 0 : s.data, D, n)), (d = !0))
        }
        M(this, qi) && ((h = M(this, qi)), (p = M(this, oc)), (m = Date.now()), (b = 'error'))
        const y = f.fetchStatus === 'fetching',
          v = b === 'pending',
          S = b === 'error',
          T = v && y,
          A = p !== void 0
        return {
          status: b,
          fetchStatus: f.fetchStatus,
          isPending: v,
          isSuccess: b === 'success',
          isError: S,
          isInitialLoading: T,
          isLoading: T,
          data: p,
          dataUpdatedAt: f.dataUpdatedAt,
          error: h,
          errorUpdatedAt: m,
          failureCount: f.fetchFailureCount,
          failureReason: f.fetchFailureReason,
          errorUpdateCount: f.errorUpdateCount,
          isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
          isFetchedAfterMount:
            f.dataUpdateCount > c.dataUpdateCount || f.errorUpdateCount > c.errorUpdateCount,
          isFetching: y,
          isRefetching: y && !v,
          isLoadingError: S && !A,
          isPaused: f.fetchStatus === 'paused',
          isPlaceholderData: d,
          isRefetchError: S && A,
          isStale: jw(t, n),
          refetch: this.refetch,
        }
      }
      updateResult(t) {
        const n = M(this, Hn),
          r = this.createResult(M(this, At), this.options)
        if (
          (ve(this, Ea, M(this, At).state),
          ve(this, sc, this.options),
          M(this, Ea).data !== void 0 && ve(this, ac, M(this, At)),
          Bp(r, n))
        )
          return
        ve(this, Hn, r)
        const i = {},
          s = () => {
            if (!n) return !0
            const { notifyOnChangeProps: o } = this.options,
              a = typeof o == 'function' ? o() : o
            if (a === 'all' || (!a && !M(this, lc).size)) return !0
            const l = new Set(a ?? M(this, lc))
            return (
              this.options.throwOnError && l.add('error'),
              Object.keys(M(this, Hn)).some((c) => {
                const u = c
                return M(this, Hn)[u] !== n[u] && l.has(u)
              })
            )
          }
        ;(t == null ? void 0 : t.listeners) !== !1 && s() && (i.listeners = !0),
          nt(this, m0, PO).call(this, { ...i, ...t })
      }
      onQueryUpdate() {
        this.updateResult(), this.hasListeners() && nt(this, Bf, pv).call(this)
      }
    }),
    (nr = new WeakMap()),
    (At = new WeakMap()),
    (Mf = new WeakMap()),
    (Hn = new WeakMap()),
    (Ea = new WeakMap()),
    (sc = new WeakMap()),
    (qi = new WeakMap()),
    (jf = new WeakMap()),
    (oc = new WeakMap()),
    (ac = new WeakMap()),
    (Ca = new WeakMap()),
    (_a = new WeakMap()),
    (bo = new WeakMap()),
    (lc = new WeakMap()),
    (Oa = new WeakSet()),
    (bu = function (t) {
      nt(this, Wf, yv).call(this)
      let n = M(this, At).fetch(this.options, t)
      return (t != null && t.throwOnError) || (n = n.catch(zr)), n
    }),
    (Lf = new WeakSet()),
    (fv = function () {
      if ((nt(this, Uf, gv).call(this), bc || M(this, Hn).isStale || !lv(this.options.staleTime)))
        return
      const n = xO(M(this, Hn).dataUpdatedAt, this.options.staleTime) + 1
      ve(
        this,
        Ca,
        setTimeout(() => {
          M(this, Hn).isStale || this.updateResult()
        }, n)
      )
    }),
    ($f = new WeakSet()),
    (dv = function () {
      return (
        (typeof this.options.refetchInterval == 'function'
          ? this.options.refetchInterval(M(this, At))
          : this.options.refetchInterval) ?? !1
      )
    }),
    (Ff = new WeakSet()),
    (hv = function (t) {
      nt(this, zf, mv).call(this),
        ve(this, bo, t),
        !(bc || this.options.enabled === !1 || !lv(M(this, bo)) || M(this, bo) === 0) &&
          ve(
            this,
            _a,
            setInterval(() => {
              ;(this.options.refetchIntervalInBackground || Mw.isFocused()) &&
                nt(this, Oa, bu).call(this)
            }, M(this, bo))
          )
    }),
    (Bf = new WeakSet()),
    (pv = function () {
      nt(this, Lf, fv).call(this), nt(this, Ff, hv).call(this, nt(this, $f, dv).call(this))
    }),
    (Uf = new WeakSet()),
    (gv = function () {
      M(this, Ca) && (clearTimeout(M(this, Ca)), ve(this, Ca, void 0))
    }),
    (zf = new WeakSet()),
    (mv = function () {
      M(this, _a) && (clearInterval(M(this, _a)), ve(this, _a, void 0))
    }),
    (Wf = new WeakSet()),
    (yv = function () {
      const t = M(this, nr).getQueryCache().build(M(this, nr), this.options)
      if (t === M(this, At)) return
      const n = M(this, At)
      ve(this, At, t),
        ve(this, Mf, t.state),
        this.hasListeners() && (n == null || n.removeObserver(this), t.addObserver(this))
    }),
    (m0 = new WeakSet()),
    (PO = function (t) {
      hn.batch(() => {
        t.listeners &&
          this.listeners.forEach((n) => {
            n(M(this, Hn))
          }),
          M(this, nr)
            .getQueryCache()
            .notify({ query: M(this, At), type: 'observerResultsUpdated' })
      })
    }),
    xC)
function i7(e, t) {
  return (
    t.enabled !== !1 &&
    e.state.data === void 0 &&
    !(e.state.status === 'error' && t.retryOnMount === !1)
  )
}
function ES(e, t) {
  return i7(e, t) || (e.state.data !== void 0 && vv(e, t, t.refetchOnMount))
}
function vv(e, t, n) {
  if (t.enabled !== !1) {
    const r = typeof n == 'function' ? n(e) : n
    return r === 'always' || (r !== !1 && jw(e, t))
  }
  return !1
}
function CS(e, t, n, r) {
  return (e !== t || r.enabled === !1) && (!n.suspense || e.state.status !== 'error') && jw(e, n)
}
function jw(e, t) {
  return t.enabled !== !1 && e.isStaleByTime(t.staleTime)
}
function s7(e, t) {
  return !Bp(e.getCurrentResult(), t)
}
var xo,
  So,
  rr,
  Es,
  cc,
  _h,
  Vf,
  wv,
  SC,
  o7 =
    ((SC = class extends Uc {
      constructor(n, r) {
        super()
        De(this, cc)
        De(this, Vf)
        De(this, xo, void 0)
        De(this, So, void 0)
        De(this, rr, void 0)
        De(this, Es, void 0)
        ve(this, xo, n), this.setOptions(r), this.bindMethods(), nt(this, cc, _h).call(this)
      }
      bindMethods() {
        ;(this.mutate = this.mutate.bind(this)), (this.reset = this.reset.bind(this))
      }
      setOptions(n) {
        var i
        const r = this.options
        ;(this.options = M(this, xo).defaultMutationOptions(n)),
          Bp(this.options, r) ||
            M(this, xo)
              .getMutationCache()
              .notify({ type: 'observerOptionsUpdated', mutation: M(this, rr), observer: this }),
          r != null &&
          r.mutationKey &&
          this.options.mutationKey &&
          Ua(r.mutationKey) !== Ua(this.options.mutationKey)
            ? this.reset()
            : ((i = M(this, rr)) == null ? void 0 : i.state.status) === 'pending' &&
              M(this, rr).setOptions(this.options)
      }
      onUnsubscribe() {
        var n
        this.hasListeners() || (n = M(this, rr)) == null || n.removeObserver(this)
      }
      onMutationUpdate(n) {
        nt(this, cc, _h).call(this), nt(this, Vf, wv).call(this, n)
      }
      getCurrentResult() {
        return M(this, So)
      }
      reset() {
        var n
        ;(n = M(this, rr)) == null || n.removeObserver(this),
          ve(this, rr, void 0),
          nt(this, cc, _h).call(this),
          nt(this, Vf, wv).call(this)
      }
      mutate(n, r) {
        var i
        return (
          ve(this, Es, r),
          (i = M(this, rr)) == null || i.removeObserver(this),
          ve(this, rr, M(this, xo).getMutationCache().build(M(this, xo), this.options)),
          M(this, rr).addObserver(this),
          M(this, rr).execute(n)
        )
      }
    }),
    (xo = new WeakMap()),
    (So = new WeakMap()),
    (rr = new WeakMap()),
    (Es = new WeakMap()),
    (cc = new WeakSet()),
    (_h = function () {
      var r
      const n = ((r = M(this, rr)) == null ? void 0 : r.state) ?? RO()
      ve(this, So, {
        ...n,
        isPending: n.status === 'pending',
        isSuccess: n.status === 'success',
        isError: n.status === 'error',
        isIdle: n.status === 'idle',
        mutate: this.mutate,
        reset: this.reset,
      })
    }),
    (Vf = new WeakSet()),
    (wv = function (n) {
      hn.batch(() => {
        var r, i, s, o, a, l, c, u
        if (M(this, Es) && this.hasListeners()) {
          const f = M(this, So).variables,
            d = M(this, So).context
          ;(n == null ? void 0 : n.type) === 'success'
            ? ((i = (r = M(this, Es)).onSuccess) == null || i.call(r, n.data, f, d),
              (o = (s = M(this, Es)).onSettled) == null || o.call(s, n.data, null, f, d))
            : (n == null ? void 0 : n.type) === 'error' &&
              ((l = (a = M(this, Es)).onError) == null || l.call(a, n.error, f, d),
              (u = (c = M(this, Es)).onSettled) == null || u.call(c, void 0, n.error, f, d))
        }
        this.listeners.forEach((f) => {
          f(M(this, So))
        })
      })
    }),
    SC),
  IO = w.createContext(void 0),
  DO = (e) => {
    const t = w.useContext(IO)
    if (e) return e
    if (!t) throw new Error('No QueryClient set, use QueryClientProvider to set one')
    return t
  },
  a7 = ({ client: e, children: t }) => (
    w.useEffect(
      () => (
        e.mount(),
        () => {
          e.unmount()
        }
      ),
      [e]
    ),
    E.jsx(IO.Provider, { value: e, children: t })
  ),
  NO = w.createContext(!1),
  l7 = () => w.useContext(NO)
NO.Provider
function c7() {
  let e = !1
  return {
    clearReset: () => {
      e = !1
    },
    reset: () => {
      e = !0
    },
    isReset: () => e,
  }
}
var u7 = w.createContext(c7()),
  f7 = () => w.useContext(u7)
function MO(e, t) {
  return typeof e == 'function' ? e(...t) : !!e
}
function d7() {}
var h7 = (e, t) => {
    ;(e.suspense || e.throwOnError) && (t.isReset() || (e.retryOnMount = !1))
  },
  p7 = (e) => {
    w.useEffect(() => {
      e.clearReset()
    }, [e])
  },
  g7 = ({ result: e, errorResetBoundary: t, throwOnError: n, query: r }) =>
    e.isError && !t.isReset() && !e.isFetching && r && MO(n, [e.error, r]),
  m7 = (e) => {
    e.suspense && typeof e.staleTime != 'number' && (e.staleTime = 1e3)
  },
  y7 = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending,
  v7 = (e, t, n) =>
    t.fetchOptimistic(e).catch(() => {
      n.clearReset()
    })
function w7(e, t, n) {
  const r = DO(n),
    i = l7(),
    s = f7(),
    o = r.defaultQueryOptions(e)
  ;(o._optimisticResults = i ? 'isRestoring' : 'optimistic'), m7(o), h7(o, s), p7(s)
  const [a] = w.useState(() => new t(r, o)),
    l = a.getOptimisticResult(o)
  if (
    (w.useSyncExternalStore(
      w.useCallback(
        (c) => {
          const u = i ? () => {} : a.subscribe(hn.batchCalls(c))
          return a.updateResult(), u
        },
        [a, i]
      ),
      () => a.getCurrentResult(),
      () => a.getCurrentResult()
    ),
    w.useEffect(() => {
      a.setOptions(o, { listeners: !1 })
    }, [o, a]),
    y7(o, l))
  )
    throw v7(o, a, s)
  if (
    g7({
      result: l,
      errorResetBoundary: s,
      throwOnError: o.throwOnError,
      query: r.getQueryCache().get(o.queryHash),
    })
  )
    throw l.error
  return o.notifyOnChangeProps ? l : a.trackResult(l)
}
function jO(e, t) {
  return w7(e, r7, t)
}
function X0(e, t) {
  const n = DO(t),
    [r] = w.useState(() => new o7(n, e))
  w.useEffect(() => {
    r.setOptions(e)
  }, [r, e])
  const i = w.useSyncExternalStore(
      w.useCallback((o) => r.subscribe(hn.batchCalls(o)), [r]),
      () => r.getCurrentResult(),
      () => r.getCurrentResult()
    ),
    s = w.useCallback(
      (o, a) => {
        r.mutate(o, a).catch(d7)
      },
      [r]
    )
  if (i.error && MO(r.options.throwOnError, [i.error])) throw i.error
  return { ...i, mutate: s, mutateAsync: i.mutate }
}
const _S = (e) => {
    let t
    const n = new Set(),
      r = (u, f) => {
        const d = typeof u == 'function' ? u(t) : u
        if (!Object.is(d, t)) {
          const p = t
          ;(t = f ?? (typeof d != 'object' || d === null) ? d : Object.assign({}, t, d)),
            n.forEach((h) => h(t, p))
        }
      },
      i = () => t,
      l = {
        setState: r,
        getState: i,
        getInitialState: () => c,
        subscribe: (u) => (n.add(u), () => n.delete(u)),
        destroy: () => {
          n.clear()
        },
      },
      c = (t = e(r, i, l))
    return l
  },
  b7 = (e) => (e ? _S(e) : _S)
var LO = { exports: {} },
  $O = {},
  FO = { exports: {} },
  BO = {}
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var xc = w
function x7(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var S7 = typeof Object.is == 'function' ? Object.is : x7,
  E7 = xc.useState,
  C7 = xc.useEffect,
  _7 = xc.useLayoutEffect,
  O7 = xc.useDebugValue
function k7(e, t) {
  var n = t(),
    r = E7({ inst: { value: n, getSnapshot: t } }),
    i = r[0].inst,
    s = r[1]
  return (
    _7(
      function () {
        ;(i.value = n), (i.getSnapshot = t), xm(i) && s({ inst: i })
      },
      [e, n, t]
    ),
    C7(
      function () {
        return (
          xm(i) && s({ inst: i }),
          e(function () {
            xm(i) && s({ inst: i })
          })
        )
      },
      [e]
    ),
    O7(n),
    n
  )
}
function xm(e) {
  var t = e.getSnapshot
  e = e.value
  try {
    var n = t()
    return !S7(e, n)
  } catch {
    return !0
  }
}
function T7(e, t) {
  return t()
}
var A7 =
  typeof window > 'u' || typeof window.document > 'u' || typeof window.document.createElement > 'u'
    ? T7
    : k7
BO.useSyncExternalStore = xc.useSyncExternalStore !== void 0 ? xc.useSyncExternalStore : A7
FO.exports = BO
var R7 = FO.exports
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Z0 = w,
  P7 = R7
function I7(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var D7 = typeof Object.is == 'function' ? Object.is : I7,
  N7 = P7.useSyncExternalStore,
  M7 = Z0.useRef,
  j7 = Z0.useEffect,
  L7 = Z0.useMemo,
  $7 = Z0.useDebugValue
$O.useSyncExternalStoreWithSelector = function (e, t, n, r, i) {
  var s = M7(null)
  if (s.current === null) {
    var o = { hasValue: !1, value: null }
    s.current = o
  } else o = s.current
  s = L7(
    function () {
      function l(p) {
        if (!c) {
          if (((c = !0), (u = p), (p = r(p)), i !== void 0 && o.hasValue)) {
            var h = o.value
            if (i(h, p)) return (f = h)
          }
          return (f = p)
        }
        if (((h = f), D7(u, p))) return h
        var m = r(p)
        return i !== void 0 && i(h, m) ? h : ((u = p), (f = m))
      }
      var c = !1,
        u,
        f,
        d = n === void 0 ? null : n
      return [
        function () {
          return l(t())
        },
        d === null
          ? void 0
          : function () {
              return l(d())
            },
      ]
    },
    [t, n, r, i]
  )
  var a = N7(e, s[0], s[1])
  return (
    j7(
      function () {
        ;(o.hasValue = !0), (o.value = a)
      },
      [a]
    ),
    $7(a),
    a
  )
}
LO.exports = $O
var F7 = LO.exports
const B7 = Ic(F7),
  { useDebugValue: U7 } = fn,
  { useSyncExternalStoreWithSelector: z7 } = B7
const W7 = (e) => e
function V7(e, t = W7, n) {
  const r = z7(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n)
  return U7(r), r
}
var H7 =
    (globalThis && globalThis.__classPrivateFieldSet) ||
    function (e, t, n, r, i) {
      if (r === 'm') throw new TypeError('Private method is not writable')
      if (r === 'a' && !i) throw new TypeError('Private accessor was defined without a setter')
      if (typeof t == 'function' ? e !== t || !i : !t.has(e))
        throw new TypeError(
          'Cannot write private member to an object whose class did not declare it'
        )
      return r === 'a' ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n
    },
  q7 =
    (globalThis && globalThis.__classPrivateFieldGet) ||
    function (e, t, n, r) {
      if (n === 'a' && !r) throw new TypeError('Private accessor was defined without a getter')
      if (typeof t == 'function' ? e !== t || !r : !t.has(e))
        throw new TypeError(
          'Cannot read private member from an object whose class did not declare it'
        )
      return n === 'm' ? r : n === 'a' ? r.call(e) : r ? r.value : t.get(e)
    },
  Oh
let uu
const kh = new Set(),
  Tl = {}
function J0() {
  if (uu || ((uu = Object.freeze({ register: OS, get: K7, on: G7 })), typeof window > 'u'))
    return uu
  const e = Object.freeze({ register: OS })
  try {
    window.addEventListener('wallet-standard:register-wallet', ({ detail: t }) => t(e))
  } catch (t) {
    console.error(
      `wallet-standard:register-wallet event listener could not be added
`,
      t
    )
  }
  try {
    window.dispatchEvent(new Y7(e))
  } catch (t) {
    console.error(
      `wallet-standard:app-ready event could not be dispatched
`,
      t
    )
  }
  return uu
}
function OS(...e) {
  var t
  return (
    (e = e.filter((n) => !kh.has(n))),
    e.length
      ? (e.forEach((n) => kh.add(n)),
        (t = Tl.register) == null || t.forEach((n) => kS(() => n(...e))),
        function () {
          var r
          e.forEach((i) => kh.delete(i)),
            (r = Tl.unregister) == null || r.forEach((i) => kS(() => i(...e)))
        })
      : () => {}
  )
}
function K7() {
  return [...kh]
}
function G7(e, t) {
  var n
  return (
    ((n = Tl[e]) != null && n.push(t)) || (Tl[e] = [t]),
    function () {
      var i
      Tl[e] = (i = Tl[e]) == null ? void 0 : i.filter((s) => t !== s)
    }
  )
}
function kS(e) {
  try {
    e()
  } catch (t) {
    console.error(t)
  }
}
class Y7 extends Event {
  constructor(t) {
    super('wallet-standard:app-ready', { bubbles: !1, cancelable: !1, composed: !1 }),
      Oh.set(this, void 0),
      H7(this, Oh, t, 'f')
  }
  get detail() {
    return q7(this, Oh, 'f')
  }
  get type() {
    return 'wallet-standard:app-ready'
  }
  preventDefault() {
    throw new Error('preventDefault cannot be called')
  }
  stopImmediatePropagation() {
    throw new Error('stopImmediatePropagation cannot be called')
  }
  stopPropagation() {
    throw new Error('stopPropagation cannot be called')
  }
}
Oh = new WeakMap()
var il =
    (globalThis && globalThis.__classPrivateFieldSet) ||
    function (e, t, n, r, i) {
      if (r === 'm') throw new TypeError('Private method is not writable')
      if (r === 'a' && !i) throw new TypeError('Private accessor was defined without a setter')
      if (typeof t == 'function' ? e !== t || !i : !t.has(e))
        throw new TypeError(
          'Cannot write private member to an object whose class did not declare it'
        )
      return r === 'a' ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n
    },
  sl =
    (globalThis && globalThis.__classPrivateFieldGet) ||
    function (e, t, n, r) {
      if (n === 'a' && !r) throw new TypeError('Private accessor was defined without a getter')
      if (typeof t == 'function' ? e !== t || !r : !t.has(e))
        throw new TypeError(
          'Cannot read private member from an object whose class did not declare it'
        )
      return n === 'm' ? r : n === 'a' ? r.call(e) : r ? r.value : t.get(e)
    },
  Th,
  Ah,
  Rh,
  Ph,
  Ih,
  Dh
class eg {
  constructor(t) {
    Th.set(this, void 0),
      Ah.set(this, void 0),
      Rh.set(this, void 0),
      Ph.set(this, void 0),
      Ih.set(this, void 0),
      Dh.set(this, void 0),
      new.target === eg && Object.freeze(this),
      il(this, Th, t.address, 'f'),
      il(this, Ah, t.publicKey.slice(), 'f'),
      il(this, Rh, t.chains.slice(), 'f'),
      il(this, Ph, t.features.slice(), 'f'),
      il(this, Ih, t.label, 'f'),
      il(this, Dh, t.icon, 'f')
  }
  get address() {
    return sl(this, Th, 'f')
  }
  get publicKey() {
    return sl(this, Ah, 'f').slice()
  }
  get chains() {
    return sl(this, Rh, 'f').slice()
  }
  get features() {
    return sl(this, Ph, 'f').slice()
  }
  get label() {
    return sl(this, Ih, 'f')
  }
  get icon() {
    return sl(this, Dh, 'f')
  }
}
;(Th = new WeakMap()),
  (Ah = new WeakMap()),
  (Rh = new WeakMap()),
  (Ph = new WeakMap()),
  (Ih = new WeakMap()),
  (Dh = new WeakMap())
function Q7(e) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var r = 0; r < e.length; r++) {
    var i = e.charAt(r),
      s = i.charCodeAt(0)
    if (t[s] !== 255) throw new TypeError(i + ' is ambiguous')
    t[s] = r
  }
  var o = e.length,
    a = e.charAt(0),
    l = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function u(p) {
    if (
      (p instanceof Uint8Array ||
        (ArrayBuffer.isView(p)
          ? (p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength))
          : Array.isArray(p) && (p = Uint8Array.from(p))),
      !(p instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (p.length === 0) return ''
    for (var h = 0, m = 0, b = 0, y = p.length; b !== y && p[b] === 0; ) b++, h++
    for (var v = ((y - b) * c + 1) >>> 0, S = new Uint8Array(v); b !== y; ) {
      for (var T = p[b], A = 0, I = v - 1; (T !== 0 || A < m) && I !== -1; I--, A++)
        (T += (256 * S[I]) >>> 0), (S[I] = T % o >>> 0), (T = (T / o) >>> 0)
      if (T !== 0) throw new Error('Non-zero carry')
      ;(m = A), b++
    }
    for (var k = v - m; k !== v && S[k] === 0; ) k++
    for (var D = a.repeat(h); k < v; ++k) D += e.charAt(S[k])
    return D
  }
  function f(p) {
    if (typeof p != 'string') throw new TypeError('Expected String')
    if (p.length === 0) return new Uint8Array()
    for (var h = 0, m = 0, b = 0; p[h] === a; ) m++, h++
    for (var y = ((p.length - h) * l + 1) >>> 0, v = new Uint8Array(y); p[h]; ) {
      var S = t[p.charCodeAt(h)]
      if (S === 255) return
      for (var T = 0, A = y - 1; (S !== 0 || T < b) && A !== -1; A--, T++)
        (S += (o * v[A]) >>> 0), (v[A] = S % 256 >>> 0), (S = (S / 256) >>> 0)
      if (S !== 0) throw new Error('Non-zero carry')
      ;(b = T), h++
    }
    for (var I = y - b; I !== y && v[I] === 0; ) I++
    for (var k = new Uint8Array(m + (y - I)), D = m; I !== y; ) k[D++] = v[I++]
    return k
  }
  function d(p) {
    var h = f(p)
    if (h) return h
    throw new Error('Non-base' + o + ' character')
  }
  return { encode: u, decodeUnsafe: f, decode: d }
}
var X7 = Q7
const Z7 = X7,
  J7 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
var e$ = Z7(J7)
const UO = Ic(e$),
  tg = (e) => UO.encode(e),
  bf = (e) => UO.decode(e)
function Gn(e) {
  return Uint8Array.from(atob(e), (t) => t.charCodeAt(0))
}
const Sm = 8192
function Pt(e) {
  if (e.length < Sm) return btoa(String.fromCharCode(...e))
  let t = ''
  for (var n = 0; n < e.length; n += Sm) {
    const r = e.slice(n, n + Sm)
    t += String.fromCharCode(...r)
  }
  return btoa(t)
}
function Lw(e) {
  var i
  const t = e.startsWith('0x') ? e.slice(2) : e,
    r =
      ((i = (t.length % 2 === 0 ? t : `0${t}}`).match(/.{2}/g)) == null
        ? void 0
        : i.map((s) => parseInt(s, 16))) ?? []
  return Uint8Array.from(r)
}
function Sc(e) {
  return e.reduce((t, n) => t + n.toString(16).padStart(2, '0'), '')
}
function $w(e) {
  let t = [],
    n = 0
  if (e === 0) return [0]
  for (; e > 0; ) (t[n] = e & 127), (e >>= 7) && (t[n] |= 128), (n += 1)
  return t
}
function t$(e) {
  let t = 0,
    n = 0,
    r = 0
  for (;;) {
    let i = e[r]
    if (((r += 1), (t |= (i & 127) << n), !(i & 128))) break
    n += 7
  }
  return { value: t, length: r }
}
class n$ {
  constructor(t) {
    ;(this.bytePosition = 0), (this.dataView = new DataView(t.buffer))
  }
  shift(t) {
    return (this.bytePosition += t), this
  }
  read8() {
    let t = this.dataView.getUint8(this.bytePosition)
    return this.shift(1), t
  }
  read16() {
    let t = this.dataView.getUint16(this.bytePosition, !0)
    return this.shift(2), t
  }
  read32() {
    let t = this.dataView.getUint32(this.bytePosition, !0)
    return this.shift(4), t
  }
  read64() {
    let t = this.read32(),
      r = this.read32().toString(16) + t.toString(16).padStart(8, '0')
    return BigInt('0x' + r).toString(10)
  }
  read128() {
    let t = BigInt(this.read64()),
      r = BigInt(this.read64()).toString(16) + t.toString(16).padStart(16, '0')
    return BigInt('0x' + r).toString(10)
  }
  read256() {
    let t = BigInt(this.read128()),
      r = BigInt(this.read128()).toString(16) + t.toString(16).padStart(32, '0')
    return BigInt('0x' + r).toString(10)
  }
  readBytes(t) {
    let n = this.bytePosition + this.dataView.byteOffset,
      r = new Uint8Array(this.dataView.buffer, n, t)
    return this.shift(t), r
  }
  readULEB() {
    let t = this.bytePosition + this.dataView.byteOffset,
      n = new Uint8Array(this.dataView.buffer, t),
      { value: r, length: i } = t$(n)
    return this.shift(i), r
  }
  readVec(t) {
    let n = this.readULEB(),
      r = []
    for (let i = 0; i < n; i++) r.push(t(this, i, n))
    return r
  }
}
function r$(e, t) {
  switch (t) {
    case 'base58':
      return tg(e)
    case 'base64':
      return Pt(e)
    case 'hex':
      return Sc(e)
    default:
      throw new Error('Unsupported encoding, supported values are: base64, hex')
  }
}
function i$(e, t = ['<', '>']) {
  const [n, r] = t,
    i = []
  let s = '',
    o = 0
  for (let a = 0; a < e.length; a++) {
    const l = e[a]
    if ((l === n && o++, l === r && o--, o === 0 && l === ',')) {
      i.push(s.trim()), (s = '')
      continue
    }
    s += l
  }
  return i.push(s.trim()), i
}
class s$ {
  constructor({ initialSize: t = 1024, maxSize: n = 1 / 0, allocateSize: r = 1024 } = {}) {
    ;(this.bytePosition = 0),
      (this.size = t),
      (this.maxSize = n),
      (this.allocateSize = r),
      (this.dataView = new DataView(new ArrayBuffer(t)))
  }
  ensureSizeOrGrow(t) {
    const n = this.bytePosition + t
    if (n > this.size) {
      const r = Math.min(this.maxSize, this.size + this.allocateSize)
      if (n > r)
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${n}`
        )
      this.size = r
      const i = new ArrayBuffer(this.size)
      new Uint8Array(i).set(new Uint8Array(this.dataView.buffer)), (this.dataView = new DataView(i))
    }
  }
  shift(t) {
    return (this.bytePosition += t), this
  }
  write8(t) {
    return (
      this.ensureSizeOrGrow(1), this.dataView.setUint8(this.bytePosition, Number(t)), this.shift(1)
    )
  }
  write16(t) {
    return (
      this.ensureSizeOrGrow(2),
      this.dataView.setUint16(this.bytePosition, Number(t), !0),
      this.shift(2)
    )
  }
  write32(t) {
    return (
      this.ensureSizeOrGrow(4),
      this.dataView.setUint32(this.bytePosition, Number(t), !0),
      this.shift(4)
    )
  }
  write64(t) {
    return Em(BigInt(t), 8).forEach((n) => this.write8(n)), this
  }
  write128(t) {
    return Em(BigInt(t), 16).forEach((n) => this.write8(n)), this
  }
  write256(t) {
    return Em(BigInt(t), 32).forEach((n) => this.write8(n)), this
  }
  writeULEB(t) {
    return $w(t).forEach((n) => this.write8(n)), this
  }
  writeVec(t, n) {
    return this.writeULEB(t.length), Array.from(t).forEach((r, i) => n(this, r, i, t.length)), this
  }
  *[Symbol.iterator]() {
    for (let t = 0; t < this.bytePosition; t++) yield this.dataView.getUint8(t)
    return this.toBytes()
  }
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition))
  }
  toString(t) {
    return r$(this.toBytes(), t)
  }
}
function Em(e, t) {
  let n = new Uint8Array(t),
    r = 0
  for (; e > 0; ) (n[r] = Number(e % BigInt(256))), (e = e / BigInt(256)), (r += 1)
  return n
}
var zO = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  xi = (e, t, n) => (zO(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  zp = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  Wp = (e, t, n, r) => (zO(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  ul,
  xu,
  Nh,
  oo
const WO = class {
  constructor(e) {
    zp(this, ul, void 0),
      zp(this, xu, void 0),
      (this.name = e.name),
      (this.read = e.read),
      (this.serializedSize = e.serializedSize ?? (() => null)),
      Wp(this, ul, e.write),
      Wp(
        this,
        xu,
        e.serialize ??
          ((t, n) => {
            const r = new s$({ initialSize: this.serializedSize(t) ?? void 0, ...n })
            return xi(this, ul).call(this, t, r), r.toBytes()
          })
      ),
      (this.validate = e.validate ?? (() => {}))
  }
  write(e, t) {
    this.validate(e), xi(this, ul).call(this, e, t)
  }
  serialize(e, t) {
    return this.validate(e), new o$(this, xi(this, xu).call(this, e, t))
  }
  parse(e) {
    const t = new n$(e)
    return this.read(t)
  }
  fromHex(e) {
    return this.parse(Lw(e))
  }
  fromBase58(e) {
    return this.parse(bf(e))
  }
  fromBase64(e) {
    return this.parse(Gn(e))
  }
  transform({ name: e, input: t, output: n, validate: r }) {
    return new WO({
      name: e ?? this.name,
      read: (i) => n(this.read(i)),
      write: (i, s) => xi(this, ul).call(this, t(i), s),
      serializedSize: (i) => this.serializedSize(t(i)),
      serialize: (i, s) => xi(this, xu).call(this, t(i), s),
      validate: (i) => {
        r == null || r(i), this.validate(t(i))
      },
    })
  }
}
let Cs = WO
ul = new WeakMap()
xu = new WeakMap()
const VO = Symbol.for('@mysten/serialized-bcs')
function HO(e) {
  return !!e && typeof e == 'object' && e[VO] === !0
}
class o$ {
  constructor(t, n) {
    zp(this, Nh, void 0), zp(this, oo, void 0), Wp(this, Nh, t), Wp(this, oo, n)
  }
  get [VO]() {
    return !0
  }
  toBytes() {
    return xi(this, oo)
  }
  toHex() {
    return Sc(xi(this, oo))
  }
  toBase64() {
    return Pt(xi(this, oo))
  }
  toBase58() {
    return tg(xi(this, oo))
  }
  parse() {
    return xi(this, Nh).parse(xi(this, oo))
  }
}
Nh = new WeakMap()
oo = new WeakMap()
function Vp({ size: e, ...t }) {
  return new Cs({ ...t, serializedSize: () => e })
}
function Cm({ readMethod: e, writeMethod: t, ...n }) {
  return Vp({
    ...n,
    read: (r) => r[e](),
    write: (r, i) => i[t](r),
    validate: (r) => {
      var i
      if (r < 0 || r > n.maxValue)
        throw new TypeError(
          `Invalid ${n.name} value: ${r}. Expected value in range 0-${n.maxValue}`
        )
      ;(i = n.validate) == null || i.call(n, r)
    },
  })
}
function _m({ readMethod: e, writeMethod: t, ...n }) {
  return Vp({
    ...n,
    read: (r) => r[e](),
    write: (r, i) => i[t](BigInt(r)),
    validate: (r) => {
      var s
      const i = BigInt(r)
      if (i < 0 || i > n.maxValue)
        throw new TypeError(
          `Invalid ${n.name} value: ${i}. Expected value in range 0-${n.maxValue}`
        )
      ;(s = n.validate) == null || s.call(n, i)
    },
  })
}
function a$({ serialize: e, ...t }) {
  const n = new Cs({
    ...t,
    serialize: e,
    write: (r, i) => {
      for (const s of n.serialize(r).toBytes()) i.write8(s)
    },
  })
  return n
}
function l$({ toBytes: e, fromBytes: t, ...n }) {
  return new Cs({
    ...n,
    read: (r) => {
      const i = r.readULEB(),
        s = r.readBytes(i)
      return t(s)
    },
    write: (r, i) => {
      const s = e(r)
      i.writeULEB(s.length)
      for (let o = 0; o < s.length; o++) i.write8(s[o])
    },
    serialize: (r) => {
      const i = e(r),
        s = $w(i.length),
        o = new Uint8Array(s.length + i.length)
      return o.set(s, 0), o.set(i, s.length), o
    },
    validate: (r) => {
      var i
      if (typeof r != 'string')
        throw new TypeError(`Invalid ${n.name} value: ${r}. Expected string`)
      ;(i = n.validate) == null || i.call(n, r)
    },
  })
}
function c$(e) {
  let t = null
  function n() {
    return t || (t = e()), t
  }
  return new Cs({
    name: 'lazy',
    read: (r) => n().read(r),
    serializedSize: (r) => n().serializedSize(r),
    write: (r, i) => n().write(r, i),
    serialize: (r, i) => n().serialize(r, i).toBytes(),
  })
}
const R = {
    u8(e) {
      return Cm({
        name: 'u8',
        readMethod: 'read8',
        writeMethod: 'write8',
        size: 1,
        maxValue: 2 ** 8 - 1,
        ...e,
      })
    },
    u16(e) {
      return Cm({
        name: 'u16',
        readMethod: 'read16',
        writeMethod: 'write16',
        size: 2,
        maxValue: 2 ** 16 - 1,
        ...e,
      })
    },
    u32(e) {
      return Cm({
        name: 'u32',
        readMethod: 'read32',
        writeMethod: 'write32',
        size: 4,
        maxValue: 2 ** 32 - 1,
        ...e,
      })
    },
    u64(e) {
      return _m({
        name: 'u64',
        readMethod: 'read64',
        writeMethod: 'write64',
        size: 8,
        maxValue: 2n ** 64n - 1n,
        ...e,
      })
    },
    u128(e) {
      return _m({
        name: 'u128',
        readMethod: 'read128',
        writeMethod: 'write128',
        size: 16,
        maxValue: 2n ** 128n - 1n,
        ...e,
      })
    },
    u256(e) {
      return _m({
        name: 'u256',
        readMethod: 'read256',
        writeMethod: 'write256',
        size: 32,
        maxValue: 2n ** 256n - 1n,
        ...e,
      })
    },
    bool(e) {
      return Vp({
        name: 'bool',
        size: 1,
        read: (t) => t.read8() === 1,
        write: (t, n) => n.write8(t ? 1 : 0),
        ...e,
        validate: (t) => {
          var n
          if (
            ((n = e == null ? void 0 : e.validate) == null || n.call(e, t), typeof t != 'boolean')
          )
            throw new TypeError(`Expected boolean, found ${typeof t}`)
        },
      })
    },
    uleb128(e) {
      return a$({
        name: 'uleb128',
        read: (t) => t.readULEB(),
        serialize: (t) => Uint8Array.from($w(t)),
        ...e,
      })
    },
    bytes(e, t) {
      return Vp({
        name: `bytes[${e}]`,
        size: e,
        read: (n) => n.readBytes(e),
        write: (n, r) => {
          for (let i = 0; i < e; i++) r.write8(n[i] ?? 0)
        },
        ...t,
        validate: (n) => {
          var r
          if (
            ((r = t == null ? void 0 : t.validate) == null || r.call(t, n),
            !n || typeof n != 'object' || !('length' in n))
          )
            throw new TypeError(`Expected array, found ${typeof n}`)
          if (n.length !== e)
            throw new TypeError(`Expected array of length ${e}, found ${n.length}`)
        },
      })
    },
    string(e) {
      return l$({
        name: 'string',
        toBytes: (t) => new TextEncoder().encode(t),
        fromBytes: (t) => new TextDecoder().decode(t),
        ...e,
      })
    },
    fixedArray(e, t, n) {
      return new Cs({
        name: `${t.name}[${e}]`,
        read: (r) => {
          const i = new Array(e)
          for (let s = 0; s < e; s++) i[s] = t.read(r)
          return i
        },
        write: (r, i) => {
          for (const s of r) t.write(s, i)
        },
        ...n,
        validate: (r) => {
          var i
          if (
            ((i = n == null ? void 0 : n.validate) == null || i.call(n, r),
            !r || typeof r != 'object' || !('length' in r))
          )
            throw new TypeError(`Expected array, found ${typeof r}`)
          if (r.length !== e)
            throw new TypeError(`Expected array of length ${e}, found ${r.length}`)
        },
      })
    },
    option(e) {
      return R.enum(`Option<${e.name}>`, { None: null, Some: e }).transform({
        input: (t) => (t == null ? { None: !0 } : { Some: t }),
        output: (t) => (t.$kind === 'Some' ? t.Some : null),
      })
    },
    vector(e, t) {
      return new Cs({
        name: `vector<${e.name}>`,
        read: (n) => {
          const r = n.readULEB(),
            i = new Array(r)
          for (let s = 0; s < r; s++) i[s] = e.read(n)
          return i
        },
        write: (n, r) => {
          r.writeULEB(n.length)
          for (const i of n) e.write(i, r)
        },
        ...t,
        validate: (n) => {
          var r
          if (
            ((r = t == null ? void 0 : t.validate) == null || r.call(t, n),
            !n || typeof n != 'object' || !('length' in n))
          )
            throw new TypeError(`Expected array, found ${typeof n}`)
        },
      })
    },
    tuple(e, t) {
      return new Cs({
        name: `(${e.map((n) => n.name).join(', ')})`,
        serializedSize: (n) => {
          let r = 0
          for (let i = 0; i < e.length; i++) {
            const s = e[i].serializedSize(n[i])
            if (s == null) return null
            r += s
          }
          return r
        },
        read: (n) => {
          const r = []
          for (const i of e) r.push(i.read(n))
          return r
        },
        write: (n, r) => {
          for (let i = 0; i < e.length; i++) e[i].write(n[i], r)
        },
        ...t,
        validate: (n) => {
          var r
          if (((r = t == null ? void 0 : t.validate) == null || r.call(t, n), !Array.isArray(n)))
            throw new TypeError(`Expected array, found ${typeof n}`)
          if (n.length !== e.length)
            throw new TypeError(`Expected array of length ${e.length}, found ${n.length}`)
        },
      })
    },
    struct(e, t, n) {
      const r = Object.entries(t)
      return new Cs({
        name: e,
        serializedSize: (i) => {
          let s = 0
          for (const [o, a] of r) {
            const l = a.serializedSize(i[o])
            if (l == null) return null
            s += l
          }
          return s
        },
        read: (i) => {
          const s = {}
          for (const [o, a] of r) s[o] = a.read(i)
          return s
        },
        write: (i, s) => {
          for (const [o, a] of r) a.write(i[o], s)
        },
        ...n,
        validate: (i) => {
          var s
          if (
            ((s = n == null ? void 0 : n.validate) == null || s.call(n, i),
            typeof i != 'object' || i == null)
          )
            throw new TypeError(`Expected object, found ${typeof i}`)
        },
      })
    },
    enum(e, t, n) {
      const r = Object.entries(t)
      return new Cs({
        name: e,
        read: (i) => {
          const s = i.readULEB(),
            [o, a] = r[s]
          return { [o]: (a == null ? void 0 : a.read(i)) ?? !0, $kind: o }
        },
        write: (i, s) => {
          const [o, a] = Object.entries(i).filter(([l]) => Object.hasOwn(t, l))[0]
          for (let l = 0; l < r.length; l++) {
            const [c, u] = r[l]
            if (c === o) {
              s.writeULEB(l), u == null || u.write(a, s)
              return
            }
          }
        },
        ...n,
        validate: (i) => {
          var a
          if (
            ((a = n == null ? void 0 : n.validate) == null || a.call(n, i),
            typeof i != 'object' || i == null)
          )
            throw new TypeError(`Expected object, found ${typeof i}`)
          const s = Object.keys(i).filter((l) => i[l] !== void 0 && Object.hasOwn(t, l))
          if (s.length !== 1)
            throw new TypeError(
              `Expected object with one key, but found ${s.length} for type ${e}}`
            )
          const [o] = s
          if (!Object.hasOwn(t, o)) throw new TypeError(`Invalid enum variant ${o}`)
        },
      })
    },
    map(e, t) {
      return R.vector(R.tuple([e, t])).transform({
        name: `Map<${e.name}, ${t.name}>`,
        input: (n) => [...n.entries()],
        output: (n) => {
          const r = new Map()
          for (const [i, s] of n) r.set(i, s)
          return r
        },
      })
    },
    lazy(e) {
      return c$(e)
    },
  },
  u$ = 32
function TS(e) {
  try {
    return bf(e).length === u$
  } catch {
    return !1
  }
}
const ng = 32
function xs(e) {
  return f$(e) && d$(e) === ng
}
function Fd(e) {
  return xs(e)
}
function kt(e, t = !1) {
  let n = e.toLowerCase()
  return !t && n.startsWith('0x') && (n = n.slice(2)), `0x${n.padStart(ng * 2, '0')}`
}
function ks(e, t = !1) {
  return kt(e, t)
}
function f$(e) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e) && e.length % 2 === 0
}
function d$(e) {
  return /^(0x|0X)/.test(e) ? (e.length - 2) / 2 : e.length / 2
}
const h$ = /^vector<(.+)>$/,
  p$ = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/
class Qi {
  static parseFromStr(t, n = !1) {
    if (t === 'address') return { address: null }
    if (t === 'bool') return { bool: null }
    if (t === 'u8') return { u8: null }
    if (t === 'u16') return { u16: null }
    if (t === 'u32') return { u32: null }
    if (t === 'u64') return { u64: null }
    if (t === 'u128') return { u128: null }
    if (t === 'u256') return { u256: null }
    if (t === 'signer') return { signer: null }
    const r = t.match(h$)
    if (r) return { vector: Qi.parseFromStr(r[1], n) }
    const i = t.match(p$)
    if (i)
      return {
        struct: {
          address: n ? kt(i[1]) : i[1],
          module: i[2],
          name: i[3],
          typeParams: i[5] === void 0 ? [] : Qi.parseStructTypeArgs(i[5], n),
        },
      }
    throw new Error(`Encountered unexpected token when parsing type args for ${t}`)
  }
  static parseStructTypeArgs(t, n = !1) {
    return i$(t).map((r) => Qi.parseFromStr(r, n))
  }
  static tagToString(t) {
    if ('bool' in t) return 'bool'
    if ('u8' in t) return 'u8'
    if ('u16' in t) return 'u16'
    if ('u32' in t) return 'u32'
    if ('u64' in t) return 'u64'
    if ('u128' in t) return 'u128'
    if ('u256' in t) return 'u256'
    if ('address' in t) return 'address'
    if ('signer' in t) return 'signer'
    if ('vector' in t) return `vector<${Qi.tagToString(t.vector)}>`
    if ('struct' in t) {
      const n = t.struct,
        r = n.typeParams.map(Qi.tagToString).join(', ')
      return `${n.address}::${n.module}::${n.name}${r ? `<${r}>` : ''}`
    }
    throw new Error('Invalid TypeTag')
  }
}
function g$(e) {
  return R.u64({ name: 'unsafe_u64', ...e }).transform({
    input: (t) => t,
    output: (t) => Number(t),
  })
}
function m$(e) {
  return R.enum('Option', { None: null, Some: e })
}
const en = R.bytes(ng).transform({
    validate: (e) => {
      const t = typeof e == 'string' ? e : Sc(e)
      if (!t || !xs(kt(t))) throw new Error(`Invalid Sui address ${t}`)
    },
    input: (e) => (typeof e == 'string' ? Lw(kt(e)) : e),
    output: (e) => kt(Sc(e)),
  }),
  _i = R.vector(R.u8()).transform({
    name: 'ObjectDigest',
    input: (e) => bf(e),
    output: (e) => tg(new Uint8Array(e)),
    validate: (e) => {
      if (bf(e).length !== 32) throw new Error('ObjectDigest must be 32 bytes')
    },
  }),
  Wr = R.struct('SuiObjectRef', { objectId: en, version: R.u64(), digest: _i }),
  qO = R.struct('SharedObjectRef', {
    objectId: en,
    initialSharedVersion: R.u64(),
    mutable: R.bool(),
  }),
  KO = R.enum('ObjectArg', { ImmOrOwnedObject: Wr, SharedObject: qO, Receiving: Wr }),
  GO = R.enum('CallArg', {
    Pure: R.struct('Pure', {
      bytes: R.vector(R.u8()).transform({
        input: (e) => (typeof e == 'string' ? Gn(e) : e),
        output: (e) => Pt(new Uint8Array(e)),
      }),
    }),
    Object: KO,
  }),
  Fw = R.enum('TypeTag', {
    bool: null,
    u8: null,
    u64: null,
    u128: null,
    address: null,
    signer: null,
    vector: R.lazy(() => Fw),
    struct: R.lazy(() => e6),
    u16: null,
    u32: null,
    u256: null,
  }),
  Bw = Fw.transform({
    input: (e) => (typeof e == 'string' ? Qi.parseFromStr(e, !0) : e),
    output: (e) => Qi.tagToString(e),
  }),
  zi = R.enum('Argument', {
    GasCoin: null,
    Input: R.u16(),
    Result: R.u16(),
    NestedResult: R.tuple([R.u16(), R.u16()]),
  }),
  YO = R.struct('ProgrammableMoveCall', {
    package: en,
    module: R.string(),
    function: R.string(),
    typeArguments: R.vector(Bw),
    arguments: R.vector(zi),
  }),
  QO = R.enum('Command', {
    MoveCall: YO,
    TransferObjects: R.struct('TransferObjects', { objects: R.vector(zi), address: zi }),
    SplitCoins: R.struct('SplitCoins', { coin: zi, amounts: R.vector(zi) }),
    MergeCoins: R.struct('MergeCoins', { destination: zi, sources: R.vector(zi) }),
    Publish: R.struct('Publish', {
      modules: R.vector(
        R.vector(R.u8()).transform({
          input: (e) => (typeof e == 'string' ? Gn(e) : e),
          output: (e) => Pt(new Uint8Array(e)),
        })
      ),
      dependencies: R.vector(en),
    }),
    MakeMoveVec: R.struct('MakeMoveVec', {
      type: m$(Bw).transform({
        input: (e) => (e === null ? { None: !0 } : { Some: e }),
        output: (e) => e.Some ?? null,
      }),
      elements: R.vector(zi),
    }),
    Upgrade: R.struct('Upgrade', {
      modules: R.vector(
        R.vector(R.u8()).transform({
          input: (e) => (typeof e == 'string' ? Gn(e) : e),
          output: (e) => Pt(new Uint8Array(e)),
        })
      ),
      dependencies: R.vector(en),
      package: en,
      ticket: zi,
    }),
  }),
  XO = R.struct('ProgrammableTransaction', { inputs: R.vector(GO), commands: R.vector(QO) }),
  ZO = R.enum('TransactionKind', {
    ProgrammableTransaction: XO,
    ChangeEpoch: null,
    Genesis: null,
    ConsensusCommitPrologue: null,
  }),
  JO = R.enum('TransactionExpiration', { None: null, Epoch: g$() }),
  e6 = R.struct('StructTag', {
    address: en,
    module: R.string(),
    name: R.string(),
    typeParams: R.vector(Fw),
  }),
  t6 = R.struct('GasData', { payment: R.vector(Wr), owner: en, price: R.u64(), budget: R.u64() }),
  n6 = R.struct('TransactionDataV1', { kind: ZO, sender: en, gasData: t6, expiration: JO }),
  r6 = R.enum('TransactionData', { V1: n6 }),
  i6 = R.enum('IntentScope', {
    TransactionData: null,
    TransactionEffects: null,
    CheckpointSummary: null,
    PersonalMessage: null,
  }),
  s6 = R.enum('IntentVersion', { V0: null }),
  o6 = R.enum('AppId', { Sui: null }),
  a6 = R.struct('Intent', { scope: i6, version: s6, appId: o6 })
function l6(e) {
  return R.struct(`IntentMessage<${e.name}>`, { intent: a6, value: e })
}
const c6 = R.enum('CompressedSignature', {
    ED25519: R.fixedArray(64, R.u8()),
    Secp256k1: R.fixedArray(64, R.u8()),
    Secp256r1: R.fixedArray(64, R.u8()),
    ZkLogin: R.vector(R.u8()),
  }),
  u6 = R.enum('PublicKey', {
    ED25519: R.fixedArray(32, R.u8()),
    Secp256k1: R.fixedArray(33, R.u8()),
    Secp256r1: R.fixedArray(33, R.u8()),
    ZkLogin: R.vector(R.u8()),
  }),
  f6 = R.struct('MultiSigPkMap', { pubKey: u6, weight: R.u8() }),
  d6 = R.struct('MultiSigPublicKey', { pk_map: R.vector(f6), threshold: R.u16() }),
  y$ = R.struct('MultiSig', { sigs: R.vector(c6), bitmap: R.u16(), multisig_pk: d6 }),
  v$ = R.vector(R.u8()).transform({
    input: (e) => (typeof e == 'string' ? Gn(e) : e),
    output: (e) => Pt(new Uint8Array(e)),
  }),
  h6 = R.struct('SenderSignedTransaction', { intentMessage: l6(r6), txSignatures: R.vector(v$) }),
  w$ = R.vector(h6, { name: 'SenderSignedData' }),
  b$ = R.enum('PackageUpgradeError', {
    UnableToFetchPackage: R.struct('UnableToFetchPackage', { packageId: en }),
    NotAPackage: R.struct('NotAPackage', { objectId: en }),
    IncompatibleUpgrade: null,
    DigestDoesNotMatch: R.struct('DigestDoesNotMatch', { digest: R.vector(R.u8()) }),
    UnknownUpgradePolicy: R.struct('UnknownUpgradePolicy', { policy: R.u8() }),
    PackageIDDoesNotMatch: R.struct('PackageIDDoesNotMatch', { packageId: en, ticketId: en }),
  }),
  x$ = R.struct('ModuleId', { address: en, name: R.string() }),
  AS = R.struct('MoveLocation', {
    module: x$,
    function: R.u16(),
    instruction: R.u16(),
    functionName: R.option(R.string()),
  }),
  S$ = R.enum('CommandArgumentError', {
    TypeMismatch: null,
    InvalidBCSBytes: null,
    InvalidUsageOfPureArg: null,
    InvalidArgumentToPrivateEntryFunction: null,
    IndexOutOfBounds: R.struct('IndexOutOfBounds', { idx: R.u16() }),
    SecondaryIndexOutOfBounds: R.struct('SecondaryIndexOutOfBounds', {
      resultIdx: R.u16(),
      secondaryIdx: R.u16(),
    }),
    InvalidResultArity: R.struct('InvalidResultArity', { resultIdx: R.u16() }),
    InvalidGasCoinUsage: null,
    InvalidValueUsage: null,
    InvalidObjectByValue: null,
    InvalidObjectByMutRef: null,
    SharedObjectOperationNotAllowed: null,
  }),
  E$ = R.enum('TypeArgumentError', { TypeNotFound: null, ConstraintNotSatisfied: null }),
  C$ = R.enum('ExecutionFailureStatus', {
    InsufficientGas: null,
    InvalidGasObject: null,
    InvariantViolation: null,
    FeatureNotYetSupported: null,
    MoveObjectTooBig: R.struct('MoveObjectTooBig', { objectSize: R.u64(), maxObjectSize: R.u64() }),
    MovePackageTooBig: R.struct('MovePackageTooBig', {
      objectSize: R.u64(),
      maxObjectSize: R.u64(),
    }),
    CircularObjectOwnership: R.struct('CircularObjectOwnership', { object: en }),
    InsufficientCoinBalance: null,
    CoinBalanceOverflow: null,
    PublishErrorNonZeroAddress: null,
    SuiMoveVerificationError: null,
    MovePrimitiveRuntimeError: R.option(AS),
    MoveAbort: R.tuple([AS, R.u64()]),
    VMVerificationOrDeserializationError: null,
    VMInvariantViolation: null,
    FunctionNotFound: null,
    ArityMismatch: null,
    TypeArityMismatch: null,
    NonEntryFunctionInvoked: null,
    CommandArgumentError: R.struct('CommandArgumentError', { argIdx: R.u16(), kind: S$ }),
    TypeArgumentError: R.struct('TypeArgumentError', { argumentIdx: R.u16(), kind: E$ }),
    UnusedValueWithoutDrop: R.struct('UnusedValueWithoutDrop', {
      resultIdx: R.u16(),
      secondaryIdx: R.u16(),
    }),
    InvalidPublicFunctionReturnType: R.struct('InvalidPublicFunctionReturnType', { idx: R.u16() }),
    InvalidTransferObject: null,
    EffectsTooLarge: R.struct('EffectsTooLarge', { currentSize: R.u64(), maxSize: R.u64() }),
    PublishUpgradeMissingDependency: null,
    PublishUpgradeDependencyDowngrade: null,
    PackageUpgradeError: R.struct('PackageUpgradeError', { upgradeError: b$ }),
    WrittenObjectsTooLarge: R.struct('WrittenObjectsTooLarge', {
      currentSize: R.u64(),
      maxSize: R.u64(),
    }),
    CertificateDenied: null,
    SuiMoveVerificationTimedout: null,
    SharedObjectOperationNotAllowed: null,
    InputObjectDeleted: null,
  }),
  p6 = R.enum('ExecutionStatus', {
    Success: null,
    Failed: R.struct('ExecutionFailed', { error: C$, command: R.option(R.u64()) }),
  }),
  g6 = R.struct('GasCostSummary', {
    computationCost: R.u64(),
    storageCost: R.u64(),
    storageRebate: R.u64(),
    nonRefundableStorageFee: R.u64(),
  }),
  Al = R.enum('Owner', {
    AddressOwner: en,
    ObjectOwner: en,
    Shared: R.struct('Shared', { initialSharedVersion: R.u64() }),
    Immutable: null,
  }),
  _$ = R.struct('TransactionEffectsV1', {
    status: p6,
    executedEpoch: R.u64(),
    gasUsed: g6,
    modifiedAtVersions: R.vector(R.tuple([en, R.u64()])),
    sharedObjects: R.vector(Wr),
    transactionDigest: _i,
    created: R.vector(R.tuple([Wr, Al])),
    mutated: R.vector(R.tuple([Wr, Al])),
    unwrapped: R.vector(R.tuple([Wr, Al])),
    deleted: R.vector(Wr),
    unwrappedThenDeleted: R.vector(Wr),
    wrapped: R.vector(Wr),
    gasObject: R.tuple([Wr, Al]),
    eventsDigest: R.option(_i),
    dependencies: R.vector(_i),
  }),
  Uw = R.tuple([R.u64(), _i]),
  O$ = R.enum('ObjectIn', { NotExist: null, Exist: R.tuple([Uw, Al]) }),
  k$ = R.enum('ObjectOut', { NotExist: null, ObjectWrite: R.tuple([_i, Al]), PackageWrite: Uw }),
  T$ = R.enum('IDOperation', { None: null, Created: null, Deleted: null }),
  A$ = R.struct('EffectsObjectChange', { inputState: O$, outputState: k$, idOperation: T$ }),
  R$ = R.enum('UnchangedSharedKind', {
    ReadOnlyRoot: Uw,
    MutateDeleted: R.u64(),
    ReadDeleted: R.u64(),
  }),
  P$ = R.struct('TransactionEffectsV2', {
    status: p6,
    executedEpoch: R.u64(),
    gasUsed: g6,
    transactionDigest: _i,
    gasObjectIndex: R.option(R.u32()),
    eventsDigest: R.option(_i),
    dependencies: R.vector(_i),
    lamportVersion: R.u64(),
    changedObjects: R.vector(R.tuple([en, A$])),
    unchangedSharedObjects: R.vector(R.tuple([en, R$])),
    auxDataDigest: R.option(_i),
  }),
  I$ = R.enum('TransactionEffects', { V1: _$, V2: P$ }),
  lt = {
    ...R,
    U8: R.u8(),
    U16: R.u16(),
    U32: R.u32(),
    U64: R.u64(),
    U128: R.u128(),
    U256: R.u256(),
    ULEB128: R.uleb128(),
    Bool: R.bool(),
    String: R.string(),
    Address: en,
    AppId: o6,
    Argument: zi,
    CallArg: GO,
    CompressedSignature: c6,
    GasData: t6,
    Intent: a6,
    IntentMessage: l6,
    IntentScope: i6,
    IntentVersion: s6,
    MultiSig: y$,
    MultiSigPkMap: f6,
    MultiSigPublicKey: d6,
    ObjectArg: KO,
    ObjectDigest: _i,
    ProgrammableMoveCall: YO,
    ProgrammableTransaction: XO,
    PublicKey: u6,
    SenderSignedData: w$,
    SenderSignedTransaction: h6,
    SharedObjectRef: qO,
    StructTag: e6,
    SuiObjectRef: Wr,
    Command: QO,
    TransactionData: r6,
    TransactionDataV1: n6,
    TransactionExpiration: JO,
    TransactionKind: ZO,
    TypeTag: Bw,
    TransactionEffects: I$,
  },
  D$ = ''
function m6(e) {
  if (e.length <= 6) return e
  const t = e.startsWith('0x') ? 2 : 0
  return `0x${e.slice(t, t + 4)}${D$}${e.slice(-4)}`
}
const N$ = /^(?:[a-z0-9][a-z0-9-]{0,62}(?:\.[a-z0-9][a-z0-9-]{0,62})*)?@[a-z0-9][a-z0-9-]{0,62}$/i,
  M$ = /^(?:[a-z0-9][a-z0-9-]{0,62}\.)+sui$/i
function j$(e, t = 'at') {
  const n = e.toLowerCase()
  let r
  if (n.includes('@')) {
    if (!N$.test(n)) throw new Error(`Invalid SuiNS name ${e}`)
    const [i, s] = n.split('@')
    r = [...(i ? i.split('.') : []), s]
  } else {
    if (!M$.test(n)) throw new Error(`Invalid SuiNS name ${e}`)
    r = n.split('.').slice(0, -1)
  }
  return t === 'dot' ? `${r.join('.')}.sui` : `${r.slice(0, -1).join('.')}@${r[r.length - 1]}`
}
BigInt(1e9)
const L$ = '0x1',
  y6 = '0x2'
ks('0x6')
const $$ = `${y6}::sui::SUI`
ks('0x5')
const F$ = 'object',
  B$ = 'ID',
  U$ = 'ascii',
  z$ = 'String',
  W$ = 'string',
  V$ = 'String',
  H$ = 'option',
  q$ = 'Option'
function K$(e) {
  const t = typeof e.body == 'object' && 'datatype' in e.body ? e.body.datatype : null
  return !!t && kt(t.package) === kt('0x2') && t.module === 'tx_context' && t.type === 'TxContext'
}
function bv(e) {
  if (typeof e == 'string')
    switch (e) {
      case 'address':
        return lt.Address
      case 'bool':
        return lt.Bool
      case 'u8':
        return lt.U8
      case 'u16':
        return lt.U16
      case 'u32':
        return lt.U32
      case 'u64':
        return lt.U64
      case 'u128':
        return lt.U128
      case 'u256':
        return lt.U256
      default:
        throw new Error(`Unknown type signature ${e}`)
    }
  if ('vector' in e) {
    if (e.vector === 'u8')
      return lt.vector(lt.U8).transform({
        input: (n) => (typeof n == 'string' ? new TextEncoder().encode(n) : n),
        output: (n) => n,
      })
    const t = bv(e.vector)
    return t ? lt.vector(t) : null
  }
  if ('datatype' in e) {
    const t = kt(e.datatype.package)
    if (t === kt(L$)) {
      if (
        (e.datatype.module === U$ && e.datatype.type === z$) ||
        (e.datatype.module === W$ && e.datatype.type === V$)
      )
        return lt.String
      if (e.datatype.module === H$ && e.datatype.type === q$) {
        const n = bv(e.datatype.typeParameters[0])
        return n ? lt.vector(n) : null
      }
    }
    if (t === kt(y6) && e.datatype.module === F$ && e.datatype.type === B$) return lt.Address
  }
  return null
}
function G$(e) {
  return typeof e == 'object' && 'Reference' in e
    ? { ref: '&', body: Vu(e.Reference) }
    : typeof e == 'object' && 'MutableReference' in e
    ? { ref: '&mut', body: Vu(e.MutableReference) }
    : { ref: null, body: Vu(e) }
}
function Vu(e) {
  if (typeof e == 'string')
    switch (e) {
      case 'Address':
        return 'address'
      case 'Bool':
        return 'bool'
      case 'U8':
        return 'u8'
      case 'U16':
        return 'u16'
      case 'U32':
        return 'u32'
      case 'U64':
        return 'u64'
      case 'U128':
        return 'u128'
      case 'U256':
        return 'u256'
      default:
        throw new Error(`Unexpected type ${e}`)
    }
  if ('Vector' in e) return { vector: Vu(e.Vector) }
  if ('Struct' in e)
    return {
      datatype: {
        package: e.Struct.address,
        module: e.Struct.module,
        type: e.Struct.name,
        typeParameters: e.Struct.typeArguments.map(Vu),
      },
    }
  if ('TypeParameter' in e) return { typeParameter: e.TypeParameter }
  throw new Error(`Unexpected type ${JSON.stringify(e)}`)
}
function Y$(e) {
  return { $kind: 'Pure', Pure: { bytes: e instanceof Uint8Array ? Pt(e) : e.toBase64() } }
}
const Ts = {
  Pure: Y$,
  ObjectRef({ objectId: e, digest: t, version: n }) {
    return {
      $kind: 'Object',
      Object: {
        $kind: 'ImmOrOwnedObject',
        ImmOrOwnedObject: { digest: t, version: n, objectId: kt(e) },
      },
    }
  },
  SharedObjectRef({ objectId: e, mutable: t, initialSharedVersion: n }) {
    return {
      $kind: 'Object',
      Object: {
        $kind: 'SharedObject',
        SharedObject: { mutable: t, initialSharedVersion: n, objectId: kt(e) },
      },
    }
  },
  ReceivingRef({ objectId: e, digest: t, version: n }) {
    return {
      $kind: 'Object',
      Object: { $kind: 'Receiving', Receiving: { digest: t, version: n, objectId: kt(e) } },
    }
  },
}
var v6 = class extends Error {
  constructor(t) {
    super(t[0].message)
    zn(this, 'issues')
    ;(this.name = 'ValiError'), (this.issues = t)
  }
}
function w6(e) {
  return typeof e == 'function' ? e() : e
}
function zw(e, t, n, r, i) {
  return { issues: [{ validation: e, message: w6(t), input: n, requirement: r, path: i }] }
}
function Ww(e) {
  return { output: e }
}
function Di(e, t) {
  return Array.isArray(e) ? [void 0, e] : [e, t]
}
function as(e, t, n) {
  return { typed: e, output: t, issues: n }
}
function b6(e, t, n) {
  if (!e || (typeof e == 'object' && !Array.isArray(e))) {
    const [s, o] = Di(t, n)
    return [e, s, o]
  }
  const [r, i] = Di(e, t)
  return [void 0, r, i]
}
function Q$(e, t) {
  return {
    reason: e == null ? void 0 : e.reason,
    validation: t.validation,
    origin: (e == null ? void 0 : e.origin) || 'value',
    message: t.message,
    input: t.input,
    requirement: t == null ? void 0 : t.requirement,
    path: t.path,
    abortEarly: e == null ? void 0 : e.abortEarly,
    abortPipeEarly: e == null ? void 0 : e.abortPipeEarly,
    skipPipe: e == null ? void 0 : e.skipPipe,
  }
}
function X$(e, t) {
  return {
    reason: t,
    origin: e == null ? void 0 : e.origin,
    abortEarly: e == null ? void 0 : e.abortEarly,
    abortPipeEarly: e == null ? void 0 : e.abortPipeEarly,
    skipPipe: e == null ? void 0 : e.skipPipe,
  }
}
function ii(e, t, n, r, i) {
  let s,
    o = e
  if (t != null && t.length && !(n != null && n.skipPipe))
    for (const a of t) {
      const l = a._parse(o)
      if (l.issues) {
        s = s || X$(n, r)
        for (const c of l.issues) {
          const u = Q$(s, c)
          i ? i.push(u) : (i = [u])
        }
        if (s.abortEarly || s.abortPipeEarly) break
      } else o = l.output
    }
  return as(!0, o, i)
}
function ni(e, t, n, r, i, s, o) {
  return {
    typed: !1,
    output: i,
    issues: [
      {
        reason: t,
        validation: n,
        origin: (e == null ? void 0 : e.origin) || 'value',
        message: w6(r),
        input: i,
        path: s,
        issues: o,
        abortEarly: e == null ? void 0 : e.abortEarly,
        abortPipeEarly: e == null ? void 0 : e.abortPipeEarly,
        skipPipe: e == null ? void 0 : e.skipPipe,
      },
    ],
  }
}
function Vw(e) {
  return typeof e.default == 'function' ? e.default() : e.default
}
function xv(e, t, n) {
  return !e._parse(t, { abortEarly: !0, skipPipe: n == null ? void 0 : n.skipPipe }).issues
}
function xt(e, t, n) {
  const [r = 'Invalid type', i] = Di(t, n)
  return {
    type: 'array',
    async: !1,
    item: e,
    message: r,
    pipe: i,
    _parse(s, o) {
      if (!Array.isArray(s)) return ni(o, 'type', 'array', this.message, s)
      let a = !0,
        l
      const c = []
      for (let u = 0; u < s.length; u++) {
        const f = s[u],
          d = this.item._parse(f, o)
        if (d.issues) {
          const p = { type: 'array', input: s, key: u, value: f }
          for (const h of d.issues)
            h.path ? h.path.unshift(p) : (h.path = [p]), l == null || l.push(h)
          if ((l || (l = d.issues), o != null && o.abortEarly)) {
            a = !1
            break
          }
        }
        d.typed || (a = !1), c.push(d.output)
      }
      return a ? ii(c, this.pipe, o, 'array', l) : as(!1, c, l)
    },
  }
}
function Z$(e, t) {
  const [n = 'Invalid type', r] = Di(e, t)
  return {
    type: 'bigint',
    async: !1,
    message: n,
    pipe: r,
    _parse(i, s) {
      return typeof i != 'bigint'
        ? ni(s, 'type', 'bigint', this.message, i)
        : ii(i, this.pipe, s, 'bigint')
    },
  }
}
function Hw(e, t) {
  const [n = 'Invalid type', r] = Di(e, t)
  return {
    type: 'boolean',
    async: !1,
    message: n,
    pipe: r,
    _parse(i, s) {
      return typeof i != 'boolean'
        ? ni(s, 'type', 'boolean', this.message, i)
        : ii(i, this.pipe, s, 'boolean')
    },
  }
}
function Lt(e, t = 'Invalid type') {
  return {
    type: 'literal',
    async: !1,
    literal: e,
    message: t,
    _parse(n, r) {
      return n !== this.literal ? ni(r, 'type', 'literal', this.message, n) : as(!0, n)
    },
  }
}
function xn(e, t) {
  return {
    type: 'nullable',
    async: !1,
    wrapped: e,
    default: t,
    _parse(n, r) {
      if (n === null) {
        const i = Vw(this)
        if (i === void 0) return as(!0, n)
        n = i
      }
      return this.wrapped._parse(n, r)
    },
  }
}
function Hp(e, t) {
  return {
    type: 'nullish',
    async: !1,
    wrapped: e,
    default: t,
    _parse(n, r) {
      if (n == null) {
        const i = Vw(this)
        if (i === void 0) return as(!0, n)
        n = i
      }
      return this.wrapped._parse(n, r)
    },
  }
}
function br(e, t) {
  const [n = 'Invalid type', r] = Di(e, t)
  return {
    type: 'number',
    async: !1,
    message: n,
    pipe: r,
    _parse(i, s) {
      return typeof i != 'number' || isNaN(i)
        ? ni(s, 'type', 'number', this.message, i)
        : ii(i, this.pipe, s, 'number')
    },
  }
}
function Ue(e, t, n, r) {
  const [i, s = 'Invalid type', o] = b6(t, n, r)
  let a
  return {
    type: 'object',
    async: !1,
    entries: e,
    rest: i,
    message: s,
    pipe: o,
    _parse(l, c) {
      if (!l || typeof l != 'object') return ni(c, 'type', 'object', this.message, l)
      a = a || Object.entries(this.entries)
      let u = !0,
        f
      const d = {}
      for (const [p, h] of a) {
        const m = l[p],
          b = h._parse(m, c)
        if (b.issues) {
          const y = { type: 'object', input: l, key: p, value: m }
          for (const v of b.issues)
            v.path ? v.path.unshift(y) : (v.path = [y]), f == null || f.push(v)
          if ((f || (f = b.issues), c != null && c.abortEarly)) {
            u = !1
            break
          }
        }
        b.typed || (u = !1), (b.output !== void 0 || p in l) && (d[p] = b.output)
      }
      if (this.rest && !(c != null && c.abortEarly && f)) {
        for (const p in l)
          if (!(p in this.entries)) {
            const h = l[p],
              m = this.rest._parse(h, c)
            if (m.issues) {
              const b = { type: 'object', input: l, key: p, value: h }
              for (const y of m.issues)
                y.path ? y.path.unshift(b) : (y.path = [b]), f == null || f.push(y)
              if ((f || (f = m.issues), c != null && c.abortEarly)) {
                u = !1
                break
              }
            }
            m.typed || (u = !1), (d[p] = m.output)
          }
      }
      return u ? ii(d, this.pipe, c, 'object', f) : as(!1, d, f)
    },
  }
}
function Rs(e, t) {
  return {
    type: 'optional',
    async: !1,
    wrapped: e,
    default: t,
    _parse(n, r) {
      if (n === void 0) {
        const i = Vw(this)
        if (i === void 0) return as(!0, n)
        n = i
      }
      return this.wrapped._parse(n, r)
    },
  }
}
function yt(e, t) {
  const [n = 'Invalid type', r] = Di(e, t)
  return {
    type: 'string',
    async: !1,
    message: n,
    pipe: r,
    _parse(i, s) {
      return typeof i != 'string'
        ? ni(s, 'type', 'string', this.message, i)
        : ii(i, this.pipe, s, 'string')
    },
  }
}
function J$(e, t, n, r) {
  if (typeof t == 'object' && !Array.isArray(t)) {
    const [o, a] = Di(n, r)
    return [e, t, o, a]
  }
  const [i, s] = Di(t, n)
  return [yt(), e, i, s]
}
var e9 = ['__proto__', 'prototype', 'constructor']
function qp(e, t, n, r) {
  const [i, s, o = 'Invalid type', a] = J$(e, t, n, r)
  return {
    type: 'record',
    async: !1,
    key: i,
    value: s,
    message: o,
    pipe: a,
    _parse(l, c) {
      if (!l || typeof l != 'object') return ni(c, 'type', 'record', this.message, l)
      let u = !0,
        f
      const d = {}
      for (const [p, h] of Object.entries(l))
        if (!e9.includes(p)) {
          let m
          const b = this.key._parse(p, {
            origin: 'key',
            abortEarly: c == null ? void 0 : c.abortEarly,
            abortPipeEarly: c == null ? void 0 : c.abortPipeEarly,
            skipPipe: c == null ? void 0 : c.skipPipe,
          })
          if (b.issues) {
            m = { type: 'record', input: l, key: p, value: h }
            for (const v of b.issues) (v.path = [m]), f == null || f.push(v)
            if ((f || (f = b.issues), c != null && c.abortEarly)) {
              u = !1
              break
            }
          }
          const y = this.value._parse(h, c)
          if (y.issues) {
            m = m || { type: 'record', input: l, key: p, value: h }
            for (const v of y.issues)
              v.path ? v.path.unshift(m) : (v.path = [m]), f == null || f.push(v)
            if ((f || (f = y.issues), c != null && c.abortEarly)) {
              u = !1
              break
            }
          }
          ;(!b.typed || !y.typed) && (u = !1), b.typed && (d[b.output] = y.output)
        }
      return u ? ii(d, this.pipe, c, 'record', f) : as(!1, d, f)
    },
  }
}
function RS(e) {
  return {
    type: 'recursive',
    async: !1,
    getter: e,
    _parse(t, n) {
      return this.getter()._parse(t, n)
    },
  }
}
function x6(e, t, n, r) {
  const [i, s = 'Invalid type', o] = b6(t, n, r)
  return {
    type: 'tuple',
    async: !1,
    items: e,
    rest: i,
    message: s,
    pipe: o,
    _parse(a, l) {
      if (!Array.isArray(a) || this.items.length > a.length)
        return ni(l, 'type', 'tuple', this.message, a)
      let c = !0,
        u
      const f = []
      for (let d = 0; d < this.items.length; d++) {
        const p = a[d],
          h = this.items[d]._parse(p, l)
        if (h.issues) {
          const m = { type: 'tuple', input: a, key: d, value: p }
          for (const b of h.issues)
            b.path ? b.path.unshift(m) : (b.path = [m]), u == null || u.push(b)
          if ((u || (u = h.issues), l != null && l.abortEarly)) {
            c = !1
            break
          }
        }
        h.typed || (c = !1), (f[d] = h.output)
      }
      if (this.rest && !(l != null && l.abortEarly && u))
        for (let d = this.items.length; d < a.length; d++) {
          const p = a[d],
            h = this.rest._parse(p, l)
          if (h.issues) {
            const m = { type: 'tuple', input: a, key: d, value: p }
            for (const b of h.issues)
              b.path ? b.path.unshift(m) : (b.path = [m]), u == null || u.push(b)
            if ((u || (u = h.issues), l != null && l.abortEarly)) {
              c = !1
              break
            }
          }
          h.typed || (c = !1), (f[d] = h.output)
        }
      return c ? ii(f, this.pipe, l, 'tuple', u) : as(!1, f, u)
    },
  }
}
function zs(e, t, n) {
  const [r = 'Invalid type', i] = Di(t, n)
  return {
    type: 'union',
    async: !1,
    options: e,
    message: r,
    pipe: i,
    _parse(s, o) {
      let a, l
      for (const c of this.options) {
        const u = c._parse(s, o)
        if (u.issues)
          if (a) for (const f of u.issues) a.push(f)
          else a = u.issues
        else {
          l = [u.output]
          break
        }
      }
      return l
        ? ii(l[0], this.pipe, o, 'union')
        : ni(o, 'type', 'union', this.message, s, void 0, a)
    },
  }
}
function rg(e) {
  return {
    type: 'unknown',
    async: !1,
    pipe: e,
    _parse(t, n) {
      return ii(t, this.pipe, n, 'unknown')
    },
  }
}
function S6(e, t, n, r) {
  const [i = 'Invalid type', s] = Di(n, r)
  return {
    type: 'variant',
    async: !1,
    key: e,
    options: t,
    message: i,
    pipe: s,
    _parse(o, a) {
      if (!o || typeof o != 'object') return ni(a, 'type', 'variant', this.message, o)
      if (this.key in o) {
        let l, c
        const u = (f) => {
          for (const d of f)
            if (d.type === 'object') {
              if (!d.entries[this.key]._parse(o[this.key], a).issues) {
                const h = d._parse(o, a)
                if (h.issues) l = h.issues
                else {
                  c = [h.output]
                  break
                }
              }
            } else if (d.type === 'variant' && (u(d.options), c)) break
        }
        if ((u(this.options), c)) return ii(c[0], this.pipe, a, 'variant')
        if (l) return as(!1, c, l)
      }
      return ni(a, 'type', 'variant', this.message, o, [
        { type: 'object', input: o, key: this.key, value: void 0 },
      ])
    },
  }
}
function Yt(e, t, n) {
  const r = e._parse(t, n)
  if (r.issues) throw new v6(r.issues)
  return r.output
}
function t9(e, t, n) {
  const r = e._parse(t, n)
  return {
    typed: r.typed,
    success: !r.issues,
    data: r.output,
    output: r.output,
    error: r.issues && new v6(r.issues),
    issues: r.issues,
  }
}
function qw(e, t, n) {
  return {
    ...e,
    _parse(r, i) {
      const s = e._parse(r, i)
      return s.typed
        ? ((s.output = t(s.output, { issues: s.issues })),
          s.issues || !n
            ? s
            : Array.isArray(n)
            ? ii(s.output, n, i, typeof s.output)
            : n._parse(s.output, i))
        : s
    },
  }
}
var n9 = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu
function E6(e, t = 'Invalid input') {
  return {
    type: 'custom',
    async: !1,
    message: t,
    requirement: e,
    _parse(n) {
      return this.requirement(n) ? Ww(n) : zw(this.type, this.message, n, this.requirement)
    },
  }
}
function xr(e = 'Invalid integer') {
  return {
    type: 'integer',
    async: !1,
    message: e,
    requirement: Number.isInteger,
    _parse(t) {
      return this.requirement(t) ? Ww(t) : zw(this.type, this.message, t, this.requirement)
    },
  }
}
function r9(e = 'Invalid UUID') {
  return {
    type: 'uuid',
    async: !1,
    message: e,
    requirement: n9,
    _parse(t) {
      return this.requirement.test(t) ? Ww(t) : zw(this.type, this.message, t, this.requirement)
    },
  }
}
function Ya(e) {
  const t = Object.entries(e).map(([n, r]) => Ue({ [n]: r }))
  return qw(zs(t), (n) => ({ ...n, $kind: Object.keys(n)[0] }))
}
const zc = qw(yt(), (e) => kt(e), [E6(xs)]),
  Cr = zc,
  za = yt(),
  fr = zs(
    [yt(), br([xr()])],
    [
      E6((e) => {
        try {
          return BigInt(e), BigInt(e) >= 0 && BigInt(e) <= 18446744073709551615n
        } catch {
          return !1
        }
      }, 'Invalid u64'),
    ]
  ),
  Fo = Ue({ objectId: zc, version: fr, digest: yt() }),
  Mt = qw(
    zs([
      Ue({ GasCoin: Lt(!0) }),
      Ue({ Input: br([xr()]), type: Rs(Lt('pure')) }),
      Ue({ Input: br([xr()]), type: Rs(Lt('object')) }),
      Ue({ Result: br([xr()]) }),
      Ue({ NestedResult: x6([br([xr()]), br([xr()])]) }),
    ]),
    (e) => ({ ...e, $kind: Object.keys(e)[0] })
  ),
  i9 = Ue({ budget: xn(fr), price: xn(fr), owner: xn(zc), payment: xn(xt(Fo)) }),
  Sv = zs([
    Lt('address'),
    Lt('bool'),
    Lt('u8'),
    Lt('u16'),
    Lt('u32'),
    Lt('u64'),
    Lt('u128'),
    Lt('u256'),
    Ue({ vector: RS(() => Sv) }),
    Ue({
      datatype: Ue({ package: yt(), module: yt(), type: yt(), typeParameters: xt(RS(() => Sv)) }),
    }),
    Ue({ typeParameter: br([xr()]) }),
  ]),
  s9 = Ue({ ref: xn(zs([Lt('&'), Lt('&mut')])), body: Sv }),
  o9 = Ue({
    package: Cr,
    module: yt(),
    function: yt(),
    typeArguments: xt(yt()),
    arguments: xt(Mt),
    _argumentTypes: Rs(xn(xt(s9))),
  }),
  a9 = Ue({ name: yt(), inputs: qp(yt(), zs([Mt, xt(Mt)])), data: qp(yt(), rg()) }),
  l9 = Ya({
    MoveCall: o9,
    TransferObjects: Ue({ objects: xt(Mt), address: Mt }),
    SplitCoins: Ue({ coin: Mt, amounts: xt(Mt) }),
    MergeCoins: Ue({ destination: Mt, sources: xt(Mt) }),
    Publish: Ue({ modules: xt(za), dependencies: xt(Cr) }),
    MakeMoveVec: Ue({ type: xn(yt()), elements: xt(Mt) }),
    Upgrade: Ue({ modules: xt(za), dependencies: xt(Cr), package: Cr, ticket: Mt }),
    $Intent: a9,
  }),
  C6 = Ya({
    ImmOrOwnedObject: Fo,
    SharedObject: Ue({ objectId: Cr, initialSharedVersion: fr, mutable: Hw() }),
    Receiving: Fo,
  }),
  c9 = Ya({
    Object: C6,
    Pure: Ue({ bytes: za }),
    UnresolvedPure: Ue({ value: rg() }),
    UnresolvedObject: Ue({
      objectId: Cr,
      version: Rs(xn(fr)),
      digest: Rs(xn(yt())),
      initialSharedVersion: Rs(xn(fr)),
    }),
  }),
  PS = Ya({ Object: C6, Pure: Ue({ bytes: za }) }),
  _6 = Ya({ None: Lt(!0), Epoch: fr }),
  Mh = Ue({
    version: Lt(2),
    sender: Hp(zc),
    expiration: Hp(_6),
    gasData: i9,
    inputs: xt(c9),
    commands: xt(l9),
  }),
  Zo = {
    MoveCall(e) {
      const [t, n = '', r = ''] =
        'target' in e ? e.target.split('::') : [e.package, e.module, e.function]
      return {
        $kind: 'MoveCall',
        MoveCall: {
          package: t,
          module: n,
          function: r,
          typeArguments: e.typeArguments ?? [],
          arguments: e.arguments ?? [],
        },
      }
    },
    TransferObjects(e, t) {
      return {
        $kind: 'TransferObjects',
        TransferObjects: { objects: e.map((n) => Yt(Mt, n)), address: Yt(Mt, t) },
      }
    },
    SplitCoins(e, t) {
      return {
        $kind: 'SplitCoins',
        SplitCoins: { coin: Yt(Mt, e), amounts: t.map((n) => Yt(Mt, n)) },
      }
    },
    MergeCoins(e, t) {
      return {
        $kind: 'MergeCoins',
        MergeCoins: { destination: Yt(Mt, e), sources: t.map((n) => Yt(Mt, n)) },
      }
    },
    Publish({ modules: e, dependencies: t }) {
      return {
        $kind: 'Publish',
        Publish: {
          modules: e.map((n) => (typeof n == 'string' ? n : Pt(new Uint8Array(n)))),
          dependencies: t.map((n) => ks(n)),
        },
      }
    },
    Upgrade({ modules: e, dependencies: t, package: n, ticket: r }) {
      return {
        $kind: 'Upgrade',
        Upgrade: {
          modules: e.map((i) => (typeof i == 'string' ? i : Pt(new Uint8Array(i)))),
          dependencies: t.map((i) => ks(i)),
          package: n,
          ticket: Yt(Mt, r),
        },
      }
    },
    MakeMoveVec({ type: e, elements: t }) {
      return {
        $kind: 'MakeMoveVec',
        MakeMoveVec: { type: e ?? null, elements: t.map((n) => Yt(Mt, n)) },
      }
    },
    Intent({ name: e, inputs: t = {}, data: n = {} }) {
      return {
        $kind: '$Intent',
        $Intent: {
          name: e,
          inputs: Object.fromEntries(
            Object.entries(t).map(([r, i]) => [
              r,
              Array.isArray(i) ? i.map((s) => Yt(Mt, s)) : Yt(Mt, i),
            ])
          ),
          data: n,
        },
      }
    },
  },
  IS = Ue({ digest: yt(), objectId: yt(), version: zs([br([xr()]), yt(), Z$()]) }),
  u9 = Ya({
    ImmOrOwned: IS,
    Shared: Ue({ objectId: Cr, initialSharedVersion: fr, mutable: Hw() }),
    Receiving: IS,
  }),
  DS = Ya({ Object: u9, Pure: xt(br([xr()])) })
function NS(e) {
  var n
  const t = e.inputs.map((r, i) => {
    if (r.Object)
      return {
        kind: 'Input',
        index: i,
        value: {
          Object: r.Object.ImmOrOwnedObject
            ? { ImmOrOwned: r.Object.ImmOrOwnedObject }
            : r.Object.Receiving
            ? {
                Receiving: {
                  digest: r.Object.Receiving.digest,
                  version: r.Object.Receiving.version,
                  objectId: r.Object.Receiving.objectId,
                },
              }
            : {
                Shared: {
                  mutable: r.Object.SharedObject.mutable,
                  initialSharedVersion: r.Object.SharedObject.initialSharedVersion,
                  objectId: r.Object.SharedObject.objectId,
                },
              },
        },
        type: 'object',
      }
    if (r.Pure)
      return {
        kind: 'Input',
        index: i,
        value: { Pure: Array.from(Gn(r.Pure.bytes)) },
        type: 'pure',
      }
    if (r.UnresolvedPure)
      return { kind: 'Input', type: 'pure', index: i, value: r.UnresolvedPure.value }
    if (r.UnresolvedObject)
      return { kind: 'Input', type: 'object', index: i, value: r.UnresolvedObject.objectId }
    throw new Error('Invalid input')
  })
  return {
    version: 1,
    sender: e.sender ?? void 0,
    expiration:
      ((n = e.expiration) == null ? void 0 : n.$kind) === 'Epoch'
        ? { Epoch: Number(e.expiration.Epoch) }
        : e.expiration
        ? { None: !0 }
        : null,
    gasConfig: {
      owner: e.gasData.owner ?? void 0,
      budget: e.gasData.budget ?? void 0,
      price: e.gasData.price ?? void 0,
      payment: e.gasData.payment ?? void 0,
    },
    inputs: t,
    transactions: e.commands.map((r) => {
      if (r.MakeMoveVec)
        return {
          kind: 'MakeMoveVec',
          type:
            r.MakeMoveVec.type === null
              ? { None: !0 }
              : { Some: Qi.parseFromStr(r.MakeMoveVec.type) },
          objects: r.MakeMoveVec.elements.map((i) => us(i, t)),
        }
      if (r.MergeCoins)
        return {
          kind: 'MergeCoins',
          destination: us(r.MergeCoins.destination, t),
          sources: r.MergeCoins.sources.map((i) => us(i, t)),
        }
      if (r.MoveCall)
        return {
          kind: 'MoveCall',
          target: `${r.MoveCall.package}::${r.MoveCall.module}::${r.MoveCall.function}`,
          typeArguments: r.MoveCall.typeArguments,
          arguments: r.MoveCall.arguments.map((i) => us(i, t)),
        }
      if (r.Publish)
        return {
          kind: 'Publish',
          modules: r.Publish.modules.map((i) => Array.from(Gn(i))),
          dependencies: r.Publish.dependencies,
        }
      if (r.SplitCoins)
        return {
          kind: 'SplitCoins',
          coin: us(r.SplitCoins.coin, t),
          amounts: r.SplitCoins.amounts.map((i) => us(i, t)),
        }
      if (r.TransferObjects)
        return {
          kind: 'TransferObjects',
          objects: r.TransferObjects.objects.map((i) => us(i, t)),
          address: us(r.TransferObjects.address, t),
        }
      if (r.Upgrade)
        return {
          kind: 'Upgrade',
          modules: r.Upgrade.modules.map((i) => Array.from(Gn(i))),
          dependencies: r.Upgrade.dependencies,
          packageId: r.Upgrade.package,
          ticket: us(r.Upgrade.ticket, t),
        }
      throw new Error(`Unknown transaction ${Object.keys(r)}`)
    }),
  }
}
function us(e, t) {
  if (e.$kind === 'GasCoin') return { kind: 'GasCoin' }
  if (e.$kind === 'Result') return { kind: 'Result', index: e.Result }
  if (e.$kind === 'NestedResult')
    return { kind: 'NestedResult', index: e.NestedResult[0], resultIndex: e.NestedResult[1] }
  if (e.$kind === 'Input') return t[e.Input]
  throw new Error(`Invalid argument ${Object.keys(e)}`)
}
function f9(e) {
  var t, n, r
  return Yt(Mh, {
    version: 2,
    sender: e.sender ?? null,
    expiration: e.expiration
      ? 'Epoch' in e.expiration
        ? { Epoch: e.expiration.Epoch }
        : { None: !0 }
      : null,
    gasData: {
      owner: e.gasConfig.owner ?? null,
      budget: ((t = e.gasConfig.budget) == null ? void 0 : t.toString()) ?? null,
      price: ((n = e.gasConfig.price) == null ? void 0 : n.toString()) ?? null,
      payment:
        ((r = e.gasConfig.payment) == null
          ? void 0
          : r.map((i) => ({
              digest: i.digest,
              objectId: i.objectId,
              version: i.version.toString(),
            }))) ?? null,
    },
    inputs: e.inputs.map((i) => {
      if (i.kind === 'Input') {
        if (xv(DS, i.value)) {
          const s = Yt(DS, i.value)
          if (s.Object) {
            if (s.Object.ImmOrOwned)
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: s.Object.ImmOrOwned.objectId,
                    version: String(s.Object.ImmOrOwned.version),
                    digest: s.Object.ImmOrOwned.digest,
                  },
                },
              }
            if (s.Object.Shared)
              return {
                Object: {
                  SharedObject: {
                    mutable: s.Object.Shared.mutable ?? null,
                    initialSharedVersion: s.Object.Shared.initialSharedVersion,
                    objectId: s.Object.Shared.objectId,
                  },
                },
              }
            if (s.Object.Receiving)
              return {
                Object: {
                  Receiving: {
                    digest: s.Object.Receiving.digest,
                    version: String(s.Object.Receiving.version),
                    objectId: s.Object.Receiving.objectId,
                  },
                },
              }
            throw new Error('Invalid object input')
          }
          return { Pure: { bytes: Pt(new Uint8Array(s.Pure)) } }
        }
        return i.type === 'object'
          ? { UnresolvedObject: { objectId: i.value } }
          : { UnresolvedPure: { value: i.value } }
      }
      throw new Error('Invalid input')
    }),
    commands: e.transactions.map((i) => {
      switch (i.kind) {
        case 'MakeMoveVec':
          return {
            MakeMoveVec: {
              type: 'Some' in i.type ? Qi.tagToString(i.type.Some) : null,
              elements: i.objects.map((s) => fs(s)),
            },
          }
        case 'MergeCoins':
          return {
            MergeCoins: { destination: fs(i.destination), sources: i.sources.map((s) => fs(s)) },
          }
        case 'MoveCall': {
          const [s, o, a] = i.target.split('::')
          return {
            MoveCall: {
              package: s,
              module: o,
              function: a,
              typeArguments: i.typeArguments,
              arguments: i.arguments.map((l) => fs(l)),
            },
          }
        }
        case 'Publish':
          return {
            Publish: {
              modules: i.modules.map((s) => Pt(Uint8Array.from(s))),
              dependencies: i.dependencies,
            },
          }
        case 'SplitCoins':
          return { SplitCoins: { coin: fs(i.coin), amounts: i.amounts.map((s) => fs(s)) } }
        case 'TransferObjects':
          return {
            TransferObjects: { objects: i.objects.map((s) => fs(s)), address: fs(i.address) },
          }
        case 'Upgrade':
          return {
            Upgrade: {
              modules: i.modules.map((s) => Pt(Uint8Array.from(s))),
              dependencies: i.dependencies,
              package: i.packageId,
              ticket: fs(i.ticket),
            },
          }
      }
      throw new Error(`Unknown transaction ${Object.keys(i)}`)
    }),
  })
}
function fs(e) {
  switch (e.kind) {
    case 'GasCoin':
      return { GasCoin: !0 }
    case 'Result':
      return { Result: e.index }
    case 'NestedResult':
      return { NestedResult: [e.index, e.resultIndex] }
    case 'Input':
      return { Input: e.index }
  }
}
function td(e) {
  return zs(Object.entries(e).map(([t, n]) => Ue({ [t]: n })))
}
const gi = td({
    GasCoin: Lt(!0),
    Input: br([xr()]),
    Result: br([xr()]),
    NestedResult: x6([br([xr()]), br([xr()])]),
  }),
  d9 = Ue({ budget: xn(fr), price: xn(fr), owner: xn(zc), payment: xn(xt(Fo)) }),
  h9 = Ue({
    package: Cr,
    module: yt(),
    function: yt(),
    typeArguments: xt(yt()),
    arguments: xt(gi),
  }),
  p9 = Ue({ name: yt(), inputs: qp(yt(), zs([gi, xt(gi)])), data: qp(yt(), rg()) }),
  g9 = td({
    MoveCall: h9,
    TransferObjects: Ue({ objects: xt(gi), address: gi }),
    SplitCoins: Ue({ coin: gi, amounts: xt(gi) }),
    MergeCoins: Ue({ destination: gi, sources: xt(gi) }),
    Publish: Ue({ modules: xt(za), dependencies: xt(Cr) }),
    MakeMoveVec: Ue({ type: xn(yt()), elements: xt(gi) }),
    Upgrade: Ue({ modules: xt(za), dependencies: xt(Cr), package: Cr, ticket: gi }),
    $Intent: p9,
  }),
  m9 = td({
    ImmOrOwnedObject: Fo,
    SharedObject: Ue({ objectId: Cr, initialSharedVersion: fr, mutable: Hw() }),
    Receiving: Fo,
  }),
  y9 = td({
    Object: m9,
    Pure: Ue({ bytes: za }),
    UnresolvedPure: Ue({ value: rg() }),
    UnresolvedObject: Ue({
      objectId: Cr,
      version: Rs(xn(fr)),
      digest: Rs(xn(yt())),
      initialSharedVersion: Rs(xn(fr)),
    }),
  }),
  v9 = td({ None: Lt(!0), Epoch: fr }),
  w9 = Ue({
    version: Lt(2),
    sender: Hp(zc),
    expiration: Hp(v9),
    gasData: d9,
    inputs: xt(y9),
    commands: xt(g9),
  }),
  b9 = 50,
  x9 = 1000n,
  S9 = 5e10
async function E9(e, t, n) {
  return (
    await T9(e, t),
    await k9(e, t),
    t.onlyTransactionKind || (await C9(e, t), await _9(e, t), await O9(e, t)),
    await A9(e),
    await n()
  )
}
async function C9(e, t) {
  e.gasConfig.price || (e.gasConfig.price = String(await nd(t).getReferenceGasPrice()))
}
async function _9(e, t) {
  if (e.gasConfig.budget) return
  const n = await nd(t).dryRunTransactionBlock({
    transactionBlock: e.build({ overrides: { gasData: { budget: String(S9), payment: [] } } }),
  })
  if (n.effects.status.status !== 'success')
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${n.effects.status.error}`,
      { cause: n }
    )
  const r = x9 * BigInt(e.gasConfig.price || 1n),
    i = BigInt(n.effects.gasUsed.computationCost) + r,
    s = i + BigInt(n.effects.gasUsed.storageCost) - BigInt(n.effects.gasUsed.storageRebate)
  e.gasConfig.budget = String(s > i ? s : i)
}
async function O9(e, t) {
  if (!e.gasConfig.payment) {
    const r = (await nd(t).getCoins({ owner: e.gasConfig.owner || e.sender, coinType: $$ })).data
      .filter(
        (i) =>
          !e.inputs.find((o) => {
            var a
            return (a = o.Object) != null && a.ImmOrOwnedObject
              ? i.coinObjectId === o.Object.ImmOrOwnedObject.objectId
              : !1
          })
      )
      .map((i) => ({ objectId: i.coinObjectId, digest: i.digest, version: i.version }))
    if (!r.length) throw new Error('No valid gas coins found for the transaction.')
    e.gasConfig.payment = r.map((i) => Yt(Fo, i))
  }
}
async function k9(e, t) {
  const n = e.inputs.filter((u) => {
      var f
      return (
        (u.UnresolvedObject && !u.UnresolvedObject.version) ||
        ((f = u.UnresolvedObject) == null ? void 0 : f.initialSharedVersion)
      )
    }),
    r = [...new Set(n.map((u) => ks(u.UnresolvedObject.objectId)))],
    i = r.length ? D9(r, b9) : [],
    s = (
      await Promise.all(i.map((u) => nd(t).multiGetObjects({ ids: u, options: { showOwner: !0 } })))
    ).flat(),
    o = new Map(r.map((u, f) => [u, s[f]])),
    a = Array.from(o)
      .filter(([u, f]) => f.error)
      .map(([u, f]) => u)
  if (a.length) throw new Error(`The following input objects are invalid: ${a.join(', ')}`)
  const l = s.map((u) => {
      if (u.error || !u.data) throw new Error(`Failed to fetch object: ${u.error}`)
      const f = u.data.owner,
        d = f && typeof f == 'object' && 'Shared' in f ? f.Shared.initial_shared_version : null
      return {
        objectId: u.data.objectId,
        digest: u.data.digest,
        version: u.data.version,
        initialSharedVersion: d,
      }
    }),
    c = new Map(r.map((u, f) => [u, l[f]]))
  for (const [u, f] of e.inputs.entries()) {
    if (!f.UnresolvedObject) continue
    let d
    const p = kt(f.UnresolvedObject.objectId),
      h = c.get(p)
    h != null && h.initialSharedVersion
      ? (d = Ts.SharedObjectRef({
          objectId: p,
          initialSharedVersion: h.initialSharedVersion,
          mutable: R9(e, u),
        }))
      : P9(e, u) &&
        (d = Ts.ReceivingRef({
          objectId: p,
          digest: f.UnresolvedObject.digest ?? (h == null ? void 0 : h.digest),
          version: f.UnresolvedObject.version ?? (h == null ? void 0 : h.version),
        })),
      (e.inputs[e.inputs.indexOf(f)] =
        d ??
        Ts.ObjectRef({
          objectId: p,
          digest: f.UnresolvedObject.digest ?? (h == null ? void 0 : h.digest),
          version: f.UnresolvedObject.version ?? (h == null ? void 0 : h.version),
        }))
  }
}
async function T9(e, t) {
  const { inputs: n, commands: r } = e,
    i = [],
    s = new Set()
  r.forEach((a) => {
    if (a.MoveCall) {
      if (a.MoveCall._argumentTypes) return
      if (
        a.MoveCall.arguments
          .map((u) => (u.$kind === 'Input' ? e.inputs[u.Input] : null))
          .some(
            (u) =>
              (u == null ? void 0 : u.UnresolvedPure) || (u == null ? void 0 : u.UnresolvedObject)
          )
      ) {
        const u = `${a.MoveCall.package}::${a.MoveCall.module}::${a.MoveCall.function}`
        s.add(u), i.push(a.MoveCall)
      }
    }
    switch (a.$kind) {
      case 'SplitCoins':
        a.SplitCoins.amounts.forEach((l) => {
          MS(l, lt.U64, e)
        })
        break
      case 'TransferObjects':
        MS(a.TransferObjects.address, lt.Address, e)
        break
    }
  })
  const o = new Map()
  if (s.size > 0) {
    const a = nd(t)
    await Promise.all(
      [...s].map(async (l) => {
        const [c, u, f] = l.split('::'),
          d = await a.getNormalizedMoveFunction({ package: c, module: u, function: f })
        o.set(
          l,
          d.parameters.map((p) => G$(p))
        )
      })
    )
  }
  i.length &&
    (await Promise.all(
      i.map(async (a) => {
        const l = o.get(`${a.package}::${a.module}::${a.function}`)
        if (!l) return
        const u = l.length > 0 && K$(l.at(-1)) ? l.slice(0, l.length - 1) : l
        a._argumentTypes = u
      })
    )),
    r.forEach((a) => {
      if (!a.MoveCall) return
      const l = a.MoveCall,
        c = `${l.package}::${l.module}::${l.function}`,
        u = l._argumentTypes
      if (u) {
        if (u.length !== a.MoveCall.arguments.length)
          throw new Error(`Incorrect number of arguments for ${c}`)
        u.forEach((f, d) => {
          var v, S
          const p = l.arguments[d]
          if (p.$kind !== 'Input') return
          const h = n[p.Input]
          if (!h.UnresolvedPure && !h.UnresolvedObject) return
          const m =
              ((v = h.UnresolvedPure) == null ? void 0 : v.value) ??
              ((S = h.UnresolvedObject) == null ? void 0 : S.objectId),
            b = bv(f.body)
          if (b) {
            ;(p.type = 'pure'), (n[n.indexOf(h)] = Ts.Pure(b.serialize(m)))
            return
          }
          if (typeof m != 'string')
            throw new Error(
              `Expect the argument to be an object id string, got ${JSON.stringify(m, null, 2)}`
            )
          p.type = 'object'
          const y = h.UnresolvedPure
            ? { $kind: 'UnresolvedObject', UnresolvedObject: { objectId: m } }
            : h
          n[p.Input] = y
        })
      }
    })
}
function A9(e) {
  e.inputs.forEach((t, n) => {
    if (t.$kind !== 'Object' && t.$kind !== 'Pure')
      throw new Error(
        `Input at index ${n} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          t
        )}`
      )
  })
}
function MS(e, t, n) {
  if (e.$kind !== 'Input') return
  const r = n.inputs[e.Input]
  r.$kind === 'UnresolvedPure' && (n.inputs[e.Input] = Ts.Pure(t.serialize(r.UnresolvedPure.value)))
}
function R9(e, t) {
  let n = !1
  return (
    e.getInputUses(t, (r, i) => {
      if (i.MoveCall && i.MoveCall._argumentTypes) {
        const s = i.MoveCall.arguments.indexOf(r)
        n = i.MoveCall._argumentTypes[s].ref !== '&' || n
      }
    }),
    n
  )
}
function P9(e, t) {
  let n = !1
  return (
    e.getInputUses(t, (r, i) => {
      if (i.MoveCall && i.MoveCall._argumentTypes) {
        const s = i.MoveCall.arguments.indexOf(r)
        n = I9(i.MoveCall._argumentTypes[s]) || n
      }
    }),
    n
  )
}
function I9(e) {
  return typeof e.body != 'object' || !('datatype' in e.body)
    ? !1
    : e.body.datatype.package === '0x2' &&
        e.body.datatype.module === 'transfer' &&
        e.body.datatype.type === 'Receiving'
}
function nd(e) {
  if (!e.client)
    throw new Error(
      'No provider passed to Transaction#build, but transaction data was not sufficient to build offline.'
    )
  return e.client
}
function D9(e, t) {
  return Array.from({ length: Math.ceil(e.length / t) }, (n, r) => e.slice(r * t, r * t + t))
}
function N9(e) {
  function t(n) {
    return e(n)
  }
  return (
    (t.u8 = (n) => e(lt.U8.serialize(n))),
    (t.u16 = (n) => e(lt.U16.serialize(n))),
    (t.u32 = (n) => e(lt.U32.serialize(n))),
    (t.u64 = (n) => e(lt.U64.serialize(n))),
    (t.u128 = (n) => e(lt.U128.serialize(n))),
    (t.u256 = (n) => e(lt.U256.serialize(n))),
    (t.bool = (n) => e(lt.Bool.serialize(n))),
    (t.string = (n) => e(lt.String.serialize(n))),
    (t.address = (n) => e(lt.Address.serialize(n))),
    (t.id = t.address),
    t
  )
}
function Mo(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`positive integer expected, not ${e}`)
}
function M9(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == 'object' && e.constructor.name === 'Uint8Array')
  )
}
function ig(e, ...t) {
  if (!M9(e)) throw new Error('Uint8Array expected')
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)
}
function O6(e) {
  if (typeof e != 'function' || typeof e.create != 'function')
    throw new Error('Hash should be wrapped by utils.wrapConstructor')
  Mo(e.outputLen), Mo(e.blockLen)
}
function Ec(e, t = !0) {
  if (e.destroyed) throw new Error('Hash instance has been destroyed')
  if (t && e.finished) throw new Error('Hash#digest() has already been called')
}
function k6(e, t) {
  ig(e)
  const n = t.outputLen
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Kp = (e) =>
    new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  jh = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  ra = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68,
  T6 = (e) =>
    ((e << 24) & 4278190080) | ((e << 8) & 16711680) | ((e >>> 8) & 65280) | ((e >>> 24) & 255),
  gs = ra ? (e) => e : (e) => T6(e)
function ol(e) {
  for (let t = 0; t < e.length; t++) e[t] = T6(e[t])
}
const j9 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, '0'))
function L9(e) {
  ig(e)
  let t = ''
  for (let n = 0; n < e.length; n++) t += j9[e[n]]
  return t
}
const ds = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 }
function jS(e) {
  if (e >= ds._0 && e <= ds._9) return e - ds._0
  if (e >= ds._A && e <= ds._F) return e - (ds._A - 10)
  if (e >= ds._a && e <= ds._f) return e - (ds._a - 10)
}
function $9(e) {
  if (typeof e != 'string') throw new Error('hex string expected, got ' + typeof e)
  const t = e.length,
    n = t / 2
  if (t % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + t)
  const r = new Uint8Array(n)
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = jS(e.charCodeAt(s)),
      a = jS(e.charCodeAt(s + 1))
    if (o === void 0 || a === void 0) {
      const l = e[s] + e[s + 1]
      throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + s)
    }
    r[i] = o * 16 + a
  }
  return r
}
function F9(e) {
  if (typeof e != 'string') throw new Error(`utf8ToBytes expected string, got ${typeof e}`)
  return new Uint8Array(new TextEncoder().encode(e))
}
function ts(e) {
  return typeof e == 'string' && (e = F9(e)), ig(e), e
}
class Kw {
  clone() {
    return this._cloneInto()
  }
}
const B9 = {}.toString
function U9(e, t) {
  if (t !== void 0 && B9.call(t) !== '[object Object]')
    throw new Error('Options should be object or undefined')
  return Object.assign(e, t)
}
function z9(e) {
  const t = (r) => e().update(ts(r)).digest(),
    n = e()
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = () => e()), t
}
function W9(e) {
  const t = (r, i) => e(i).update(ts(r)).digest(),
    n = e({})
  return (t.outputLen = n.outputLen), (t.blockLen = n.blockLen), (t.create = (r) => e(r)), t
}
const V9 = new Uint8Array([
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11,
  7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6,
  5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8,
  3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14,
  12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10,
  2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
  14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
])
class H9 extends Kw {
  constructor(t, n, r = {}, i, s, o) {
    if (
      (super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.length = 0),
      (this.pos = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Mo(t),
      Mo(n),
      Mo(i),
      n < 0 || n > i)
    )
      throw new Error('outputLen bigger than keyLen')
    if (r.key !== void 0 && (r.key.length < 1 || r.key.length > i))
      throw new Error(`key must be up 1..${i} byte long or undefined`)
    if (r.salt !== void 0 && r.salt.length !== s)
      throw new Error(`salt must be ${s} byte long or undefined`)
    if (r.personalization !== void 0 && r.personalization.length !== o)
      throw new Error(`personalization must be ${o} byte long or undefined`)
    this.buffer32 = Kp((this.buffer = new Uint8Array(t)))
  }
  update(t) {
    Ec(this)
    const { blockLen: n, buffer: r, buffer32: i } = this
    t = ts(t)
    const s = t.length,
      o = t.byteOffset,
      a = t.buffer
    for (let l = 0; l < s; ) {
      this.pos === n && (ra || ol(i), this.compress(i, 0, !1), ra || ol(i), (this.pos = 0))
      const c = Math.min(n - this.pos, s - l),
        u = o + l
      if (c === n && !(u % 4) && l + c < s) {
        const f = new Uint32Array(a, u, Math.floor((s - l) / 4))
        ra || ol(f)
        for (let d = 0; l + n < s; d += i.length, l += n)
          (this.length += n), this.compress(f, d, !1)
        ra || ol(f)
        continue
      }
      r.set(t.subarray(l, l + c), this.pos), (this.pos += c), (this.length += c), (l += c)
    }
    return this
  }
  digestInto(t) {
    Ec(this), k6(t, this)
    const { pos: n, buffer32: r } = this
    ;(this.finished = !0),
      this.buffer.subarray(n).fill(0),
      ra || ol(r),
      this.compress(r, 0, !0),
      ra || ol(r)
    const i = Kp(t)
    this.get().forEach((s, o) => (i[o] = gs(s)))
  }
  digest() {
    const { buffer: t, outputLen: n } = this
    this.digestInto(t)
    const r = t.slice(0, n)
    return this.destroy(), r
  }
  _cloneInto(t) {
    const { buffer: n, length: r, finished: i, destroyed: s, outputLen: o, pos: a } = this
    return (
      t || (t = new this.constructor({ dkLen: o })),
      t.set(...this.get()),
      (t.length = r),
      (t.finished = i),
      (t.destroyed = s),
      (t.outputLen = o),
      t.buffer.set(n),
      (t.pos = a),
      t
    )
  }
}
const Bd = BigInt(2 ** 32 - 1),
  Ev = BigInt(32)
function A6(e, t = !1) {
  return t
    ? { h: Number(e & Bd), l: Number((e >> Ev) & Bd) }
    : { h: Number((e >> Ev) & Bd) | 0, l: Number(e & Bd) | 0 }
}
function q9(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length)
  for (let i = 0; i < e.length; i++) {
    const { h: s, l: o } = A6(e[i], t)
    ;[n[i], r[i]] = [s, o]
  }
  return [n, r]
}
const K9 = (e, t) => (BigInt(e >>> 0) << Ev) | BigInt(t >>> 0),
  G9 = (e, t, n) => e >>> n,
  Y9 = (e, t, n) => (e << (32 - n)) | (t >>> n),
  Q9 = (e, t, n) => (e >>> n) | (t << (32 - n)),
  X9 = (e, t, n) => (e << (32 - n)) | (t >>> n),
  Z9 = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
  J9 = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
  eF = (e, t) => t,
  tF = (e, t) => e,
  nF = (e, t, n) => (e << n) | (t >>> (32 - n)),
  rF = (e, t, n) => (t << n) | (e >>> (32 - n)),
  iF = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  sF = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n))
function oF(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0)
  return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 }
}
const aF = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
  lF = (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
  cF = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  uF = (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
  fF = (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  dF = (e, t, n, r, i, s) => (t + n + r + i + s + ((e / 2 ** 32) | 0)) | 0,
  hF = {
    fromBig: A6,
    split: q9,
    toBig: K9,
    shrSH: G9,
    shrSL: Y9,
    rotrSH: Q9,
    rotrSL: X9,
    rotrBH: Z9,
    rotrBL: J9,
    rotr32H: eF,
    rotr32L: tF,
    rotlSH: nF,
    rotlSL: rF,
    rotlBH: iF,
    rotlBL: sF,
    add: oF,
    add3L: aF,
    add3H: lF,
    add4L: cF,
    add4H: uF,
    add5H: dF,
    add5L: fF,
  },
  je = hF,
  ln = new Uint32Array([
    4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762,
    2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225,
  ]),
  pe = new Uint32Array(32)
function Qs(e, t, n, r, i, s) {
  const o = i[s],
    a = i[s + 1]
  let l = pe[2 * e],
    c = pe[2 * e + 1],
    u = pe[2 * t],
    f = pe[2 * t + 1],
    d = pe[2 * n],
    p = pe[2 * n + 1],
    h = pe[2 * r],
    m = pe[2 * r + 1],
    b = je.add3L(l, u, o)
  ;(c = je.add3H(b, c, f, a)),
    (l = b | 0),
    ({ Dh: m, Dl: h } = { Dh: m ^ c, Dl: h ^ l }),
    ({ Dh: m, Dl: h } = { Dh: je.rotr32H(m, h), Dl: je.rotr32L(m, h) }),
    ({ h: p, l: d } = je.add(p, d, m, h)),
    ({ Bh: f, Bl: u } = { Bh: f ^ p, Bl: u ^ d }),
    ({ Bh: f, Bl: u } = { Bh: je.rotrSH(f, u, 24), Bl: je.rotrSL(f, u, 24) }),
    (pe[2 * e] = l),
    (pe[2 * e + 1] = c),
    (pe[2 * t] = u),
    (pe[2 * t + 1] = f),
    (pe[2 * n] = d),
    (pe[2 * n + 1] = p),
    (pe[2 * r] = h),
    (pe[2 * r + 1] = m)
}
function Xs(e, t, n, r, i, s) {
  const o = i[s],
    a = i[s + 1]
  let l = pe[2 * e],
    c = pe[2 * e + 1],
    u = pe[2 * t],
    f = pe[2 * t + 1],
    d = pe[2 * n],
    p = pe[2 * n + 1],
    h = pe[2 * r],
    m = pe[2 * r + 1],
    b = je.add3L(l, u, o)
  ;(c = je.add3H(b, c, f, a)),
    (l = b | 0),
    ({ Dh: m, Dl: h } = { Dh: m ^ c, Dl: h ^ l }),
    ({ Dh: m, Dl: h } = { Dh: je.rotrSH(m, h, 16), Dl: je.rotrSL(m, h, 16) }),
    ({ h: p, l: d } = je.add(p, d, m, h)),
    ({ Bh: f, Bl: u } = { Bh: f ^ p, Bl: u ^ d }),
    ({ Bh: f, Bl: u } = { Bh: je.rotrBH(f, u, 63), Bl: je.rotrBL(f, u, 63) }),
    (pe[2 * e] = l),
    (pe[2 * e + 1] = c),
    (pe[2 * t] = u),
    (pe[2 * t + 1] = f),
    (pe[2 * n] = d),
    (pe[2 * n + 1] = p),
    (pe[2 * r] = h),
    (pe[2 * r + 1] = m)
}
class pF extends H9 {
  constructor(t = {}) {
    super(128, t.dkLen === void 0 ? 64 : t.dkLen, t, 64, 16, 16),
      (this.v0l = ln[0] | 0),
      (this.v0h = ln[1] | 0),
      (this.v1l = ln[2] | 0),
      (this.v1h = ln[3] | 0),
      (this.v2l = ln[4] | 0),
      (this.v2h = ln[5] | 0),
      (this.v3l = ln[6] | 0),
      (this.v3h = ln[7] | 0),
      (this.v4l = ln[8] | 0),
      (this.v4h = ln[9] | 0),
      (this.v5l = ln[10] | 0),
      (this.v5h = ln[11] | 0),
      (this.v6l = ln[12] | 0),
      (this.v6h = ln[13] | 0),
      (this.v7l = ln[14] | 0),
      (this.v7h = ln[15] | 0)
    const n = t.key ? t.key.length : 0
    if (((this.v0l ^= this.outputLen | (n << 8) | 65536 | (1 << 24)), t.salt)) {
      const r = Kp(ts(t.salt))
      ;(this.v4l ^= gs(r[0])),
        (this.v4h ^= gs(r[1])),
        (this.v5l ^= gs(r[2])),
        (this.v5h ^= gs(r[3]))
    }
    if (t.personalization) {
      const r = Kp(ts(t.personalization))
      ;(this.v6l ^= gs(r[0])),
        (this.v6h ^= gs(r[1])),
        (this.v7l ^= gs(r[2])),
        (this.v7h ^= gs(r[3]))
    }
    if (t.key) {
      const r = new Uint8Array(this.blockLen)
      r.set(ts(t.key)), this.update(r)
    }
  }
  get() {
    let {
      v0l: t,
      v0h: n,
      v1l: r,
      v1h: i,
      v2l: s,
      v2h: o,
      v3l: a,
      v3h: l,
      v4l: c,
      v4h: u,
      v5l: f,
      v5h: d,
      v6l: p,
      v6h: h,
      v7l: m,
      v7h: b,
    } = this
    return [t, n, r, i, s, o, a, l, c, u, f, d, p, h, m, b]
  }
  set(t, n, r, i, s, o, a, l, c, u, f, d, p, h, m, b) {
    ;(this.v0l = t | 0),
      (this.v0h = n | 0),
      (this.v1l = r | 0),
      (this.v1h = i | 0),
      (this.v2l = s | 0),
      (this.v2h = o | 0),
      (this.v3l = a | 0),
      (this.v3h = l | 0),
      (this.v4l = c | 0),
      (this.v4h = u | 0),
      (this.v5l = f | 0),
      (this.v5h = d | 0),
      (this.v6l = p | 0),
      (this.v6h = h | 0),
      (this.v7l = m | 0),
      (this.v7h = b | 0)
  }
  compress(t, n, r) {
    this.get().forEach((l, c) => (pe[c] = l)), pe.set(ln, 16)
    let { h: i, l: s } = je.fromBig(BigInt(this.length))
    ;(pe[24] = ln[8] ^ s), (pe[25] = ln[9] ^ i), r && ((pe[28] = ~pe[28]), (pe[29] = ~pe[29]))
    let o = 0
    const a = V9
    for (let l = 0; l < 12; l++)
      Qs(0, 4, 8, 12, t, n + 2 * a[o++]),
        Xs(0, 4, 8, 12, t, n + 2 * a[o++]),
        Qs(1, 5, 9, 13, t, n + 2 * a[o++]),
        Xs(1, 5, 9, 13, t, n + 2 * a[o++]),
        Qs(2, 6, 10, 14, t, n + 2 * a[o++]),
        Xs(2, 6, 10, 14, t, n + 2 * a[o++]),
        Qs(3, 7, 11, 15, t, n + 2 * a[o++]),
        Xs(3, 7, 11, 15, t, n + 2 * a[o++]),
        Qs(0, 5, 10, 15, t, n + 2 * a[o++]),
        Xs(0, 5, 10, 15, t, n + 2 * a[o++]),
        Qs(1, 6, 11, 12, t, n + 2 * a[o++]),
        Xs(1, 6, 11, 12, t, n + 2 * a[o++]),
        Qs(2, 7, 8, 13, t, n + 2 * a[o++]),
        Xs(2, 7, 8, 13, t, n + 2 * a[o++]),
        Qs(3, 4, 9, 14, t, n + 2 * a[o++]),
        Xs(3, 4, 9, 14, t, n + 2 * a[o++])
    ;(this.v0l ^= pe[0] ^ pe[16]),
      (this.v0h ^= pe[1] ^ pe[17]),
      (this.v1l ^= pe[2] ^ pe[18]),
      (this.v1h ^= pe[3] ^ pe[19]),
      (this.v2l ^= pe[4] ^ pe[20]),
      (this.v2h ^= pe[5] ^ pe[21]),
      (this.v3l ^= pe[6] ^ pe[22]),
      (this.v3h ^= pe[7] ^ pe[23]),
      (this.v4l ^= pe[8] ^ pe[24]),
      (this.v4h ^= pe[9] ^ pe[25]),
      (this.v5l ^= pe[10] ^ pe[26]),
      (this.v5h ^= pe[11] ^ pe[27]),
      (this.v6l ^= pe[12] ^ pe[28]),
      (this.v6h ^= pe[13] ^ pe[29]),
      (this.v7l ^= pe[14] ^ pe[30]),
      (this.v7h ^= pe[15] ^ pe[31]),
      pe.fill(0)
  }
  destroy() {
    ;(this.destroyed = !0),
      this.buffer32.fill(0),
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  }
}
const Gp = W9((e) => new pF(e))
function gF(e, t) {
  const n = Array.from(`${e}::`).map((i) => i.charCodeAt(0)),
    r = new Uint8Array(n.length + t.length)
  return r.set(n), r.set(t, n.length), Gp(r, { dkLen: 32 })
}
function LS(e) {
  return kt(e).replace('0x', '')
}
class Ei {
  constructor(t) {
    ;(this.version = 2),
      (this.sender = (t == null ? void 0 : t.sender) ?? null),
      (this.expiration = (t == null ? void 0 : t.expiration) ?? null),
      (this.inputs = (t == null ? void 0 : t.inputs) ?? []),
      (this.commands = (t == null ? void 0 : t.commands) ?? []),
      (this.gasData = (t == null ? void 0 : t.gasData) ?? {
        budget: null,
        price: null,
        owner: null,
        payment: null,
      })
  }
  static fromKindBytes(t) {
    const r = lt.TransactionKind.parse(t).ProgrammableTransaction
    if (!r) throw new Error('Unable to deserialize from bytes.')
    return Ei.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: { budget: null, owner: null, payment: null, price: null },
      inputs: r.inputs,
      commands: r.commands,
    })
  }
  static fromBytes(t) {
    const n = lt.TransactionData.parse(t),
      r = n == null ? void 0 : n.V1,
      i = r.kind.ProgrammableTransaction
    if (!r || !i) throw new Error('Unable to deserialize from bytes.')
    return Ei.restore({
      version: 2,
      sender: r.sender,
      expiration: r.expiration,
      gasData: r.gasData,
      inputs: i.inputs,
      commands: i.commands,
    })
  }
  static restore(t) {
    return t.version === 2 ? new Ei(Yt(Mh, t)) : new Ei(Yt(Mh, f9(t)))
  }
  static getDigestFromBytes(t) {
    const n = gF('TransactionData', t)
    return tg(n)
  }
  get gasConfig() {
    return this.gasData
  }
  set gasConfig(t) {
    this.gasData = t
  }
  build({ maxSizeBytes: t = 1 / 0, overrides: n, onlyTransactionKind: r } = {}) {
    const i = this.inputs,
      s = this.commands,
      o = { ProgrammableTransaction: { inputs: i, commands: s } }
    if (r) return lt.TransactionKind.serialize(o, { maxSize: t }).toBytes()
    const a = (n == null ? void 0 : n.expiration) ?? this.expiration,
      l = (n == null ? void 0 : n.sender) ?? this.sender,
      c = {
        ...this.gasData,
        ...(n == null ? void 0 : n.gasConfig),
        ...(n == null ? void 0 : n.gasData),
      }
    if (!l) throw new Error('Missing transaction sender')
    if (!c.budget) throw new Error('Missing gas budget')
    if (!c.payment) throw new Error('Missing gas payment')
    if (!c.price) throw new Error('Missing gas price')
    const u = {
      sender: LS(l),
      expiration: a || { None: !0 },
      gasData: {
        payment: c.payment,
        owner: LS(this.gasData.owner ?? l),
        price: BigInt(c.price),
        budget: BigInt(c.budget),
      },
      kind: { ProgrammableTransaction: { inputs: i, commands: s } },
    }
    return lt.TransactionData.serialize({ V1: u }, { maxSize: t }).toBytes()
  }
  addInput(t, n) {
    const r = this.inputs.length
    return this.inputs.push(n), { Input: r, type: t, $kind: 'Input' }
  }
  getInputUses(t, n) {
    this.mapArguments((r, i) => (r.$kind === 'Input' && r.Input === t && n(r, i), r))
  }
  mapArguments(t) {
    for (const n of this.commands)
      switch (n.$kind) {
        case 'MoveCall':
          n.MoveCall.arguments = n.MoveCall.arguments.map((i) => t(i, n))
          break
        case 'TransferObjects':
          ;(n.TransferObjects.objects = n.TransferObjects.objects.map((i) => t(i, n))),
            (n.TransferObjects.address = t(n.TransferObjects.address, n))
          break
        case 'SplitCoins':
          ;(n.SplitCoins.coin = t(n.SplitCoins.coin, n)),
            (n.SplitCoins.amounts = n.SplitCoins.amounts.map((i) => t(i, n)))
          break
        case 'MergeCoins':
          ;(n.MergeCoins.destination = t(n.MergeCoins.destination, n)),
            (n.MergeCoins.sources = n.MergeCoins.sources.map((i) => t(i, n)))
          break
        case 'MakeMoveVec':
          n.MakeMoveVec.elements = n.MakeMoveVec.elements.map((i) => t(i, n))
          break
        case 'Upgrade':
          n.Upgrade.ticket = t(n.Upgrade.ticket, n)
          break
        case '$Intent':
          const r = n.$Intent.inputs
          n.$Intent.inputs = {}
          for (const [i, s] of Object.entries(r))
            n.$Intent.inputs[i] = Array.isArray(s) ? s.map((o) => t(o, n)) : t(s, n)
          break
        case 'Publish':
          break
        default:
          throw new Error(`Unexpected transaction kind: ${n.$kind}`)
      }
  }
  replaceCommand(t, n) {
    if (!Array.isArray(n)) {
      this.commands[t] = n
      return
    }
    const r = n.length - 1
    this.commands.splice(t, 1, ...n),
      r !== 0 &&
        this.mapArguments((i) => {
          switch (i.$kind) {
            case 'Result':
              i.Result > t && (i.Result += r)
              break
            case 'NestedResult':
              i.NestedResult[0] > t && (i.NestedResult[0] += r)
              break
          }
          return i
        })
  }
  getDigest() {
    const t = this.build({ onlyTransactionKind: !1 })
    return Ei.getDigestFromBytes(t)
  }
  snapshot() {
    return Yt(Mh, this)
  }
}
function $S(e) {
  if (typeof e == 'string') return kt(e)
  if (e.Object)
    return e.Object.ImmOrOwnedObject
      ? kt(e.Object.ImmOrOwnedObject.objectId)
      : e.Object.Receiving
      ? kt(e.Object.Receiving.objectId)
      : kt(e.Object.SharedObject.objectId)
  if (e.UnresolvedObject) return kt(e.UnresolvedObject.objectId)
}
var Gw = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  vt = (e, t, n) => (Gw(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  Zs = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  fu = (e, t, n, r) => (Gw(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  vs = (e, t, n) => (Gw(e, t, 'access private method'), n),
  Lh,
  Yp,
  ia,
  Ct,
  Su,
  $h,
  Qp,
  Yw,
  Fh,
  Cv,
  Xp,
  Qw
function mF(e) {
  const t = { $kind: 'Result', Result: e },
    n = [],
    r = (i) => n[i] ?? (n[i] = { $kind: 'NestedResult', NestedResult: [e, i] })
  return new Proxy(t, {
    set() {
      throw new Error(
        'The transaction result is a proxy, and does not support setting properties directly'
      )
    },
    get(i, s) {
      if (s in i) return Reflect.get(i, s)
      if (s === Symbol.iterator)
        return function* () {
          let a = 0
          for (;;) yield r(a), a++
        }
      if (typeof s == 'symbol') return
      const o = parseInt(s, 10)
      if (!(Number.isNaN(o) || o < 0)) return r(o)
    },
  })
}
const R6 = Symbol.for('@mysten/transaction')
function P6(e) {
  return !!e && typeof e == 'object' && e[R6] === !0
}
const _v = class {
  constructor() {
    Zs(this, Su),
      Zs(this, Qp),
      Zs(this, Fh),
      Zs(this, Xp),
      Zs(this, Lh, []),
      Zs(this, Yp, []),
      Zs(this, ia, new Map()),
      Zs(this, Ct, void 0),
      fu(this, Ct, new Ei())
  }
  static fromKind(e) {
    const t = new _v()
    return fu(t, Ct, Ei.fromKindBytes(typeof e == 'string' ? Gn(e) : e)), t
  }
  static from(e) {
    const t = new _v()
    return (
      P6(e)
        ? fu(t, Ct, new Ei(e.getData()))
        : typeof e != 'string' || !e.startsWith('{')
        ? fu(t, Ct, Ei.fromBytes(typeof e == 'string' ? Gn(e) : e))
        : fu(t, Ct, Ei.restore(JSON.parse(e))),
      t
    )
  }
  addSerializationPlugin(e) {
    vt(this, Lh).push(e)
  }
  addBuildPlugin(e) {
    vt(this, Yp).push(e)
  }
  addIntentResolver(e, t) {
    if (vt(this, ia).has(e) && vt(this, ia).get(e) !== t)
      throw new Error(`Intent resolver for ${e} already exists`)
    vt(this, ia).set(e, t)
  }
  setSender(e) {
    vt(this, Ct).sender = e
  }
  setSenderIfNotSet(e) {
    vt(this, Ct).sender || (vt(this, Ct).sender = e)
  }
  setExpiration(e) {
    vt(this, Ct).expiration = e ? Yt(_6, e) : null
  }
  setGasPrice(e) {
    vt(this, Ct).gasConfig.price = String(e)
  }
  setGasBudget(e) {
    vt(this, Ct).gasConfig.budget = String(e)
  }
  setGasOwner(e) {
    vt(this, Ct).gasConfig.owner = e
  }
  setGasPayment(e) {
    vt(this, Ct).gasConfig.payment = e.map((t) => Yt(Fo, t))
  }
  get blockData() {
    return NS(vt(this, Ct).snapshot())
  }
  getData() {
    return vt(this, Ct).snapshot()
  }
  get [R6]() {
    return !0
  }
  get pure() {
    return (
      Object.defineProperty(this, 'pure', {
        enumerable: !1,
        value: N9((e) =>
          HO(e)
            ? vt(this, Ct).addInput('pure', { $kind: 'Pure', Pure: { bytes: e.toBase64() } })
            : vt(this, Ct).addInput(
                'pure',
                xv(PS, e)
                  ? Yt(PS, e)
                  : e instanceof Uint8Array
                  ? Ts.Pure(e)
                  : { $kind: 'UnresolvedPure', UnresolvedPure: { value: e } }
              )
        ),
      }),
      this.pure
    )
  }
  get gas() {
    return { $kind: 'GasCoin', GasCoin: !0 }
  }
  object(e) {
    var r, i
    if (typeof e == 'function') return this.object(e(this))
    if (typeof e == 'object' && xv(Mt, e)) return e
    const t = $S(e),
      n = vt(this, Ct).inputs.find((s) => t === $S(s))
    return (
      (r = n == null ? void 0 : n.Object) != null &&
        r.SharedObject &&
        typeof e == 'object' &&
        (i = e.Object) != null &&
        i.SharedObject &&
        (n.Object.SharedObject.mutable =
          n.Object.SharedObject.mutable || e.Object.SharedObject.mutable),
      n
        ? { $kind: 'Input', Input: vt(this, Ct).inputs.indexOf(n), type: 'object' }
        : vt(this, Ct).addInput(
            'object',
            typeof e == 'string'
              ? { $kind: 'UnresolvedObject', UnresolvedObject: { objectId: kt(e) } }
              : e
          )
    )
  }
  objectRef(...e) {
    return this.object(Ts.ObjectRef(...e))
  }
  receivingRef(...e) {
    return this.object(Ts.ReceivingRef(...e))
  }
  sharedObjectRef(...e) {
    return this.object(Ts.SharedObjectRef(...e))
  }
  add(e) {
    if (typeof e == 'function') return e(this)
    const t = vt(this, Ct).commands.push(e)
    return mF(t - 1)
  }
  splitCoins(e, t) {
    return this.add(
      Zo.SplitCoins(
        typeof e == 'string' ? this.object(e) : vs(this, Qp, Yw).call(this, e),
        t.map((n) =>
          typeof n == 'number' || typeof n == 'bigint' || typeof n == 'string'
            ? this.pure.u64(n)
            : vs(this, Su, $h).call(this, n)
        )
      )
    )
  }
  mergeCoins(e, t) {
    return this.add(
      Zo.MergeCoins(
        this.object(e),
        t.map((n) => this.object(n))
      )
    )
  }
  publish({ modules: e, dependencies: t }) {
    return this.add(Zo.Publish({ modules: e, dependencies: t }))
  }
  upgrade({ modules: e, dependencies: t, package: n, ticket: r }) {
    return this.add(Zo.Upgrade({ modules: e, dependencies: t, package: n, ticket: this.object(r) }))
  }
  moveCall({ arguments: e, ...t }) {
    return this.add(
      Zo.MoveCall({
        ...t,
        arguments: e == null ? void 0 : e.map((n) => vs(this, Su, $h).call(this, n)),
      })
    )
  }
  transferObjects(e, t) {
    return this.add(
      Zo.TransferObjects(
        e.map((n) => this.object(n)),
        typeof t == 'string' ? this.pure.address(t) : vs(this, Su, $h).call(this, t)
      )
    )
  }
  makeMoveVec({ type: e, elements: t }) {
    return this.add(Zo.MakeMoveVec({ type: e, elements: t.map((n) => this.object(n)) }))
  }
  serialize() {
    return JSON.stringify(NS(vt(this, Ct).snapshot()))
  }
  async toJSON(e = {}) {
    return (
      await this.prepareForSerialization(e),
      JSON.stringify(
        Yt(w9, vt(this, Ct).snapshot()),
        (t, n) => (typeof n == 'bigint' ? n.toString() : n),
        2
      )
    )
  }
  async sign(e) {
    const { signer: t, ...n } = e,
      r = await this.build(n)
    return t.signTransaction(r)
  }
  async build(e = {}) {
    return (
      await this.prepareForSerialization(e),
      await vs(this, Fh, Cv).call(this, e),
      vt(this, Ct).build({ onlyTransactionKind: e.onlyTransactionKind })
    )
  }
  async getDigest(e = {}) {
    return await vs(this, Fh, Cv).call(this, e), vt(this, Ct).getDigest()
  }
  async prepareForSerialization(e) {
    var r
    const t = new Set()
    for (const i of vt(this, Ct).commands) i.$Intent && e.supportedIntents && t.add(i.$Intent.name)
    const n = [...vt(this, Lh)]
    for (const i of t)
      if (!((r = e.supportedIntents) != null && r.includes(i))) {
        if (!vt(this, ia).has(i)) throw new Error(`Missing intent resolver for ${i}`)
        n.push(vt(this, ia).get(i))
      }
    await vs(this, Xp, Qw).call(this, n, e)
  }
}
let Ov = _v
Lh = new WeakMap()
Yp = new WeakMap()
ia = new WeakMap()
Ct = new WeakMap()
Su = new WeakSet()
$h = function (e) {
  return HO(e) ? this.pure(e) : vs(this, Qp, Yw).call(this, e)
}
Qp = new WeakSet()
Yw = function (e) {
  return typeof e == 'function' ? Yt(Mt, e(this)) : Yt(Mt, e)
}
Fh = new WeakSet()
Cv = async function (e) {
  if (!e.onlyTransactionKind && !vt(this, Ct).sender) throw new Error('Missing transaction sender')
  await vs(this, Xp, Qw).call(this, [...vt(this, Yp), E9], e)
}
Xp = new WeakSet()
Qw = async function (e, t) {
  const n = (r) => {
    if (r >= e.length) return () => {}
    const i = e[r]
    return async () => {
      const s = n(r + 1)
      let o = !1,
        a = !1
      if (
        (await i(vt(this, Ct), t, async () => {
          if (o) throw new Error(`next() was call multiple times in TransactionPlugin ${r}`)
          ;(o = !0), await s(), (a = !0)
        }),
        !o)
      )
        throw new Error(`next() was not called in TransactionPlugin ${r}`)
      if (!a) throw new Error(`next() was not awaited in TransactionPlugin ${r}`)
    }
  }
  await n(0)()
}
const yF = ['standard:connect', 'standard:events']
function vF(e, t = []) {
  return [...yF, ...t].every((n) => n in e.features)
}
const wF = 'sui:devnet',
  bF = 'sui:testnet',
  xF = 'sui:localnet',
  Xw = 'sui:mainnet',
  SF = [wF, bF, xF, Xw]
function EF(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || 'default')
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function CF(e) {
  var t = EF(e, 'string')
  return typeof t == 'symbol' ? t : String(t)
}
function _F(e, t, n) {
  return (
    (t = CF(t)),
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function FS(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function BS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? FS(Object(n), !0).forEach(function (r) {
          _F(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : FS(Object(n)).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
  }
  return e
}
function US(e, t) {
  var n = {}
  for (var r in e) n[r] = t(e[r], r)
  return n
}
var OF = (e, t, n) => {
    for (var r of Object.keys(e)) {
      var i
      if (e[r] !== ((i = t[r]) !== null && i !== void 0 ? i : n[r])) return !1
    }
    return !0
  },
  Zw = (e) => {
    var t = (n) => {
      var r = e.defaultClassName,
        i = BS(BS({}, e.defaultVariants), n)
      for (var s in i) {
        var o,
          a = (o = i[s]) !== null && o !== void 0 ? o : e.defaultVariants[s]
        if (a != null) {
          var l = a
          typeof l == 'boolean' && (l = l === !0 ? 'true' : 'false')
          var c = e.variantClassNames[s][l]
          c && (r += ' ' + c)
        }
      }
      for (var [u, f] of e.compoundVariants) OF(u, i, e.defaultVariants) && (r += ' ' + f)
      return r
    }
    return (
      (t.variants = () => Object.keys(e.variantClassNames)),
      (t.classNames = {
        get base() {
          return e.defaultClassName.split(' ')[0]
        },
        get variants() {
          return US(e.variantClassNames, (n) => US(n, (r) => r.split(' ')[0]))
        },
      }),
      t
    )
  }
function I6(e) {
  const t = e + 'CollectionProvider',
    [n, r] = Fc(t),
    [i, s] = n(t, { collectionRef: { current: null }, itemMap: new Map() }),
    o = (p) => {
      const { scope: h, children: m } = p,
        b = fn.useRef(null),
        y = fn.useRef(new Map()).current
      return fn.createElement(i, { scope: h, itemMap: y, collectionRef: b }, m)
    },
    a = e + 'CollectionSlot',
    l = fn.forwardRef((p, h) => {
      const { scope: m, children: b } = p,
        y = s(a, m),
        v = Qn(h, y.collectionRef)
      return fn.createElement(Ii, { ref: v }, b)
    }),
    c = e + 'CollectionItemSlot',
    u = 'data-radix-collection-item',
    f = fn.forwardRef((p, h) => {
      const { scope: m, children: b, ...y } = p,
        v = fn.useRef(null),
        S = Qn(h, v),
        T = s(c, m)
      return (
        fn.useEffect(() => (T.itemMap.set(v, { ref: v, ...y }), () => void T.itemMap.delete(v))),
        fn.createElement(Ii, { [u]: '', ref: S }, b)
      )
    })
  function d(p) {
    const h = s(e + 'CollectionConsumer', p)
    return fn.useCallback(() => {
      const b = h.collectionRef.current
      if (!b) return []
      const y = Array.from(b.querySelectorAll(`[${u}]`))
      return Array.from(h.itemMap.values()).sort(
        (T, A) => y.indexOf(T.ref.current) - y.indexOf(A.ref.current)
      )
    }, [h.collectionRef, h.itemMap])
  }
  return [{ Provider: o, Slot: l, ItemSlot: f }, d, r]
}
const kF = w.createContext(void 0)
function D6(e) {
  const t = w.useContext(kF)
  return e || t || 'ltr'
}
const TF = ['top', 'right', 'bottom', 'left'],
  Zi = Math.min,
  wr = Math.max,
  Zp = Math.round,
  Ud = Math.floor,
  Bo = (e) => ({ x: e, y: e }),
  AF = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' },
  RF = { start: 'end', end: 'start' }
function kv(e, t, n) {
  return wr(e, Zi(t, n))
}
function js(e, t) {
  return typeof e == 'function' ? e(t) : e
}
function Ls(e) {
  return e.split('-')[0]
}
function Wc(e) {
  return e.split('-')[1]
}
function Jw(e) {
  return e === 'x' ? 'y' : 'x'
}
function eb(e) {
  return e === 'y' ? 'height' : 'width'
}
function Vc(e) {
  return ['top', 'bottom'].includes(Ls(e)) ? 'y' : 'x'
}
function tb(e) {
  return Jw(Vc(e))
}
function PF(e, t, n) {
  n === void 0 && (n = !1)
  const r = Wc(e),
    i = tb(e),
    s = eb(i)
  let o =
    i === 'x' ? (r === (n ? 'end' : 'start') ? 'right' : 'left') : r === 'start' ? 'bottom' : 'top'
  return t.reference[s] > t.floating[s] && (o = Jp(o)), [o, Jp(o)]
}
function IF(e) {
  const t = Jp(e)
  return [Tv(e), t, Tv(t)]
}
function Tv(e) {
  return e.replace(/start|end/g, (t) => RF[t])
}
function DF(e, t, n) {
  const r = ['left', 'right'],
    i = ['right', 'left'],
    s = ['top', 'bottom'],
    o = ['bottom', 'top']
  switch (e) {
    case 'top':
    case 'bottom':
      return n ? (t ? i : r) : t ? r : i
    case 'left':
    case 'right':
      return t ? s : o
    default:
      return []
  }
}
function NF(e, t, n, r) {
  const i = Wc(e)
  let s = DF(Ls(e), n === 'start', r)
  return i && ((s = s.map((o) => o + '-' + i)), t && (s = s.concat(s.map(Tv)))), s
}
function Jp(e) {
  return e.replace(/left|right|bottom|top/g, (t) => AF[t])
}
function MF(e) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e }
}
function N6(e) {
  return typeof e != 'number' ? MF(e) : { top: e, right: e, bottom: e, left: e }
}
function e0(e) {
  const { x: t, y: n, width: r, height: i } = e
  return { width: r, height: i, top: n, left: t, right: t + r, bottom: n + i, x: t, y: n }
}
function zS(e, t, n) {
  let { reference: r, floating: i } = e
  const s = Vc(t),
    o = tb(t),
    a = eb(o),
    l = Ls(t),
    c = s === 'y',
    u = r.x + r.width / 2 - i.width / 2,
    f = r.y + r.height / 2 - i.height / 2,
    d = r[a] / 2 - i[a] / 2
  let p
  switch (l) {
    case 'top':
      p = { x: u, y: r.y - i.height }
      break
    case 'bottom':
      p = { x: u, y: r.y + r.height }
      break
    case 'right':
      p = { x: r.x + r.width, y: f }
      break
    case 'left':
      p = { x: r.x - i.width, y: f }
      break
    default:
      p = { x: r.x, y: r.y }
  }
  switch (Wc(t)) {
    case 'start':
      p[o] -= d * (n && c ? -1 : 1)
      break
    case 'end':
      p[o] += d * (n && c ? -1 : 1)
      break
  }
  return p
}
const jF = async (e, t, n) => {
  const { placement: r = 'bottom', strategy: i = 'absolute', middleware: s = [], platform: o } = n,
    a = s.filter(Boolean),
    l = await (o.isRTL == null ? void 0 : o.isRTL(t))
  let c = await o.getElementRects({ reference: e, floating: t, strategy: i }),
    { x: u, y: f } = zS(c, r, l),
    d = r,
    p = {},
    h = 0
  for (let m = 0; m < a.length; m++) {
    const { name: b, fn: y } = a[m],
      {
        x: v,
        y: S,
        data: T,
        reset: A,
      } = await y({
        x: u,
        y: f,
        initialPlacement: r,
        placement: d,
        strategy: i,
        middlewareData: p,
        rects: c,
        platform: o,
        elements: { reference: e, floating: t },
      })
    ;(u = v ?? u),
      (f = S ?? f),
      (p = { ...p, [b]: { ...p[b], ...T } }),
      A &&
        h <= 50 &&
        (h++,
        typeof A == 'object' &&
          (A.placement && (d = A.placement),
          A.rects &&
            (c =
              A.rects === !0
                ? await o.getElementRects({ reference: e, floating: t, strategy: i })
                : A.rects),
          ({ x: u, y: f } = zS(c, d, l))),
        (m = -1))
  }
  return { x: u, y: f, placement: d, strategy: i, middlewareData: p }
}
async function xf(e, t) {
  var n
  t === void 0 && (t = {})
  const { x: r, y: i, platform: s, rects: o, elements: a, strategy: l } = e,
    {
      boundary: c = 'clippingAncestors',
      rootBoundary: u = 'viewport',
      elementContext: f = 'floating',
      altBoundary: d = !1,
      padding: p = 0,
    } = js(t, e),
    h = N6(p),
    b = a[d ? (f === 'floating' ? 'reference' : 'floating') : f],
    y = e0(
      await s.getClippingRect({
        element:
          (n = await (s.isElement == null ? void 0 : s.isElement(b))) == null || n
            ? b
            : b.contextElement ||
              (await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating))),
        boundary: c,
        rootBoundary: u,
        strategy: l,
      })
    ),
    v =
      f === 'floating'
        ? { x: r, y: i, width: o.floating.width, height: o.floating.height }
        : o.reference,
    S = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)),
    T = (await (s.isElement == null ? void 0 : s.isElement(S)))
      ? (await (s.getScale == null ? void 0 : s.getScale(S))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    A = e0(
      s.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: a,
            rect: v,
            offsetParent: S,
            strategy: l,
          })
        : v
    )
  return {
    top: (y.top - A.top + h.top) / T.y,
    bottom: (A.bottom - y.bottom + h.bottom) / T.y,
    left: (y.left - A.left + h.left) / T.x,
    right: (A.right - y.right + h.right) / T.x,
  }
}
const LF = (e) => ({
    name: 'arrow',
    options: e,
    async fn(t) {
      const { x: n, y: r, placement: i, rects: s, platform: o, elements: a, middlewareData: l } = t,
        { element: c, padding: u = 0 } = js(e, t) || {}
      if (c == null) return {}
      const f = N6(u),
        d = { x: n, y: r },
        p = tb(i),
        h = eb(p),
        m = await o.getDimensions(c),
        b = p === 'y',
        y = b ? 'top' : 'left',
        v = b ? 'bottom' : 'right',
        S = b ? 'clientHeight' : 'clientWidth',
        T = s.reference[h] + s.reference[p] - d[p] - s.floating[h],
        A = d[p] - s.reference[p],
        I = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c))
      let k = I ? I[S] : 0
      ;(!k || !(await (o.isElement == null ? void 0 : o.isElement(I)))) &&
        (k = a.floating[S] || s.floating[h])
      const D = T / 2 - A / 2,
        F = k / 2 - m[h] / 2 - 1,
        V = Zi(f[y], F),
        ie = Zi(f[v], F),
        de = V,
        xe = k - m[h] - ie,
        we = k / 2 - m[h] / 2 + D,
        Pe = kv(de, we, xe),
        We =
          !l.arrow &&
          Wc(i) != null &&
          we !== Pe &&
          s.reference[h] / 2 - (we < de ? V : ie) - m[h] / 2 < 0,
        Me = We ? (we < de ? we - de : we - xe) : 0
      return {
        [p]: d[p] + Me,
        data: { [p]: Pe, centerOffset: we - Pe - Me, ...(We && { alignmentOffset: Me }) },
        reset: We,
      }
    },
  }),
  $F = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'flip',
        options: e,
        async fn(t) {
          var n, r
          const {
              placement: i,
              middlewareData: s,
              rects: o,
              initialPlacement: a,
              platform: l,
              elements: c,
            } = t,
            {
              mainAxis: u = !0,
              crossAxis: f = !0,
              fallbackPlacements: d,
              fallbackStrategy: p = 'bestFit',
              fallbackAxisSideDirection: h = 'none',
              flipAlignment: m = !0,
              ...b
            } = js(e, t)
          if ((n = s.arrow) != null && n.alignmentOffset) return {}
          const y = Ls(i),
            v = Ls(a) === a,
            S = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
            T = d || (v || !m ? [Jp(a)] : IF(a))
          !d && h !== 'none' && T.push(...NF(a, m, h, S))
          const A = [a, ...T],
            I = await xf(t, b),
            k = []
          let D = ((r = s.flip) == null ? void 0 : r.overflows) || []
          if ((u && k.push(I[y]), f)) {
            const de = PF(i, o, S)
            k.push(I[de[0]], I[de[1]])
          }
          if (((D = [...D, { placement: i, overflows: k }]), !k.every((de) => de <= 0))) {
            var F, V
            const de = (((F = s.flip) == null ? void 0 : F.index) || 0) + 1,
              xe = A[de]
            if (xe) return { data: { index: de, overflows: D }, reset: { placement: xe } }
            let we =
              (V = D.filter((Pe) => Pe.overflows[0] <= 0).sort(
                (Pe, We) => Pe.overflows[1] - We.overflows[1]
              )[0]) == null
                ? void 0
                : V.placement
            if (!we)
              switch (p) {
                case 'bestFit': {
                  var ie
                  const Pe =
                    (ie = D.map((We) => [
                      We.placement,
                      We.overflows.filter((Me) => Me > 0).reduce((Me, K) => Me + K, 0),
                    ]).sort((We, Me) => We[1] - Me[1])[0]) == null
                      ? void 0
                      : ie[0]
                  Pe && (we = Pe)
                  break
                }
                case 'initialPlacement':
                  we = a
                  break
              }
            if (i !== we) return { reset: { placement: we } }
          }
          return {}
        },
      }
    )
  }
function WS(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width,
  }
}
function VS(e) {
  return TF.some((t) => e[t] >= 0)
}
const FF = function (e) {
  return (
    e === void 0 && (e = {}),
    {
      name: 'hide',
      options: e,
      async fn(t) {
        const { rects: n } = t,
          { strategy: r = 'referenceHidden', ...i } = js(e, t)
        switch (r) {
          case 'referenceHidden': {
            const s = await xf(t, { ...i, elementContext: 'reference' }),
              o = WS(s, n.reference)
            return { data: { referenceHiddenOffsets: o, referenceHidden: VS(o) } }
          }
          case 'escaped': {
            const s = await xf(t, { ...i, altBoundary: !0 }),
              o = WS(s, n.floating)
            return { data: { escapedOffsets: o, escaped: VS(o) } }
          }
          default:
            return {}
        }
      },
    }
  )
}
async function BF(e, t) {
  const { placement: n, platform: r, elements: i } = e,
    s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)),
    o = Ls(n),
    a = Wc(n),
    l = Vc(n) === 'y',
    c = ['left', 'top'].includes(o) ? -1 : 1,
    u = s && l ? -1 : 1,
    f = js(t, e)
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: h,
  } = typeof f == 'number'
    ? { mainAxis: f, crossAxis: 0, alignmentAxis: null }
    : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...f }
  return (
    a && typeof h == 'number' && (p = a === 'end' ? h * -1 : h),
    l ? { x: p * u, y: d * c } : { x: d * c, y: p * u }
  )
}
const UF = function (e) {
    return (
      e === void 0 && (e = 0),
      {
        name: 'offset',
        options: e,
        async fn(t) {
          var n, r
          const { x: i, y: s, placement: o, middlewareData: a } = t,
            l = await BF(t, e)
          return o === ((n = a.offset) == null ? void 0 : n.placement) &&
            (r = a.arrow) != null &&
            r.alignmentOffset
            ? {}
            : { x: i + l.x, y: s + l.y, data: { ...l, placement: o } }
        },
      }
    )
  },
  zF = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'shift',
        options: e,
        async fn(t) {
          const { x: n, y: r, placement: i } = t,
            {
              mainAxis: s = !0,
              crossAxis: o = !1,
              limiter: a = {
                fn: (b) => {
                  let { x: y, y: v } = b
                  return { x: y, y: v }
                },
              },
              ...l
            } = js(e, t),
            c = { x: n, y: r },
            u = await xf(t, l),
            f = Vc(Ls(i)),
            d = Jw(f)
          let p = c[d],
            h = c[f]
          if (s) {
            const b = d === 'y' ? 'top' : 'left',
              y = d === 'y' ? 'bottom' : 'right',
              v = p + u[b],
              S = p - u[y]
            p = kv(v, p, S)
          }
          if (o) {
            const b = f === 'y' ? 'top' : 'left',
              y = f === 'y' ? 'bottom' : 'right',
              v = h + u[b],
              S = h - u[y]
            h = kv(v, h, S)
          }
          const m = a.fn({ ...t, [d]: p, [f]: h })
          return { ...m, data: { x: m.x - n, y: m.y - r } }
        },
      }
    )
  },
  WF = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        options: e,
        fn(t) {
          const { x: n, y: r, placement: i, rects: s, middlewareData: o } = t,
            { offset: a = 0, mainAxis: l = !0, crossAxis: c = !0 } = js(e, t),
            u = { x: n, y: r },
            f = Vc(i),
            d = Jw(f)
          let p = u[d],
            h = u[f]
          const m = js(a, t),
            b =
              typeof m == 'number'
                ? { mainAxis: m, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...m }
          if (l) {
            const S = d === 'y' ? 'height' : 'width',
              T = s.reference[d] - s.floating[S] + b.mainAxis,
              A = s.reference[d] + s.reference[S] - b.mainAxis
            p < T ? (p = T) : p > A && (p = A)
          }
          if (c) {
            var y, v
            const S = d === 'y' ? 'width' : 'height',
              T = ['top', 'left'].includes(Ls(i)),
              A =
                s.reference[f] -
                s.floating[S] +
                ((T && ((y = o.offset) == null ? void 0 : y[f])) || 0) +
                (T ? 0 : b.crossAxis),
              I =
                s.reference[f] +
                s.reference[S] +
                (T ? 0 : ((v = o.offset) == null ? void 0 : v[f]) || 0) -
                (T ? b.crossAxis : 0)
            h < A ? (h = A) : h > I && (h = I)
          }
          return { [d]: p, [f]: h }
        },
      }
    )
  },
  VF = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'size',
        options: e,
        async fn(t) {
          const { placement: n, rects: r, platform: i, elements: s } = t,
            { apply: o = () => {}, ...a } = js(e, t),
            l = await xf(t, a),
            c = Ls(n),
            u = Wc(n),
            f = Vc(n) === 'y',
            { width: d, height: p } = r.floating
          let h, m
          c === 'top' || c === 'bottom'
            ? ((h = c),
              (m =
                u === ((await (i.isRTL == null ? void 0 : i.isRTL(s.floating))) ? 'start' : 'end')
                  ? 'left'
                  : 'right'))
            : ((m = c), (h = u === 'end' ? 'top' : 'bottom'))
          const b = p - l.top - l.bottom,
            y = d - l.left - l.right,
            v = Zi(p - l[h], b),
            S = Zi(d - l[m], y),
            T = !t.middlewareData.shift
          let A = v,
            I = S
          if ((f ? (I = u || T ? Zi(S, y) : y) : (A = u || T ? Zi(v, b) : b), T && !u)) {
            const D = wr(l.left, 0),
              F = wr(l.right, 0),
              V = wr(l.top, 0),
              ie = wr(l.bottom, 0)
            f
              ? (I = d - 2 * (D !== 0 || F !== 0 ? D + F : wr(l.left, l.right)))
              : (A = p - 2 * (V !== 0 || ie !== 0 ? V + ie : wr(l.top, l.bottom)))
          }
          await o({ ...t, availableWidth: I, availableHeight: A })
          const k = await i.getDimensions(s.floating)
          return d !== k.width || p !== k.height ? { reset: { rects: !0 } } : {}
        },
      }
    )
  }
function Hc(e) {
  return M6(e) ? (e.nodeName || '').toLowerCase() : '#document'
}
function _r(e) {
  var t
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}
function Ws(e) {
  var t
  return (t = (M6(e) ? e.ownerDocument : e.document) || window.document) == null
    ? void 0
    : t.documentElement
}
function M6(e) {
  return e instanceof Node || e instanceof _r(e).Node
}
function rs(e) {
  return e instanceof Element || e instanceof _r(e).Element
}
function is(e) {
  return e instanceof HTMLElement || e instanceof _r(e).HTMLElement
}
function HS(e) {
  return typeof ShadowRoot > 'u' ? !1 : e instanceof ShadowRoot || e instanceof _r(e).ShadowRoot
}
function rd(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: i } = Ni(e)
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !['inline', 'contents'].includes(i)
}
function HF(e) {
  return ['table', 'td', 'th'].includes(Hc(e))
}
function nb(e) {
  const t = rb(),
    n = Ni(e)
  return (
    n.transform !== 'none' ||
    n.perspective !== 'none' ||
    (n.containerType ? n.containerType !== 'normal' : !1) ||
    (!t && (n.backdropFilter ? n.backdropFilter !== 'none' : !1)) ||
    (!t && (n.filter ? n.filter !== 'none' : !1)) ||
    ['transform', 'perspective', 'filter'].some((r) => (n.willChange || '').includes(r)) ||
    ['paint', 'layout', 'strict', 'content'].some((r) => (n.contain || '').includes(r))
  )
}
function qF(e) {
  let t = Uo(e)
  for (; is(t) && !Cc(t); ) {
    if (nb(t)) return t
    t = Uo(t)
  }
  return null
}
function rb() {
  return typeof CSS > 'u' || !CSS.supports ? !1 : CSS.supports('-webkit-backdrop-filter', 'none')
}
function Cc(e) {
  return ['html', 'body', '#document'].includes(Hc(e))
}
function Ni(e) {
  return _r(e).getComputedStyle(e)
}
function sg(e) {
  return rs(e)
    ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
    : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset }
}
function Uo(e) {
  if (Hc(e) === 'html') return e
  const t = e.assignedSlot || e.parentNode || (HS(e) && e.host) || Ws(e)
  return HS(t) ? t.host : t
}
function j6(e) {
  const t = Uo(e)
  return Cc(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : is(t) && rd(t) ? t : j6(t)
}
function Sf(e, t, n) {
  var r
  t === void 0 && (t = []), n === void 0 && (n = !0)
  const i = j6(e),
    s = i === ((r = e.ownerDocument) == null ? void 0 : r.body),
    o = _r(i)
  return s
    ? t.concat(
        o,
        o.visualViewport || [],
        rd(i) ? i : [],
        o.frameElement && n ? Sf(o.frameElement) : []
      )
    : t.concat(i, Sf(i, [], n))
}
function L6(e) {
  const t = Ni(e)
  let n = parseFloat(t.width) || 0,
    r = parseFloat(t.height) || 0
  const i = is(e),
    s = i ? e.offsetWidth : n,
    o = i ? e.offsetHeight : r,
    a = Zp(n) !== s || Zp(r) !== o
  return a && ((n = s), (r = o)), { width: n, height: r, $: a }
}
function ib(e) {
  return rs(e) ? e : e.contextElement
}
function zl(e) {
  const t = ib(e)
  if (!is(t)) return Bo(1)
  const n = t.getBoundingClientRect(),
    { width: r, height: i, $: s } = L6(t)
  let o = (s ? Zp(n.width) : n.width) / r,
    a = (s ? Zp(n.height) : n.height) / i
  return (
    (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: o, y: a }
  )
}
const KF = Bo(0)
function $6(e) {
  const t = _r(e)
  return !rb() || !t.visualViewport
    ? KF
    : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop }
}
function GF(e, t, n) {
  return t === void 0 && (t = !1), !n || (t && n !== _r(e)) ? !1 : t
}
function Wa(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1)
  const i = e.getBoundingClientRect(),
    s = ib(e)
  let o = Bo(1)
  t && (r ? rs(r) && (o = zl(r)) : (o = zl(e)))
  const a = GF(s, n, r) ? $6(s) : Bo(0)
  let l = (i.left + a.x) / o.x,
    c = (i.top + a.y) / o.y,
    u = i.width / o.x,
    f = i.height / o.y
  if (s) {
    const d = _r(s),
      p = r && rs(r) ? _r(r) : r
    let h = d,
      m = h.frameElement
    for (; m && r && p !== h; ) {
      const b = zl(m),
        y = m.getBoundingClientRect(),
        v = Ni(m),
        S = y.left + (m.clientLeft + parseFloat(v.paddingLeft)) * b.x,
        T = y.top + (m.clientTop + parseFloat(v.paddingTop)) * b.y
      ;(l *= b.x),
        (c *= b.y),
        (u *= b.x),
        (f *= b.y),
        (l += S),
        (c += T),
        (h = _r(m)),
        (m = h.frameElement)
    }
  }
  return e0({ width: u, height: f, x: l, y: c })
}
const YF = [':popover-open', ':modal']
function sb(e) {
  return YF.some((t) => {
    try {
      return e.matches(t)
    } catch {
      return !1
    }
  })
}
function QF(e) {
  let { elements: t, rect: n, offsetParent: r, strategy: i } = e
  const s = i === 'fixed',
    o = Ws(r),
    a = t ? sb(t.floating) : !1
  if (r === o || (a && s)) return n
  let l = { scrollLeft: 0, scrollTop: 0 },
    c = Bo(1)
  const u = Bo(0),
    f = is(r)
  if ((f || (!f && !s)) && ((Hc(r) !== 'body' || rd(o)) && (l = sg(r)), is(r))) {
    const d = Wa(r)
    ;(c = zl(r)), (u.x = d.x + r.clientLeft), (u.y = d.y + r.clientTop)
  }
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y,
  }
}
function XF(e) {
  return Array.from(e.getClientRects())
}
function F6(e) {
  return Wa(Ws(e)).left + sg(e).scrollLeft
}
function ZF(e) {
  const t = Ws(e),
    n = sg(e),
    r = e.ownerDocument.body,
    i = wr(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
    s = wr(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight)
  let o = -n.scrollLeft + F6(e)
  const a = -n.scrollTop
  return (
    Ni(r).direction === 'rtl' && (o += wr(t.clientWidth, r.clientWidth) - i),
    { width: i, height: s, x: o, y: a }
  )
}
function JF(e, t) {
  const n = _r(e),
    r = Ws(e),
    i = n.visualViewport
  let s = r.clientWidth,
    o = r.clientHeight,
    a = 0,
    l = 0
  if (i) {
    ;(s = i.width), (o = i.height)
    const c = rb()
    ;(!c || (c && t === 'fixed')) && ((a = i.offsetLeft), (l = i.offsetTop))
  }
  return { width: s, height: o, x: a, y: l }
}
function eB(e, t) {
  const n = Wa(e, !0, t === 'fixed'),
    r = n.top + e.clientTop,
    i = n.left + e.clientLeft,
    s = is(e) ? zl(e) : Bo(1),
    o = e.clientWidth * s.x,
    a = e.clientHeight * s.y,
    l = i * s.x,
    c = r * s.y
  return { width: o, height: a, x: l, y: c }
}
function qS(e, t, n) {
  let r
  if (t === 'viewport') r = JF(e, n)
  else if (t === 'document') r = ZF(Ws(e))
  else if (rs(t)) r = eB(t, n)
  else {
    const i = $6(e)
    r = { ...t, x: t.x - i.x, y: t.y - i.y }
  }
  return e0(r)
}
function B6(e, t) {
  const n = Uo(e)
  return n === t || !rs(n) || Cc(n) ? !1 : Ni(n).position === 'fixed' || B6(n, t)
}
function tB(e, t) {
  const n = t.get(e)
  if (n) return n
  let r = Sf(e, [], !1).filter((a) => rs(a) && Hc(a) !== 'body'),
    i = null
  const s = Ni(e).position === 'fixed'
  let o = s ? Uo(e) : e
  for (; rs(o) && !Cc(o); ) {
    const a = Ni(o),
      l = nb(o)
    !l && a.position === 'fixed' && (i = null),
      (
        s
          ? !l && !i
          : (!l && a.position === 'static' && !!i && ['absolute', 'fixed'].includes(i.position)) ||
            (rd(o) && !l && B6(e, o))
      )
        ? (r = r.filter((u) => u !== o))
        : (i = a),
      (o = Uo(o))
  }
  return t.set(e, r), r
}
function nB(e) {
  let { element: t, boundary: n, rootBoundary: r, strategy: i } = e
  const o = [...(n === 'clippingAncestors' ? (sb(t) ? [] : tB(t, this._c)) : [].concat(n)), r],
    a = o[0],
    l = o.reduce((c, u) => {
      const f = qS(t, u, i)
      return (
        (c.top = wr(f.top, c.top)),
        (c.right = Zi(f.right, c.right)),
        (c.bottom = Zi(f.bottom, c.bottom)),
        (c.left = wr(f.left, c.left)),
        c
      )
    }, qS(t, a, i))
  return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top }
}
function rB(e) {
  const { width: t, height: n } = L6(e)
  return { width: t, height: n }
}
function iB(e, t, n) {
  const r = is(t),
    i = Ws(t),
    s = n === 'fixed',
    o = Wa(e, !0, s, t)
  let a = { scrollLeft: 0, scrollTop: 0 }
  const l = Bo(0)
  if (r || (!r && !s))
    if (((Hc(t) !== 'body' || rd(i)) && (a = sg(t)), r)) {
      const f = Wa(t, !0, s, t)
      ;(l.x = f.x + t.clientLeft), (l.y = f.y + t.clientTop)
    } else i && (l.x = F6(i))
  const c = o.left + a.scrollLeft - l.x,
    u = o.top + a.scrollTop - l.y
  return { x: c, y: u, width: o.width, height: o.height }
}
function Om(e) {
  return Ni(e).position === 'static'
}
function KS(e, t) {
  return !is(e) || Ni(e).position === 'fixed' ? null : t ? t(e) : e.offsetParent
}
function U6(e, t) {
  const n = _r(e)
  if (sb(e)) return n
  if (!is(e)) {
    let i = Uo(e)
    for (; i && !Cc(i); ) {
      if (rs(i) && !Om(i)) return i
      i = Uo(i)
    }
    return n
  }
  let r = KS(e, t)
  for (; r && HF(r) && Om(r); ) r = KS(r, t)
  return r && Cc(r) && Om(r) && !nb(r) ? n : r || qF(e) || n
}
const sB = async function (e) {
  const t = this.getOffsetParent || U6,
    n = this.getDimensions,
    r = await n(e.floating)
  return {
    reference: iB(e.reference, await t(e.floating), e.strategy),
    floating: { x: 0, y: 0, width: r.width, height: r.height },
  }
}
function oB(e) {
  return Ni(e).direction === 'rtl'
}
const aB = {
  convertOffsetParentRelativeRectToViewportRelativeRect: QF,
  getDocumentElement: Ws,
  getClippingRect: nB,
  getOffsetParent: U6,
  getElementRects: sB,
  getClientRects: XF,
  getDimensions: rB,
  getScale: zl,
  isElement: rs,
  isRTL: oB,
}
function lB(e, t) {
  let n = null,
    r
  const i = Ws(e)
  function s() {
    var a
    clearTimeout(r), (a = n) == null || a.disconnect(), (n = null)
  }
  function o(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), s()
    const { left: c, top: u, width: f, height: d } = e.getBoundingClientRect()
    if ((a || t(), !f || !d)) return
    const p = Ud(u),
      h = Ud(i.clientWidth - (c + f)),
      m = Ud(i.clientHeight - (u + d)),
      b = Ud(c),
      v = {
        rootMargin: -p + 'px ' + -h + 'px ' + -m + 'px ' + -b + 'px',
        threshold: wr(0, Zi(1, l)) || 1,
      }
    let S = !0
    function T(A) {
      const I = A[0].intersectionRatio
      if (I !== l) {
        if (!S) return o()
        I
          ? o(!1, I)
          : (r = setTimeout(() => {
              o(!1, 1e-7)
            }, 1e3))
      }
      S = !1
    }
    try {
      n = new IntersectionObserver(T, { ...v, root: i.ownerDocument })
    } catch {
      n = new IntersectionObserver(T, v)
    }
    n.observe(e)
  }
  return o(!0), s
}
function cB(e, t, n, r) {
  r === void 0 && (r = {})
  const {
      ancestorScroll: i = !0,
      ancestorResize: s = !0,
      elementResize: o = typeof ResizeObserver == 'function',
      layoutShift: a = typeof IntersectionObserver == 'function',
      animationFrame: l = !1,
    } = r,
    c = ib(e),
    u = i || s ? [...(c ? Sf(c) : []), ...Sf(t)] : []
  u.forEach((y) => {
    i && y.addEventListener('scroll', n, { passive: !0 }), s && y.addEventListener('resize', n)
  })
  const f = c && a ? lB(c, n) : null
  let d = -1,
    p = null
  o &&
    ((p = new ResizeObserver((y) => {
      let [v] = y
      v &&
        v.target === c &&
        p &&
        (p.unobserve(t),
        cancelAnimationFrame(d),
        (d = requestAnimationFrame(() => {
          var S
          ;(S = p) == null || S.observe(t)
        }))),
        n()
    })),
    c && !l && p.observe(c),
    p.observe(t))
  let h,
    m = l ? Wa(e) : null
  l && b()
  function b() {
    const y = Wa(e)
    m && (y.x !== m.x || y.y !== m.y || y.width !== m.width || y.height !== m.height) && n(),
      (m = y),
      (h = requestAnimationFrame(b))
  }
  return (
    n(),
    () => {
      var y
      u.forEach((v) => {
        i && v.removeEventListener('scroll', n), s && v.removeEventListener('resize', n)
      }),
        f == null || f(),
        (y = p) == null || y.disconnect(),
        (p = null),
        l && cancelAnimationFrame(h)
    }
  )
}
const uB = UF,
  fB = zF,
  dB = $F,
  hB = VF,
  pB = FF,
  GS = LF,
  gB = WF,
  mB = (e, t, n) => {
    const r = new Map(),
      i = { platform: aB, ...n },
      s = { ...i.platform, _c: r }
    return jF(e, t, { ...i, platform: s })
  }
var Bh = typeof document < 'u' ? w.useLayoutEffect : w.useEffect
function t0(e, t) {
  if (e === t) return !0
  if (typeof e != typeof t) return !1
  if (typeof e == 'function' && e.toString() === t.toString()) return !0
  let n, r, i
  if (e && t && typeof e == 'object') {
    if (Array.isArray(e)) {
      if (((n = e.length), n !== t.length)) return !1
      for (r = n; r-- !== 0; ) if (!t0(e[r], t[r])) return !1
      return !0
    }
    if (((i = Object.keys(e)), (n = i.length), n !== Object.keys(t).length)) return !1
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, i[r])) return !1
    for (r = n; r-- !== 0; ) {
      const s = i[r]
      if (!(s === '_owner' && e.$$typeof) && !t0(e[s], t[s])) return !1
    }
    return !0
  }
  return e !== e && t !== t
}
function z6(e) {
  return typeof window > 'u' ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function YS(e, t) {
  const n = z6(e)
  return Math.round(t * n) / n
}
function QS(e) {
  const t = w.useRef(e)
  return (
    Bh(() => {
      t.current = e
    }),
    t
  )
}
function yB(e) {
  e === void 0 && (e = {})
  const {
      placement: t = 'bottom',
      strategy: n = 'absolute',
      middleware: r = [],
      platform: i,
      elements: { reference: s, floating: o } = {},
      transform: a = !0,
      whileElementsMounted: l,
      open: c,
    } = e,
    [u, f] = w.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1,
    }),
    [d, p] = w.useState(r)
  t0(d, r) || p(r)
  const [h, m] = w.useState(null),
    [b, y] = w.useState(null),
    v = w.useCallback((Me) => {
      Me !== I.current && ((I.current = Me), m(Me))
    }, []),
    S = w.useCallback((Me) => {
      Me !== k.current && ((k.current = Me), y(Me))
    }, []),
    T = s || h,
    A = o || b,
    I = w.useRef(null),
    k = w.useRef(null),
    D = w.useRef(u),
    F = l != null,
    V = QS(l),
    ie = QS(i),
    de = w.useCallback(() => {
      if (!I.current || !k.current) return
      const Me = { placement: t, strategy: n, middleware: d }
      ie.current && (Me.platform = ie.current),
        mB(I.current, k.current, Me).then((K) => {
          const H = { ...K, isPositioned: !0 }
          xe.current &&
            !t0(D.current, H) &&
            ((D.current = H),
            jc.flushSync(() => {
              f(H)
            }))
        })
    }, [d, t, n, ie])
  Bh(() => {
    c === !1 &&
      D.current.isPositioned &&
      ((D.current.isPositioned = !1), f((Me) => ({ ...Me, isPositioned: !1 })))
  }, [c])
  const xe = w.useRef(!1)
  Bh(
    () => (
      (xe.current = !0),
      () => {
        xe.current = !1
      }
    ),
    []
  ),
    Bh(() => {
      if ((T && (I.current = T), A && (k.current = A), T && A)) {
        if (V.current) return V.current(T, A, de)
        de()
      }
    }, [T, A, de, V, F])
  const we = w.useMemo(
      () => ({ reference: I, floating: k, setReference: v, setFloating: S }),
      [v, S]
    ),
    Pe = w.useMemo(() => ({ reference: T, floating: A }), [T, A]),
    We = w.useMemo(() => {
      const Me = { position: n, left: 0, top: 0 }
      if (!Pe.floating) return Me
      const K = YS(Pe.floating, u.x),
        H = YS(Pe.floating, u.y)
      return a
        ? {
            ...Me,
            transform: 'translate(' + K + 'px, ' + H + 'px)',
            ...(z6(Pe.floating) >= 1.5 && { willChange: 'transform' }),
          }
        : { position: n, left: K, top: H }
    }, [n, a, Pe.floating, u.x, u.y])
  return w.useMemo(
    () => ({ ...u, update: de, refs: we, elements: Pe, floatingStyles: We }),
    [u, de, we, Pe, We]
  )
}
const vB = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, 'current')
    }
    return {
      name: 'arrow',
      options: e,
      fn(n) {
        const { element: r, padding: i } = typeof e == 'function' ? e(n) : e
        return r && t(r)
          ? r.current != null
            ? GS({ element: r.current, padding: i }).fn(n)
            : {}
          : r
          ? GS({ element: r, padding: i }).fn(n)
          : {}
      },
    }
  },
  wB = (e, t) => ({ ...uB(e), options: [e, t] }),
  bB = (e, t) => ({ ...fB(e), options: [e, t] }),
  xB = (e, t) => ({ ...gB(e), options: [e, t] }),
  SB = (e, t) => ({ ...dB(e), options: [e, t] }),
  EB = (e, t) => ({ ...hB(e), options: [e, t] }),
  CB = (e, t) => ({ ...pB(e), options: [e, t] }),
  _B = (e, t) => ({ ...vB(e), options: [e, t] })
function OB(e) {
  const [t, n] = w.useState(void 0)
  return (
    wc(() => {
      if (e) {
        n({ width: e.offsetWidth, height: e.offsetHeight })
        const r = new ResizeObserver((i) => {
          if (!Array.isArray(i) || !i.length) return
          const s = i[0]
          let o, a
          if ('borderBoxSize' in s) {
            const l = s.borderBoxSize,
              c = Array.isArray(l) ? l[0] : l
            ;(o = c.inlineSize), (a = c.blockSize)
          } else (o = e.offsetWidth), (a = e.offsetHeight)
          n({ width: o, height: a })
        })
        return r.observe(e, { box: 'border-box' }), () => r.unobserve(e)
      } else n(void 0)
    }, [e]),
    t
  )
}
const W6 = 'Popper',
  [V6, H6] = Fc(W6),
  [kB, q6] = V6(W6),
  TB = (e) => {
    const { __scopePopper: t, children: n } = e,
      [r, i] = w.useState(null)
    return w.createElement(kB, { scope: t, anchor: r, onAnchorChange: i }, n)
  },
  AB = 'PopperAnchor',
  RB = w.forwardRef((e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e,
      s = q6(AB, n),
      o = w.useRef(null),
      a = Qn(t, o)
    return (
      w.useEffect(() => {
        s.onAnchorChange((r == null ? void 0 : r.current) || o.current)
      }),
      r ? null : w.createElement(dr.div, He({}, i, { ref: a }))
    )
  }),
  K6 = 'PopperContent',
  [PB, xQ] = V6(K6),
  IB = w.forwardRef((e, t) => {
    var n, r, i, s, o, a, l, c
    const {
        __scopePopper: u,
        side: f = 'bottom',
        sideOffset: d = 0,
        align: p = 'center',
        alignOffset: h = 0,
        arrowPadding: m = 0,
        avoidCollisions: b = !0,
        collisionBoundary: y = [],
        collisionPadding: v = 0,
        sticky: S = 'partial',
        hideWhenDetached: T = !1,
        updatePositionStrategy: A = 'optimized',
        onPlaced: I,
        ...k
      } = e,
      D = q6(K6, u),
      [F, V] = w.useState(null),
      ie = Qn(t, (si) => V(si)),
      [de, xe] = w.useState(null),
      we = OB(de),
      Pe = (n = we == null ? void 0 : we.width) !== null && n !== void 0 ? n : 0,
      We = (r = we == null ? void 0 : we.height) !== null && r !== void 0 ? r : 0,
      Me = f + (p !== 'center' ? '-' + p : ''),
      K = typeof v == 'number' ? v : { top: 0, right: 0, bottom: 0, left: 0, ...v },
      H = Array.isArray(y) ? y : [y],
      oe = H.length > 0,
      Ae = { padding: K, boundary: H.filter(DB), altBoundary: oe },
      {
        refs: Ie,
        floatingStyles: fe,
        placement: _e,
        isPositioned: re,
        middlewareData: Z,
      } = yB({
        strategy: 'fixed',
        placement: Me,
        whileElementsMounted: (...si) => cB(...si, { animationFrame: A === 'always' }),
        elements: { reference: D.anchor },
        middleware: [
          wB({ mainAxis: d + We, alignmentAxis: h }),
          b && bB({ mainAxis: !0, crossAxis: !1, limiter: S === 'partial' ? xB() : void 0, ...Ae }),
          b && SB({ ...Ae }),
          EB({
            ...Ae,
            apply: ({ elements: si, rects: Tn, availableWidth: Vs, availableHeight: ls }) => {
              const { width: pr, height: Ir } = Tn.reference,
                Dr = si.floating.style
              Dr.setProperty('--radix-popper-available-width', `${Vs}px`),
                Dr.setProperty('--radix-popper-available-height', `${ls}px`),
                Dr.setProperty('--radix-popper-anchor-width', `${pr}px`),
                Dr.setProperty('--radix-popper-anchor-height', `${Ir}px`)
            },
          }),
          de && _B({ element: de, padding: m }),
          NB({ arrowWidth: Pe, arrowHeight: We }),
          T && CB({ strategy: 'referenceHidden', ...Ae }),
        ],
      }),
      [it, wt] = G6(_e),
      Ze = ns(I)
    wc(() => {
      re && (Ze == null || Ze())
    }, [re, Ze])
    const _t = (i = Z.arrow) === null || i === void 0 ? void 0 : i.x,
      gn = (s = Z.arrow) === null || s === void 0 ? void 0 : s.y,
      bt = ((o = Z.arrow) === null || o === void 0 ? void 0 : o.centerOffset) !== 0,
      [Jn, hr] = w.useState()
    return (
      wc(() => {
        F && hr(window.getComputedStyle(F).zIndex)
      }, [F]),
      w.createElement(
        'div',
        {
          ref: Ie.setFloating,
          'data-radix-popper-content-wrapper': '',
          style: {
            ...fe,
            transform: re ? fe.transform : 'translate(0, -200%)',
            minWidth: 'max-content',
            zIndex: Jn,
            '--radix-popper-transform-origin': [
              (a = Z.transformOrigin) === null || a === void 0 ? void 0 : a.x,
              (l = Z.transformOrigin) === null || l === void 0 ? void 0 : l.y,
            ].join(' '),
          },
          dir: e.dir,
        },
        w.createElement(
          PB,
          {
            scope: u,
            placedSide: it,
            onArrowChange: xe,
            arrowX: _t,
            arrowY: gn,
            shouldHideArrow: bt,
          },
          w.createElement(
            dr.div,
            He({ 'data-side': it, 'data-align': wt }, k, {
              ref: ie,
              style: {
                ...k.style,
                animation: re ? void 0 : 'none',
                opacity: (c = Z.hide) !== null && c !== void 0 && c.referenceHidden ? 0 : void 0,
              },
            })
          )
        )
      )
    )
  })
function DB(e) {
  return e !== null
}
const NB = (e) => ({
  name: 'transformOrigin',
  options: e,
  fn(t) {
    var n, r, i, s, o
    const { placement: a, rects: l, middlewareData: c } = t,
      f = ((n = c.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !== 0,
      d = f ? 0 : e.arrowWidth,
      p = f ? 0 : e.arrowHeight,
      [h, m] = G6(a),
      b = { start: '0%', center: '50%', end: '100%' }[m],
      y =
        ((r = (i = c.arrow) === null || i === void 0 ? void 0 : i.x) !== null && r !== void 0
          ? r
          : 0) +
        d / 2,
      v =
        ((s = (o = c.arrow) === null || o === void 0 ? void 0 : o.y) !== null && s !== void 0
          ? s
          : 0) +
        p / 2
    let S = '',
      T = ''
    return (
      h === 'bottom'
        ? ((S = f ? b : `${y}px`), (T = `${-p}px`))
        : h === 'top'
        ? ((S = f ? b : `${y}px`), (T = `${l.floating.height + p}px`))
        : h === 'right'
        ? ((S = `${-p}px`), (T = f ? b : `${v}px`))
        : h === 'left' && ((S = `${l.floating.width + p}px`), (T = f ? b : `${v}px`)),
      { data: { x: S, y: T } }
    )
  },
})
function G6(e) {
  const [t, n = 'center'] = e.split('-')
  return [t, n]
}
const MB = TB,
  jB = RB,
  LB = IB,
  km = 'rovingFocusGroup.onEntryFocus',
  $B = { bubbles: !1, cancelable: !0 },
  ob = 'RovingFocusGroup',
  [Av, Y6, FB] = I6(ob),
  [BB, Q6] = Fc(ob, [FB]),
  [UB, zB] = BB(ob),
  WB = w.forwardRef((e, t) =>
    w.createElement(
      Av.Provider,
      { scope: e.__scopeRovingFocusGroup },
      w.createElement(
        Av.Slot,
        { scope: e.__scopeRovingFocusGroup },
        w.createElement(VB, He({}, e, { ref: t }))
      )
    )
  ),
  VB = w.forwardRef((e, t) => {
    const {
        __scopeRovingFocusGroup: n,
        orientation: r,
        loop: i = !1,
        dir: s,
        currentTabStopId: o,
        defaultCurrentTabStopId: a,
        onCurrentTabStopIdChange: l,
        onEntryFocus: c,
        ...u
      } = e,
      f = w.useRef(null),
      d = Qn(t, f),
      p = D6(s),
      [h = null, m] = Iw({ prop: o, defaultProp: a, onChange: l }),
      [b, y] = w.useState(!1),
      v = ns(c),
      S = Y6(n),
      T = w.useRef(!1),
      [A, I] = w.useState(0)
    return (
      w.useEffect(() => {
        const k = f.current
        if (k) return k.addEventListener(km, v), () => k.removeEventListener(km, v)
      }, [v]),
      w.createElement(
        UB,
        {
          scope: n,
          orientation: r,
          dir: p,
          loop: i,
          currentTabStopId: h,
          onItemFocus: w.useCallback((k) => m(k), [m]),
          onItemShiftTab: w.useCallback(() => y(!0), []),
          onFocusableItemAdd: w.useCallback(() => I((k) => k + 1), []),
          onFocusableItemRemove: w.useCallback(() => I((k) => k - 1), []),
        },
        w.createElement(
          dr.div,
          He({ tabIndex: b || A === 0 ? -1 : 0, 'data-orientation': r }, u, {
            ref: d,
            style: { outline: 'none', ...e.style },
            onMouseDown: St(e.onMouseDown, () => {
              T.current = !0
            }),
            onFocus: St(e.onFocus, (k) => {
              const D = !T.current
              if (k.target === k.currentTarget && D && !b) {
                const F = new CustomEvent(km, $B)
                if ((k.currentTarget.dispatchEvent(F), !F.defaultPrevented)) {
                  const V = S().filter((Pe) => Pe.focusable),
                    ie = V.find((Pe) => Pe.active),
                    de = V.find((Pe) => Pe.id === h),
                    we = [ie, de, ...V].filter(Boolean).map((Pe) => Pe.ref.current)
                  X6(we)
                }
              }
              T.current = !1
            }),
            onBlur: St(e.onBlur, () => y(!1)),
          })
        )
      )
    )
  }),
  HB = 'RovingFocusGroupItem',
  qB = w.forwardRef((e, t) => {
    const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, tabStopId: s, ...o } = e,
      a = Bl(),
      l = s || a,
      c = zB(HB, n),
      u = c.currentTabStopId === l,
      f = Y6(n),
      { onFocusableItemAdd: d, onFocusableItemRemove: p } = c
    return (
      w.useEffect(() => {
        if (r) return d(), () => p()
      }, [r, d, p]),
      w.createElement(
        Av.ItemSlot,
        { scope: n, id: l, focusable: r, active: i },
        w.createElement(
          dr.span,
          He({ tabIndex: u ? 0 : -1, 'data-orientation': c.orientation }, o, {
            ref: t,
            onMouseDown: St(e.onMouseDown, (h) => {
              r ? c.onItemFocus(l) : h.preventDefault()
            }),
            onFocus: St(e.onFocus, () => c.onItemFocus(l)),
            onKeyDown: St(e.onKeyDown, (h) => {
              if (h.key === 'Tab' && h.shiftKey) {
                c.onItemShiftTab()
                return
              }
              if (h.target !== h.currentTarget) return
              const m = YB(h, c.orientation, c.dir)
              if (m !== void 0) {
                h.preventDefault()
                let y = f()
                  .filter((v) => v.focusable)
                  .map((v) => v.ref.current)
                if (m === 'last') y.reverse()
                else if (m === 'prev' || m === 'next') {
                  m === 'prev' && y.reverse()
                  const v = y.indexOf(h.currentTarget)
                  y = c.loop ? QB(y, v + 1) : y.slice(v + 1)
                }
                setTimeout(() => X6(y))
              }
            }),
          })
        )
      )
    )
  }),
  KB = {
    ArrowLeft: 'prev',
    ArrowUp: 'prev',
    ArrowRight: 'next',
    ArrowDown: 'next',
    PageUp: 'first',
    Home: 'first',
    PageDown: 'last',
    End: 'last',
  }
function GB(e, t) {
  return t !== 'rtl' ? e : e === 'ArrowLeft' ? 'ArrowRight' : e === 'ArrowRight' ? 'ArrowLeft' : e
}
function YB(e, t, n) {
  const r = GB(e.key, n)
  if (
    !(t === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(r)) &&
    !(t === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(r))
  )
    return KB[r]
}
function X6(e) {
  const t = document.activeElement
  for (const n of e) if (n === t || (n.focus(), document.activeElement !== t)) return
}
function QB(e, t) {
  return e.map((n, r) => e[(t + r) % e.length])
}
const XB = WB,
  ZB = qB,
  JB = ['Enter', ' '],
  eU = ['ArrowDown', 'PageUp', 'Home'],
  Z6 = ['ArrowUp', 'PageDown', 'End'],
  tU = [...eU, ...Z6],
  og = 'Menu',
  [Rv, nU, rU] = I6(og),
  [Qa, J6] = Fc(og, [rU, H6, Q6]),
  ab = H6(),
  ek = Q6(),
  [iU, id] = Qa(og),
  [sU, lb] = Qa(og),
  oU = (e) => {
    const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: s, modal: o = !0 } = e,
      a = ab(t),
      [l, c] = w.useState(null),
      u = w.useRef(!1),
      f = ns(s),
      d = D6(i)
    return (
      w.useEffect(() => {
        const p = () => {
            ;(u.current = !0),
              document.addEventListener('pointerdown', h, { capture: !0, once: !0 }),
              document.addEventListener('pointermove', h, { capture: !0, once: !0 })
          },
          h = () => (u.current = !1)
        return (
          document.addEventListener('keydown', p, { capture: !0 }),
          () => {
            document.removeEventListener('keydown', p, { capture: !0 }),
              document.removeEventListener('pointerdown', h, { capture: !0 }),
              document.removeEventListener('pointermove', h, { capture: !0 })
          }
        )
      }, []),
      w.createElement(
        MB,
        a,
        w.createElement(
          iU,
          { scope: t, open: n, onOpenChange: f, content: l, onContentChange: c },
          w.createElement(
            sU,
            {
              scope: t,
              onClose: w.useCallback(() => f(!1), [f]),
              isUsingKeyboardRef: u,
              dir: d,
              modal: o,
            },
            r
          )
        )
      )
    )
  },
  aU = w.forwardRef((e, t) => {
    const { __scopeMenu: n, ...r } = e,
      i = ab(n)
    return w.createElement(jB, He({}, i, r, { ref: t }))
  }),
  tk = 'MenuPortal',
  [lU, cU] = Qa(tk, { forceMount: void 0 }),
  uU = (e) => {
    const { __scopeMenu: t, forceMount: n, children: r, container: i } = e,
      s = id(tk, t)
    return w.createElement(
      lU,
      { scope: t, forceMount: n },
      w.createElement(
        Bc,
        { present: n || s.open },
        w.createElement(nO, { asChild: !0, container: i }, r)
      )
    )
  },
  jo = 'MenuContent',
  [fU, nk] = Qa(jo),
  dU = w.forwardRef((e, t) => {
    const n = cU(jo, e.__scopeMenu),
      { forceMount: r = n.forceMount, ...i } = e,
      s = id(jo, e.__scopeMenu),
      o = lb(jo, e.__scopeMenu)
    return w.createElement(
      Rv.Provider,
      { scope: e.__scopeMenu },
      w.createElement(
        Bc,
        { present: r || s.open },
        w.createElement(
          Rv.Slot,
          { scope: e.__scopeMenu },
          o.modal
            ? w.createElement(hU, He({}, i, { ref: t }))
            : w.createElement(pU, He({}, i, { ref: t }))
        )
      )
    )
  }),
  hU = w.forwardRef((e, t) => {
    const n = id(jo, e.__scopeMenu),
      r = w.useRef(null),
      i = Qn(t, r)
    return (
      w.useEffect(() => {
        const s = r.current
        if (s) return pO(s)
      }, []),
      w.createElement(
        rk,
        He({}, e, {
          ref: i,
          trapFocus: n.open,
          disableOutsidePointerEvents: n.open,
          disableOutsideScroll: !0,
          onFocusOutside: St(e.onFocusOutside, (s) => s.preventDefault(), {
            checkForDefaultPrevented: !1,
          }),
          onDismiss: () => n.onOpenChange(!1),
        })
      )
    )
  }),
  pU = w.forwardRef((e, t) => {
    const n = id(jo, e.__scopeMenu)
    return w.createElement(
      rk,
      He({}, e, {
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => n.onOpenChange(!1),
      })
    )
  }),
  rk = w.forwardRef((e, t) => {
    const {
        __scopeMenu: n,
        loop: r = !1,
        trapFocus: i,
        onOpenAutoFocus: s,
        onCloseAutoFocus: o,
        disableOutsidePointerEvents: a,
        onEntryFocus: l,
        onEscapeKeyDown: c,
        onPointerDownOutside: u,
        onFocusOutside: f,
        onInteractOutside: d,
        onDismiss: p,
        disableOutsideScroll: h,
        ...m
      } = e,
      b = id(jo, n),
      y = lb(jo, n),
      v = ab(n),
      S = ek(n),
      T = nU(n),
      [A, I] = w.useState(null),
      k = w.useRef(null),
      D = Qn(t, k, b.onContentChange),
      F = w.useRef(0),
      V = w.useRef(''),
      ie = w.useRef(0),
      de = w.useRef(null),
      xe = w.useRef('right'),
      we = w.useRef(0),
      Pe = h ? dO : w.Fragment,
      We = h ? { as: Ii, allowPinchZoom: !0 } : void 0,
      Me = (H) => {
        var oe, Ae
        const Ie = V.current + H,
          fe = T().filter((Ze) => !Ze.disabled),
          _e = document.activeElement,
          re =
            (oe = fe.find((Ze) => Ze.ref.current === _e)) === null || oe === void 0
              ? void 0
              : oe.textValue,
          Z = fe.map((Ze) => Ze.textValue),
          it = CU(Z, Ie, re),
          wt =
            (Ae = fe.find((Ze) => Ze.textValue === it)) === null || Ae === void 0
              ? void 0
              : Ae.ref.current
        ;(function Ze(_t) {
          ;(V.current = _t),
            window.clearTimeout(F.current),
            _t !== '' && (F.current = window.setTimeout(() => Ze(''), 1e3))
        })(Ie),
          wt && setTimeout(() => wt.focus())
      }
    w.useEffect(() => () => window.clearTimeout(F.current), []), rO()
    const K = w.useCallback((H) => {
      var oe, Ae
      return (
        xe.current === ((oe = de.current) === null || oe === void 0 ? void 0 : oe.side) &&
        OU(H, (Ae = de.current) === null || Ae === void 0 ? void 0 : Ae.area)
      )
    }, [])
    return w.createElement(
      fU,
      {
        scope: n,
        searchRef: V,
        onItemEnter: w.useCallback(
          (H) => {
            K(H) && H.preventDefault()
          },
          [K]
        ),
        onItemLeave: w.useCallback(
          (H) => {
            var oe
            K(H) || ((oe = k.current) === null || oe === void 0 || oe.focus(), I(null))
          },
          [K]
        ),
        onTriggerLeave: w.useCallback(
          (H) => {
            K(H) && H.preventDefault()
          },
          [K]
        ),
        pointerGraceTimerRef: ie,
        onPointerGraceIntentChange: w.useCallback((H) => {
          de.current = H
        }, []),
      },
      w.createElement(
        Pe,
        We,
        w.createElement(
          eO,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: St(s, (H) => {
              var oe
              H.preventDefault(), (oe = k.current) === null || oe === void 0 || oe.focus()
            }),
            onUnmountAutoFocus: o,
          },
          w.createElement(
            Z_,
            {
              asChild: !0,
              disableOutsidePointerEvents: a,
              onEscapeKeyDown: c,
              onPointerDownOutside: u,
              onFocusOutside: f,
              onInteractOutside: d,
              onDismiss: p,
            },
            w.createElement(
              XB,
              He({ asChild: !0 }, S, {
                dir: y.dir,
                orientation: 'vertical',
                loop: r,
                currentTabStopId: A,
                onCurrentTabStopIdChange: I,
                onEntryFocus: St(l, (H) => {
                  y.isUsingKeyboardRef.current || H.preventDefault()
                }),
              }),
              w.createElement(
                LB,
                He(
                  {
                    role: 'menu',
                    'aria-orientation': 'vertical',
                    'data-state': xU(b.open),
                    'data-radix-menu-content': '',
                    dir: y.dir,
                  },
                  v,
                  m,
                  {
                    ref: D,
                    style: { outline: 'none', ...m.style },
                    onKeyDown: St(m.onKeyDown, (H) => {
                      const Ae = H.target.closest('[data-radix-menu-content]') === H.currentTarget,
                        Ie = H.ctrlKey || H.altKey || H.metaKey,
                        fe = H.key.length === 1
                      Ae && (H.key === 'Tab' && H.preventDefault(), !Ie && fe && Me(H.key))
                      const _e = k.current
                      if (H.target !== _e || !tU.includes(H.key)) return
                      H.preventDefault()
                      const Z = T()
                        .filter((it) => !it.disabled)
                        .map((it) => it.ref.current)
                      Z6.includes(H.key) && Z.reverse(), SU(Z)
                    }),
                    onBlur: St(e.onBlur, (H) => {
                      H.currentTarget.contains(H.target) ||
                        (window.clearTimeout(F.current), (V.current = ''))
                    }),
                    onPointerMove: St(
                      e.onPointerMove,
                      Iv((H) => {
                        const oe = H.target,
                          Ae = we.current !== H.clientX
                        if (H.currentTarget.contains(oe) && Ae) {
                          const Ie = H.clientX > we.current ? 'right' : 'left'
                          ;(xe.current = Ie), (we.current = H.clientX)
                        }
                      })
                    ),
                  }
                )
              )
            )
          )
        )
      )
    )
  }),
  Pv = 'MenuItem',
  XS = 'menu.itemSelect',
  gU = w.forwardRef((e, t) => {
    const { disabled: n = !1, onSelect: r, ...i } = e,
      s = w.useRef(null),
      o = lb(Pv, e.__scopeMenu),
      a = nk(Pv, e.__scopeMenu),
      l = Qn(t, s),
      c = w.useRef(!1),
      u = () => {
        const f = s.current
        if (!n && f) {
          const d = new CustomEvent(XS, { bubbles: !0, cancelable: !0 })
          f.addEventListener(XS, (p) => (r == null ? void 0 : r(p)), { once: !0 }),
            X_(f, d),
            d.defaultPrevented ? (c.current = !1) : o.onClose()
        }
      }
    return w.createElement(
      mU,
      He({}, i, {
        ref: l,
        disabled: n,
        onClick: St(e.onClick, u),
        onPointerDown: (f) => {
          var d
          ;(d = e.onPointerDown) === null || d === void 0 || d.call(e, f), (c.current = !0)
        },
        onPointerUp: St(e.onPointerUp, (f) => {
          var d
          c.current || (d = f.currentTarget) === null || d === void 0 || d.click()
        }),
        onKeyDown: St(e.onKeyDown, (f) => {
          const d = a.searchRef.current !== ''
          n ||
            (d && f.key === ' ') ||
            (JB.includes(f.key) && (f.currentTarget.click(), f.preventDefault()))
        }),
      })
    )
  }),
  mU = w.forwardRef((e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: i, ...s } = e,
      o = nk(Pv, n),
      a = ek(n),
      l = w.useRef(null),
      c = Qn(t, l),
      [u, f] = w.useState(!1),
      [d, p] = w.useState('')
    return (
      w.useEffect(() => {
        const h = l.current
        if (h) {
          var m
          p(((m = h.textContent) !== null && m !== void 0 ? m : '').trim())
        }
      }, [s.children]),
      w.createElement(
        Rv.ItemSlot,
        { scope: n, disabled: r, textValue: i ?? d },
        w.createElement(
          ZB,
          He({ asChild: !0 }, a, { focusable: !r }),
          w.createElement(
            dr.div,
            He(
              {
                role: 'menuitem',
                'data-highlighted': u ? '' : void 0,
                'aria-disabled': r || void 0,
                'data-disabled': r ? '' : void 0,
              },
              s,
              {
                ref: c,
                onPointerMove: St(
                  e.onPointerMove,
                  Iv((h) => {
                    r
                      ? o.onItemLeave(h)
                      : (o.onItemEnter(h), h.defaultPrevented || h.currentTarget.focus())
                  })
                ),
                onPointerLeave: St(
                  e.onPointerLeave,
                  Iv((h) => o.onItemLeave(h))
                ),
                onFocus: St(e.onFocus, () => f(!0)),
                onBlur: St(e.onBlur, () => f(!1)),
              }
            )
          )
        )
      )
    )
  }),
  yU = 'MenuRadioGroup'
Qa(yU, { value: void 0, onValueChange: () => {} })
const vU = 'MenuItemIndicator'
Qa(vU, { checked: !1 })
const wU = w.forwardRef((e, t) => {
    const { __scopeMenu: n, ...r } = e
    return w.createElement(
      dr.div,
      He({ role: 'separator', 'aria-orientation': 'horizontal' }, r, { ref: t })
    )
  }),
  bU = 'MenuSub'
Qa(bU)
function xU(e) {
  return e ? 'open' : 'closed'
}
function SU(e) {
  const t = document.activeElement
  for (const n of e) if (n === t || (n.focus(), document.activeElement !== t)) return
}
function EU(e, t) {
  return e.map((n, r) => e[(t + r) % e.length])
}
function CU(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((c) => c === t[0]) ? t[0] : t,
    s = n ? e.indexOf(n) : -1
  let o = EU(e, Math.max(s, 0))
  i.length === 1 && (o = o.filter((c) => c !== n))
  const l = o.find((c) => c.toLowerCase().startsWith(i.toLowerCase()))
  return l !== n ? l : void 0
}
function _U(e, t) {
  const { x: n, y: r } = e
  let i = !1
  for (let s = 0, o = t.length - 1; s < t.length; o = s++) {
    const a = t[s].x,
      l = t[s].y,
      c = t[o].x,
      u = t[o].y
    l > r != u > r && n < ((c - a) * (r - l)) / (u - l) + a && (i = !i)
  }
  return i
}
function OU(e, t) {
  if (!t) return !1
  const n = { x: e.clientX, y: e.clientY }
  return _U(n, t)
}
function Iv(e) {
  return (t) => (t.pointerType === 'mouse' ? e(t) : void 0)
}
const kU = oU,
  TU = aU,
  AU = uU,
  RU = dU,
  PU = gU,
  IU = wU,
  ik = 'DropdownMenu',
  [DU, SQ] = Fc(ik, [J6]),
  qc = J6(),
  [NU, sk] = DU(ik),
  MU = (e) => {
    const {
        __scopeDropdownMenu: t,
        children: n,
        dir: r,
        open: i,
        defaultOpen: s,
        onOpenChange: o,
        modal: a = !0,
      } = e,
      l = qc(t),
      c = w.useRef(null),
      [u = !1, f] = Iw({ prop: i, defaultProp: s, onChange: o })
    return w.createElement(
      NU,
      {
        scope: t,
        triggerId: Bl(),
        triggerRef: c,
        contentId: Bl(),
        open: u,
        onOpenChange: f,
        onOpenToggle: w.useCallback(() => f((d) => !d), [f]),
        modal: a,
      },
      w.createElement(kU, He({}, l, { open: u, onOpenChange: f, dir: r, modal: a }), n)
    )
  },
  jU = 'DropdownMenuTrigger',
  LU = w.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e,
      s = sk(jU, n),
      o = qc(n)
    return w.createElement(
      TU,
      He({ asChild: !0 }, o),
      w.createElement(
        dr.button,
        He(
          {
            type: 'button',
            id: s.triggerId,
            'aria-haspopup': 'menu',
            'aria-expanded': s.open,
            'aria-controls': s.open ? s.contentId : void 0,
            'data-state': s.open ? 'open' : 'closed',
            'data-disabled': r ? '' : void 0,
            disabled: r,
          },
          i,
          {
            ref: Pw(t, s.triggerRef),
            onPointerDown: St(e.onPointerDown, (a) => {
              !r &&
                a.button === 0 &&
                a.ctrlKey === !1 &&
                (s.onOpenToggle(), s.open || a.preventDefault())
            }),
            onKeyDown: St(e.onKeyDown, (a) => {
              r ||
                (['Enter', ' '].includes(a.key) && s.onOpenToggle(),
                a.key === 'ArrowDown' && s.onOpenChange(!0),
                ['Enter', ' ', 'ArrowDown'].includes(a.key) && a.preventDefault())
            }),
          }
        )
      )
    )
  }),
  $U = (e) => {
    const { __scopeDropdownMenu: t, ...n } = e,
      r = qc(t)
    return w.createElement(AU, He({}, r, n))
  },
  FU = 'DropdownMenuContent',
  BU = w.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      i = sk(FU, n),
      s = qc(n),
      o = w.useRef(!1)
    return w.createElement(
      RU,
      He({ id: i.contentId, 'aria-labelledby': i.triggerId }, s, r, {
        ref: t,
        onCloseAutoFocus: St(e.onCloseAutoFocus, (a) => {
          var l
          o.current || (l = i.triggerRef.current) === null || l === void 0 || l.focus(),
            (o.current = !1),
            a.preventDefault()
        }),
        onInteractOutside: St(e.onInteractOutside, (a) => {
          const l = a.detail.originalEvent,
            c = l.button === 0 && l.ctrlKey === !0,
            u = l.button === 2 || c
          ;(!i.modal || u) && (o.current = !0)
        }),
        style: {
          ...e.style,
          '--radix-dropdown-menu-content-transform-origin': 'var(--radix-popper-transform-origin)',
          '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',
          '--radix-dropdown-menu-content-available-height': 'var(--radix-popper-available-height)',
          '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',
          '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',
        },
      })
    )
  }),
  UU = w.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      i = qc(n)
    return w.createElement(PU, He({}, i, r, { ref: t }))
  }),
  zU = w.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e,
      i = qc(n)
    return w.createElement(IU, He({}, i, r, { ref: t }))
  }),
  WU = MU,
  VU = LU,
  HU = $U,
  qU = BU,
  ok = UU,
  KU = zU,
  GU = '1.0.5',
  YU = '1.27.0',
  QU = {
    '-32700': 'ParseError',
    '-32701': 'OversizedRequest',
    '-32702': 'OversizedResponse',
    '-32600': 'InvalidRequest',
    '-32601': 'MethodNotFound',
    '-32602': 'InvalidParams',
    '-32603': 'InternalError',
    '-32604': 'ServerBusy',
    '-32000': 'CallExecutionFailed',
    '-32001': 'UnknownError',
    '-32003': 'SubscriptionClosed',
    '-32004': 'SubscriptionClosedWithError',
    '-32005': 'BatchesNotSupported',
    '-32006': 'TooManySubscriptions',
    '-32050': 'TransientError',
    '-32002': 'TransactionExecutionClientError',
  }
class ak extends Error {}
class lk extends ak {
  constructor(t, n) {
    super(t), (this.code = n), (this.type = QU[n] ?? 'ServerError')
  }
}
class XU extends ak {
  constructor(t, n, r) {
    super(t), (this.status = n), (this.statusText = r)
  }
}
var cb = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  Gt = (e, t, n) => (cb(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  Js = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  Wl = (e, t, n, r) => (cb(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  ZU = (e, t, n, r) => ({
    set _(i) {
      Wl(e, t, i, n)
    },
    get _() {
      return Gt(e, t, r)
    },
  }),
  ck = (e, t, n) => (cb(e, t, 'access private method'), n),
  sa,
  Hu,
  Ss,
  ya,
  Ef,
  Vl,
  Dv,
  uk,
  ub,
  fk
function JU(e) {
  const t = new URL(e)
  return (t.protocol = t.protocol.replace('http', 'ws')), t.toString()
}
const ez = {
  WebSocketConstructor: typeof WebSocket < 'u' ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5,
}
class tz {
  constructor(t, n = {}) {
    if (
      (Js(this, Dv),
      Js(this, ub),
      Js(this, sa, 0),
      Js(this, Hu, 0),
      Js(this, Ss, null),
      Js(this, ya, null),
      Js(this, Ef, new Set()),
      Js(this, Vl, new Map()),
      (this.endpoint = t),
      (this.options = { ...ez, ...n }),
      !this.options.WebSocketConstructor)
    )
      throw new Error('Missing WebSocket constructor')
    this.endpoint.startsWith('http') && (this.endpoint = JU(this.endpoint))
  }
  async makeRequest(t, n) {
    const r = await ck(this, Dv, uk).call(this)
    return new Promise((i, s) => {
      Wl(this, sa, Gt(this, sa) + 1),
        Gt(this, Vl).set(Gt(this, sa), {
          resolve: i,
          reject: s,
          timeout: setTimeout(() => {
            Gt(this, Vl).delete(Gt(this, sa)), s(new Error(`Request timeout: ${t}`))
          }, this.options.callTimeout),
        }),
        r.send(JSON.stringify({ jsonrpc: '2.0', id: Gt(this, sa), method: t, params: n }))
    }).then(({ error: i, result: s }) => {
      if (i) throw new lk(i.message, i.code)
      return s
    })
  }
  async subscribe(t) {
    const n = new nz(t)
    return Gt(this, Ef).add(n), await n.subscribe(this), () => n.unsubscribe(this)
  }
}
sa = new WeakMap()
Hu = new WeakMap()
Ss = new WeakMap()
ya = new WeakMap()
Ef = new WeakMap()
Vl = new WeakMap()
Dv = new WeakSet()
uk = function () {
  return Gt(this, ya)
    ? Gt(this, ya)
    : (Wl(
        this,
        ya,
        new Promise((e) => {
          var t
          ;(t = Gt(this, Ss)) == null || t.close(),
            Wl(this, Ss, new this.options.WebSocketConstructor(this.endpoint)),
            Gt(this, Ss).addEventListener('open', () => {
              Wl(this, Hu, 0), e(Gt(this, Ss))
            }),
            Gt(this, Ss).addEventListener('close', () => {
              ZU(this, Hu)._++,
                Gt(this, Hu) <= this.options.maxReconnects &&
                  setTimeout(() => {
                    ck(this, ub, fk).call(this)
                  }, this.options.reconnectTimeout)
            }),
            Gt(this, Ss).addEventListener('message', ({ data: n }) => {
              let r
              try {
                r = JSON.parse(n)
              } catch (i) {
                console.error(new Error(`Failed to parse RPC message: ${n}`, { cause: i }))
                return
              }
              if ('id' in r && r.id != null && Gt(this, Vl).has(r.id)) {
                const { resolve: i, timeout: s } = Gt(this, Vl).get(r.id)
                clearTimeout(s), i(r)
              } else if ('params' in r) {
                const { params: i } = r
                Gt(this, Ef).forEach((s) => {
                  s.subscriptionId === i.subscription &&
                    i.subscription === s.subscriptionId &&
                    s.onMessage(i.result)
                })
              }
            })
        })
      ),
      Gt(this, ya))
}
ub = new WeakSet()
fk = async function () {
  var e
  return (
    (e = Gt(this, Ss)) == null || e.close(),
    Wl(this, ya, null),
    Promise.allSettled([...Gt(this, Ef)].map((t) => t.subscribe(this)))
  )
}
class nz {
  constructor(t) {
    ;(this.subscriptionId = null), (this.subscribed = !1), (this.input = t)
  }
  onMessage(t) {
    this.subscribed && this.input.onMessage(t)
  }
  async unsubscribe(t) {
    const { subscriptionId: n } = this
    return (
      (this.subscribed = !1),
      n == null ? !1 : ((this.subscriptionId = null), t.makeRequest(this.input.unsubscribe, [n]))
    )
  }
  async subscribe(t) {
    ;(this.subscriptionId = null), (this.subscribed = !0)
    const n = await t.makeRequest(this.input.method, this.input.params)
    this.subscribed && (this.subscriptionId = n)
  }
}
var fb = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  Gr = (e, t, n) => (fb(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  zd = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  Nv = (e, t, n, r) => (fb(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  rz = (e, t, n) => (fb(e, t, 'access private method'), n),
  Eu,
  Si,
  qu,
  Mv,
  dk
class iz {
  constructor(t) {
    zd(this, Mv), zd(this, Eu, 0), zd(this, Si, void 0), zd(this, qu, void 0), Nv(this, Si, t)
  }
  fetch(t, n) {
    const r = Gr(this, Si).fetch ?? fetch
    if (!r)
      throw new Error(
        'The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.'
      )
    return r(t, n)
  }
  async request(t) {
    var i, s
    Nv(this, Eu, Gr(this, Eu) + 1)
    const n = await this.fetch(
      ((i = Gr(this, Si).rpc) == null ? void 0 : i.url) ?? Gr(this, Si).url,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Client-Sdk-Type': 'typescript',
          'Client-Sdk-Version': GU,
          'Client-Target-Api-Version': YU,
          ...((s = Gr(this, Si).rpc) == null ? void 0 : s.headers),
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          id: Gr(this, Eu),
          method: t.method,
          params: t.params,
        }),
      }
    )
    if (!n.ok) throw new XU(`Unexpected status code: ${n.status}`, n.status, n.statusText)
    const r = await n.json()
    if ('error' in r && r.error != null) throw new lk(r.error.message, r.error.code)
    return r.result
  }
  async subscribe(t) {
    const n = await rz(this, Mv, dk).call(this).subscribe(t)
    return async () => !!(await n())
  }
}
Eu = new WeakMap()
Si = new WeakMap()
qu = new WeakMap()
Mv = new WeakSet()
dk = function () {
  var e
  if (!Gr(this, qu)) {
    const t = Gr(this, Si).WebSocketConstructor ?? WebSocket
    if (!t)
      throw new Error(
        'The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.'
      )
    Nv(
      this,
      qu,
      new tz(((e = Gr(this, Si).websocket) == null ? void 0 : e.url) ?? Gr(this, Si).url, {
        WebSocketConstructor: t,
        ...Gr(this, Si).websocket,
      })
    )
  }
  return Gr(this, qu)
}
function sz(e) {
  switch (e) {
    case 'mainnet':
      return 'https://fullnode.mainnet.sui.io:443'
    case 'testnet':
      return 'https://fullnode.testnet.sui.io:443'
    case 'devnet':
      return 'https://fullnode.devnet.sui.io:443'
    case 'localnet':
      return 'http://127.0.0.1:9000'
    default:
      throw new Error(`Unknown network: ${e}`)
  }
}
const hk = Symbol.for('@mysten/SuiClient')
function oz(e) {
  return typeof e == 'object' && e !== null && e[hk] === !0
}
class pk {
  get [hk]() {
    return !0
  }
  constructor(t) {
    this.transport = t.transport ?? new iz({ url: t.url })
  }
  async getRpcApiVersion() {
    return (await this.transport.request({ method: 'rpc.discover', params: [] })).info.version
  }
  async getCoins(t) {
    if (!t.owner || !xs(kt(t.owner))) throw new Error('Invalid Sui address')
    return await this.transport.request({
      method: 'suix_getCoins',
      params: [t.owner, t.coinType, t.cursor, t.limit],
    })
  }
  async getAllCoins(t) {
    if (!t.owner || !xs(kt(t.owner))) throw new Error('Invalid Sui address')
    return await this.transport.request({
      method: 'suix_getAllCoins',
      params: [t.owner, t.cursor, t.limit],
    })
  }
  async getBalance(t) {
    if (!t.owner || !xs(kt(t.owner))) throw new Error('Invalid Sui address')
    return await this.transport.request({
      method: 'suix_getBalance',
      params: [t.owner, t.coinType],
    })
  }
  async getAllBalances(t) {
    if (!t.owner || !xs(kt(t.owner))) throw new Error('Invalid Sui address')
    return await this.transport.request({ method: 'suix_getAllBalances', params: [t.owner] })
  }
  async getCoinMetadata(t) {
    return await this.transport.request({ method: 'suix_getCoinMetadata', params: [t.coinType] })
  }
  async getTotalSupply(t) {
    return await this.transport.request({ method: 'suix_getTotalSupply', params: [t.coinType] })
  }
  async call(t, n) {
    return await this.transport.request({ method: t, params: n })
  }
  async getMoveFunctionArgTypes(t) {
    return await this.transport.request({
      method: 'sui_getMoveFunctionArgTypes',
      params: [t.package, t.module, t.function],
    })
  }
  async getNormalizedMoveModulesByPackage(t) {
    return await this.transport.request({
      method: 'sui_getNormalizedMoveModulesByPackage',
      params: [t.package],
    })
  }
  async getNormalizedMoveModule(t) {
    return await this.transport.request({
      method: 'sui_getNormalizedMoveModule',
      params: [t.package, t.module],
    })
  }
  async getNormalizedMoveFunction(t) {
    return await this.transport.request({
      method: 'sui_getNormalizedMoveFunction',
      params: [t.package, t.module, t.function],
    })
  }
  async getNormalizedMoveStruct(t) {
    return await this.transport.request({
      method: 'sui_getNormalizedMoveStruct',
      params: [t.package, t.module, t.struct],
    })
  }
  async getOwnedObjects(t) {
    if (!t.owner || !xs(kt(t.owner))) throw new Error('Invalid Sui address')
    return await this.transport.request({
      method: 'suix_getOwnedObjects',
      params: [t.owner, { filter: t.filter, options: t.options }, t.cursor, t.limit],
    })
  }
  async getObject(t) {
    if (!t.id || !Fd(ks(t.id))) throw new Error('Invalid Sui Object id')
    return await this.transport.request({ method: 'sui_getObject', params: [t.id, t.options] })
  }
  async tryGetPastObject(t) {
    return await this.transport.request({
      method: 'sui_tryGetPastObject',
      params: [t.id, t.version, t.options],
    })
  }
  async multiGetObjects(t) {
    if (
      (t.ids.forEach((r) => {
        if (!r || !Fd(ks(r))) throw new Error(`Invalid Sui Object id ${r}`)
      }),
      t.ids.length !== new Set(t.ids).size)
    )
      throw new Error(`Duplicate object ids in batch call ${t.ids}`)
    return await this.transport.request({
      method: 'sui_multiGetObjects',
      params: [t.ids, t.options],
    })
  }
  async queryTransactionBlocks(t) {
    return await this.transport.request({
      method: 'suix_queryTransactionBlocks',
      params: [
        { filter: t.filter, options: t.options },
        t.cursor,
        t.limit,
        (t.order || 'descending') === 'descending',
      ],
    })
  }
  async getTransactionBlock(t) {
    if (!TS(t.digest)) throw new Error('Invalid Transaction digest')
    return await this.transport.request({
      method: 'sui_getTransactionBlock',
      params: [t.digest, t.options],
    })
  }
  async multiGetTransactionBlocks(t) {
    if (
      (t.digests.forEach((r) => {
        if (!TS(r)) throw new Error(`Invalid Transaction digest ${r}`)
      }),
      t.digests.length !== new Set(t.digests).size)
    )
      throw new Error(`Duplicate digests in batch call ${t.digests}`)
    return await this.transport.request({
      method: 'sui_multiGetTransactionBlocks',
      params: [t.digests, t.options],
    })
  }
  async executeTransactionBlock(t) {
    return await this.transport.request({
      method: 'sui_executeTransactionBlock',
      params: [
        typeof t.transactionBlock == 'string' ? t.transactionBlock : Pt(t.transactionBlock),
        Array.isArray(t.signature) ? t.signature : [t.signature],
        t.options,
        t.requestType,
      ],
    })
  }
  async signAndExecuteTransaction({ transaction: t, signer: n, ...r }) {
    let i
    t instanceof Uint8Array
      ? (i = t)
      : (t.setSenderIfNotSet(n.toSuiAddress()), (i = await t.build({ client: this })))
    const { signature: s, bytes: o } = await n.signTransaction(i)
    return this.executeTransactionBlock({ transactionBlock: o, signature: s, ...r })
  }
  async getTotalTransactionBlocks() {
    const t = await this.transport.request({ method: 'sui_getTotalTransactionBlocks', params: [] })
    return BigInt(t)
  }
  async getReferenceGasPrice() {
    const t = await this.transport.request({ method: 'suix_getReferenceGasPrice', params: [] })
    return BigInt(t)
  }
  async getStakes(t) {
    if (!t.owner || !xs(kt(t.owner))) throw new Error('Invalid Sui address')
    return await this.transport.request({ method: 'suix_getStakes', params: [t.owner] })
  }
  async getStakesByIds(t) {
    return (
      t.stakedSuiIds.forEach((n) => {
        if (!n || !Fd(ks(n))) throw new Error(`Invalid Sui Stake id ${n}`)
      }),
      await this.transport.request({ method: 'suix_getStakesByIds', params: [t.stakedSuiIds] })
    )
  }
  async getLatestSuiSystemState() {
    return await this.transport.request({ method: 'suix_getLatestSuiSystemState', params: [] })
  }
  async queryEvents(t) {
    return await this.transport.request({
      method: 'suix_queryEvents',
      params: [t.query, t.cursor, t.limit, (t.order || 'descending') === 'descending'],
    })
  }
  async subscribeEvent(t) {
    return this.transport.subscribe({
      method: 'suix_subscribeEvent',
      unsubscribe: 'suix_unsubscribeEvent',
      params: [t.filter],
      onMessage: t.onMessage,
    })
  }
  async subscribeTransaction(t) {
    return this.transport.subscribe({
      method: 'suix_subscribeTransaction',
      unsubscribe: 'suix_unsubscribeTransaction',
      params: [t.filter],
      onMessage: t.onMessage,
    })
  }
  async devInspectTransactionBlock(t) {
    var r
    let n
    if (P6(t.transactionBlock))
      t.transactionBlock.setSenderIfNotSet(t.sender),
        (n = Pt(await t.transactionBlock.build({ client: this, onlyTransactionKind: !0 })))
    else if (typeof t.transactionBlock == 'string') n = t.transactionBlock
    else if (t.transactionBlock instanceof Uint8Array) n = Pt(t.transactionBlock)
    else throw new Error('Unknown transaction block format.')
    return await this.transport.request({
      method: 'sui_devInspectTransactionBlock',
      params: [t.sender, n, (r = t.gasPrice) == null ? void 0 : r.toString(), t.epoch],
    })
  }
  async dryRunTransactionBlock(t) {
    return await this.transport.request({
      method: 'sui_dryRunTransactionBlock',
      params: [typeof t.transactionBlock == 'string' ? t.transactionBlock : Pt(t.transactionBlock)],
    })
  }
  async getDynamicFields(t) {
    if (!t.parentId || !Fd(ks(t.parentId))) throw new Error('Invalid Sui Object id')
    return await this.transport.request({
      method: 'suix_getDynamicFields',
      params: [t.parentId, t.cursor, t.limit],
    })
  }
  async getDynamicFieldObject(t) {
    return await this.transport.request({
      method: 'suix_getDynamicFieldObject',
      params: [t.parentId, t.name],
    })
  }
  async getLatestCheckpointSequenceNumber() {
    const t = await this.transport.request({
      method: 'sui_getLatestCheckpointSequenceNumber',
      params: [],
    })
    return String(t)
  }
  async getCheckpoint(t) {
    return await this.transport.request({ method: 'sui_getCheckpoint', params: [t.id] })
  }
  async getCheckpoints(t) {
    return await this.transport.request({
      method: 'sui_getCheckpoints',
      params: [t.cursor, t == null ? void 0 : t.limit, t.descendingOrder],
    })
  }
  async getCommitteeInfo(t) {
    return await this.transport.request({
      method: 'suix_getCommitteeInfo',
      params: [t == null ? void 0 : t.epoch],
    })
  }
  async getNetworkMetrics() {
    return await this.transport.request({ method: 'suix_getNetworkMetrics', params: [] })
  }
  async getAddressMetrics() {
    return await this.transport.request({ method: 'suix_getLatestAddressMetrics', params: [] })
  }
  async getEpochMetrics(t) {
    return await this.transport.request({
      method: 'suix_getEpochMetrics',
      params: [
        t == null ? void 0 : t.cursor,
        t == null ? void 0 : t.limit,
        t == null ? void 0 : t.descendingOrder,
      ],
    })
  }
  async getAllEpochAddressMetrics(t) {
    return await this.transport.request({
      method: 'suix_getAllEpochAddressMetrics',
      params: [t == null ? void 0 : t.descendingOrder],
    })
  }
  async getEpochs(t) {
    return await this.transport.request({
      method: 'suix_getEpochs',
      params: [
        t == null ? void 0 : t.cursor,
        t == null ? void 0 : t.limit,
        t == null ? void 0 : t.descendingOrder,
      ],
    })
  }
  async getMoveCallMetrics() {
    return await this.transport.request({ method: 'suix_getMoveCallMetrics', params: [] })
  }
  async getCurrentEpoch() {
    return await this.transport.request({ method: 'suix_getCurrentEpoch', params: [] })
  }
  async getValidatorsApy() {
    return await this.transport.request({ method: 'suix_getValidatorsApy', params: [] })
  }
  async getChainIdentifier() {
    const t = await this.getCheckpoint({ id: '0' }),
      n = bf(t.digest)
    return Sc(n.slice(0, 4))
  }
  async resolveNameServiceAddress(t) {
    return await this.transport.request({
      method: 'suix_resolveNameServiceAddress',
      params: [t.name],
    })
  }
  async resolveNameServiceNames({ format: t = 'dot', ...n }) {
    const {
      nextCursor: r,
      hasNextPage: i,
      data: s,
    } = await this.transport.request({
      method: 'suix_resolveNameServiceNames',
      params: [n.address, n.cursor, n.limit],
    })
    return { hasNextPage: i, nextCursor: r, data: s.map((o) => j$(o, t)) }
  }
  async getProtocolConfig(t) {
    return await this.transport.request({
      method: 'sui_getProtocolConfig',
      params: [t == null ? void 0 : t.version],
    })
  }
  async waitForTransaction({ signal: t, timeout: n = 60 * 1e3, pollInterval: r = 2 * 1e3, ...i }) {
    const s = AbortSignal.timeout(n),
      o = new Promise((a, l) => {
        s.addEventListener('abort', () => l(s.reason))
      })
    for (o.catch(() => {}); !s.aborted; ) {
      t == null || t.throwIfAborted()
      try {
        return await this.getTransactionBlock(i)
      } catch {
        await Promise.race([new Promise((l) => setTimeout(l, r)), o])
      }
    }
    throw (s.throwIfAborted(), new Error('Unexpected error while waiting for transaction block.'))
  }
}
function gk(e, t) {
  return lt
    .IntentMessage(lt.fixedArray(t.length, lt.u8()))
    .serialize({
      intent: { scope: { [e]: !0 }, version: { V0: !0 }, appId: { Sui: !0 } },
      value: t,
    })
    .toBytes()
}
function mk(e, t) {
  if (e === t) return !0
  if (e.length !== t.length) return !1
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1
  return !0
}
class yk {
  equals(t) {
    return mk(this.toRawBytes(), t.toRawBytes())
  }
  toBase64() {
    return Pt(this.toRawBytes())
  }
  toString() {
    throw new Error(
      '`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.'
    )
  }
  toSuiPublicKey() {
    const t = this.toSuiBytes()
    return Pt(t)
  }
  verifyWithIntent(t, n, r) {
    const i = gk(r, t),
      s = Gp(i, { dkLen: 32 })
    return this.verify(s, n)
  }
  verifyPersonalMessage(t, n) {
    return this.verifyWithIntent(lt.vector(lt.u8()).serialize(t).toBytes(), n, 'PersonalMessage')
  }
  verifyTransaction(t, n) {
    return this.verifyWithIntent(t, n, 'TransactionData')
  }
  toSuiBytes() {
    const t = this.toRawBytes(),
      n = new Uint8Array(t.length + 1)
    return n.set([this.flag()]), n.set(t, 1), n
  }
  toSuiAddress() {
    return kt(L9(Gp(this.toSuiBytes(), { dkLen: 32 })).slice(0, ng * 2))
  }
}
const sd = { ED25519: 0, Secp256k1: 1, Secp256r1: 2, MultiSig: 3, ZkLogin: 5 },
  az = { ED25519: 32, Secp256k1: 33, Secp256r1: 33 },
  lz = { 0: 'ED25519', 1: 'Secp256k1', 2: 'Secp256r1', 3: 'MultiSig', 5: 'ZkLogin' }
function cz(e, t) {
  if (!!!e) throw new Error(t)
}
const vk = {
    Name: [],
    Document: ['definitions'],
    OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
    VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
    Variable: ['name'],
    SelectionSet: ['selections'],
    Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
    Argument: ['name', 'value'],
    FragmentSpread: ['name', 'directives'],
    InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
    FragmentDefinition: [
      'name',
      'variableDefinitions',
      'typeCondition',
      'directives',
      'selectionSet',
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ['values'],
    ObjectValue: ['fields'],
    ObjectField: ['name', 'value'],
    Directive: ['name', 'arguments'],
    NamedType: ['name'],
    ListType: ['type'],
    NonNullType: ['type'],
    SchemaDefinition: ['description', 'directives', 'operationTypes'],
    OperationTypeDefinition: ['type'],
    ScalarTypeDefinition: ['description', 'name', 'directives'],
    ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
    FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
    InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
    InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
    UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
    EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
    EnumValueDefinition: ['description', 'name', 'directives'],
    InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
    DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
    SchemaExtension: ['directives', 'operationTypes'],
    ScalarTypeExtension: ['name', 'directives'],
    ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
    InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
    UnionTypeExtension: ['name', 'directives', 'types'],
    EnumTypeExtension: ['name', 'directives', 'values'],
    InputObjectTypeExtension: ['name', 'directives', 'fields'],
  },
  uz = new Set(Object.keys(vk))
function ZS(e) {
  const t = e == null ? void 0 : e.kind
  return typeof t == 'string' && uz.has(t)
}
var JS
;(function (e) {
  ;(e.QUERY = 'query'), (e.MUTATION = 'mutation'), (e.SUBSCRIPTION = 'subscription')
})(JS || (JS = {}))
var jv
;(function (e) {
  ;(e.NAME = 'Name'),
    (e.DOCUMENT = 'Document'),
    (e.OPERATION_DEFINITION = 'OperationDefinition'),
    (e.VARIABLE_DEFINITION = 'VariableDefinition'),
    (e.SELECTION_SET = 'SelectionSet'),
    (e.FIELD = 'Field'),
    (e.ARGUMENT = 'Argument'),
    (e.FRAGMENT_SPREAD = 'FragmentSpread'),
    (e.INLINE_FRAGMENT = 'InlineFragment'),
    (e.FRAGMENT_DEFINITION = 'FragmentDefinition'),
    (e.VARIABLE = 'Variable'),
    (e.INT = 'IntValue'),
    (e.FLOAT = 'FloatValue'),
    (e.STRING = 'StringValue'),
    (e.BOOLEAN = 'BooleanValue'),
    (e.NULL = 'NullValue'),
    (e.ENUM = 'EnumValue'),
    (e.LIST = 'ListValue'),
    (e.OBJECT = 'ObjectValue'),
    (e.OBJECT_FIELD = 'ObjectField'),
    (e.DIRECTIVE = 'Directive'),
    (e.NAMED_TYPE = 'NamedType'),
    (e.LIST_TYPE = 'ListType'),
    (e.NON_NULL_TYPE = 'NonNullType'),
    (e.SCHEMA_DEFINITION = 'SchemaDefinition'),
    (e.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'),
    (e.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'),
    (e.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'),
    (e.FIELD_DEFINITION = 'FieldDefinition'),
    (e.INPUT_VALUE_DEFINITION = 'InputValueDefinition'),
    (e.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'),
    (e.UNION_TYPE_DEFINITION = 'UnionTypeDefinition'),
    (e.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'),
    (e.ENUM_VALUE_DEFINITION = 'EnumValueDefinition'),
    (e.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'),
    (e.DIRECTIVE_DEFINITION = 'DirectiveDefinition'),
    (e.SCHEMA_EXTENSION = 'SchemaExtension'),
    (e.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'),
    (e.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'),
    (e.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'),
    (e.UNION_TYPE_EXTENSION = 'UnionTypeExtension'),
    (e.ENUM_TYPE_EXTENSION = 'EnumTypeExtension'),
    (e.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension')
})(jv || (jv = {}))
function eE(e) {
  return e === 9 || e === 32
}
function fz(e, t) {
  const n = e.replace(/"""/g, '\\"""'),
    r = n.split(/\r\n|[\n\r]/g),
    i = r.length === 1,
    s = r.length > 1 && r.slice(1).every((p) => p.length === 0 || eE(p.charCodeAt(0))),
    o = n.endsWith('\\"""'),
    a = e.endsWith('"') && !o,
    l = e.endsWith('\\'),
    c = a || l,
    u = !(t != null && t.minimize) && (!i || e.length > 70 || c || s || o)
  let f = ''
  const d = i && eE(e.charCodeAt(0))
  return (
    ((u && !d) || s) &&
      (f += `
`),
    (f += n),
    (u || c) &&
      (f += `
`),
    '"""' + f + '"""'
  )
}
const dz = 10,
  wk = 2
function hz(e) {
  return ag(e, [])
}
function ag(e, t) {
  switch (typeof e) {
    case 'string':
      return JSON.stringify(e)
    case 'function':
      return e.name ? `[function ${e.name}]` : '[function]'
    case 'object':
      return pz(e, t)
    default:
      return String(e)
  }
}
function pz(e, t) {
  if (e === null) return 'null'
  if (t.includes(e)) return '[Circular]'
  const n = [...t, e]
  if (gz(e)) {
    const r = e.toJSON()
    if (r !== e) return typeof r == 'string' ? r : ag(r, n)
  } else if (Array.isArray(e)) return yz(e, n)
  return mz(e, n)
}
function gz(e) {
  return typeof e.toJSON == 'function'
}
function mz(e, t) {
  const n = Object.entries(e)
  return n.length === 0
    ? '{}'
    : t.length > wk
    ? '[' + vz(e) + ']'
    : '{ ' + n.map(([i, s]) => i + ': ' + ag(s, t)).join(', ') + ' }'
}
function yz(e, t) {
  if (e.length === 0) return '[]'
  if (t.length > wk) return '[Array]'
  const n = Math.min(dz, e.length),
    r = e.length - n,
    i = []
  for (let s = 0; s < n; ++s) i.push(ag(e[s], t))
  return (
    r === 1 ? i.push('... 1 more item') : r > 1 && i.push(`... ${r} more items`),
    '[' + i.join(', ') + ']'
  )
}
function vz(e) {
  const t = Object.prototype.toString
    .call(e)
    .replace(/^\[object /, '')
    .replace(/]$/, '')
  if (t === 'Object' && typeof e.constructor == 'function') {
    const n = e.constructor.name
    if (typeof n == 'string' && n !== '') return n
  }
  return t
}
function wz(e) {
  return `"${e.replace(bz, xz)}"`
}
const bz = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g
function xz(e) {
  return Sz[e.charCodeAt(0)]
}
const Sz = [
    '\\u0000',
    '\\u0001',
    '\\u0002',
    '\\u0003',
    '\\u0004',
    '\\u0005',
    '\\u0006',
    '\\u0007',
    '\\b',
    '\\t',
    '\\n',
    '\\u000B',
    '\\f',
    '\\r',
    '\\u000E',
    '\\u000F',
    '\\u0010',
    '\\u0011',
    '\\u0012',
    '\\u0013',
    '\\u0014',
    '\\u0015',
    '\\u0016',
    '\\u0017',
    '\\u0018',
    '\\u0019',
    '\\u001A',
    '\\u001B',
    '\\u001C',
    '\\u001D',
    '\\u001E',
    '\\u001F',
    '',
    '',
    '\\"',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\u007F',
    '\\u0080',
    '\\u0081',
    '\\u0082',
    '\\u0083',
    '\\u0084',
    '\\u0085',
    '\\u0086',
    '\\u0087',
    '\\u0088',
    '\\u0089',
    '\\u008A',
    '\\u008B',
    '\\u008C',
    '\\u008D',
    '\\u008E',
    '\\u008F',
    '\\u0090',
    '\\u0091',
    '\\u0092',
    '\\u0093',
    '\\u0094',
    '\\u0095',
    '\\u0096',
    '\\u0097',
    '\\u0098',
    '\\u0099',
    '\\u009A',
    '\\u009B',
    '\\u009C',
    '\\u009D',
    '\\u009E',
    '\\u009F',
  ],
  Ez = Object.freeze({})
function Cz(e, t, n = vk) {
  const r = new Map()
  for (const y of Object.values(jv)) r.set(y, _z(t, y))
  let i,
    s = Array.isArray(e),
    o = [e],
    a = -1,
    l = [],
    c = e,
    u,
    f
  const d = [],
    p = []
  do {
    a++
    const y = a === o.length,
      v = y && l.length !== 0
    if (y) {
      if (((u = p.length === 0 ? void 0 : d[d.length - 1]), (c = f), (f = p.pop()), v))
        if (s) {
          c = c.slice()
          let T = 0
          for (const [A, I] of l) {
            const k = A - T
            I === null ? (c.splice(k, 1), T++) : (c[k] = I)
          }
        } else {
          c = Object.defineProperties({}, Object.getOwnPropertyDescriptors(c))
          for (const [T, A] of l) c[T] = A
        }
      ;(a = i.index), (o = i.keys), (l = i.edits), (s = i.inArray), (i = i.prev)
    } else if (f) {
      if (((u = s ? a : o[a]), (c = f[u]), c == null)) continue
      d.push(u)
    }
    let S
    if (!Array.isArray(c)) {
      var h, m
      ZS(c) || cz(!1, `Invalid AST Node: ${hz(c)}.`)
      const T = y
        ? (h = r.get(c.kind)) === null || h === void 0
          ? void 0
          : h.leave
        : (m = r.get(c.kind)) === null || m === void 0
        ? void 0
        : m.enter
      if (((S = T == null ? void 0 : T.call(t, c, u, f, d, p)), S === Ez)) break
      if (S === !1) {
        if (!y) {
          d.pop()
          continue
        }
      } else if (S !== void 0 && (l.push([u, S]), !y))
        if (ZS(S)) c = S
        else {
          d.pop()
          continue
        }
    }
    if ((S === void 0 && v && l.push([u, c]), y)) d.pop()
    else {
      var b
      ;(i = { inArray: s, index: a, keys: o, edits: l, prev: i }),
        (s = Array.isArray(c)),
        (o = s ? c : (b = n[c.kind]) !== null && b !== void 0 ? b : []),
        (a = -1),
        (l = []),
        f && p.push(f),
        (f = c)
    }
  } while (i !== void 0)
  return l.length !== 0 ? l[l.length - 1][1] : e
}
function _z(e, t) {
  const n = e[t]
  return typeof n == 'object'
    ? n
    : typeof n == 'function'
    ? { enter: n, leave: void 0 }
    : { enter: e.enter, leave: e.leave }
}
function Oz(e) {
  return Cz(e, Tz)
}
const kz = 80,
  Tz = {
    Name: { leave: (e) => e.value },
    Variable: { leave: (e) => '$' + e.name },
    Document: {
      leave: (e) =>
        Ce(
          e.definitions,
          `

`
        ),
    },
    OperationDefinition: {
      leave(e) {
        const t = at('(', Ce(e.variableDefinitions, ', '), ')'),
          n = Ce([e.operation, Ce([e.name, t]), Ce(e.directives, ' ')], ' ')
        return (n === 'query' ? '' : n + ' ') + e.selectionSet
      },
    },
    VariableDefinition: {
      leave: ({ variable: e, type: t, defaultValue: n, directives: r }) =>
        e + ': ' + t + at(' = ', n) + at(' ', Ce(r, ' ')),
    },
    SelectionSet: { leave: ({ selections: e }) => di(e) },
    Field: {
      leave({ alias: e, name: t, arguments: n, directives: r, selectionSet: i }) {
        const s = at('', e, ': ') + t
        let o = s + at('(', Ce(n, ', '), ')')
        return (
          o.length > kz &&
            (o =
              s +
              at(
                `(
`,
                Uh(
                  Ce(
                    n,
                    `
`
                  )
                ),
                `
)`
              )),
          Ce([o, Ce(r, ' '), i], ' ')
        )
      },
    },
    Argument: { leave: ({ name: e, value: t }) => e + ': ' + t },
    FragmentSpread: { leave: ({ name: e, directives: t }) => '...' + e + at(' ', Ce(t, ' ')) },
    InlineFragment: {
      leave: ({ typeCondition: e, directives: t, selectionSet: n }) =>
        Ce(['...', at('on ', e), Ce(t, ' '), n], ' '),
    },
    FragmentDefinition: {
      leave: ({
        name: e,
        typeCondition: t,
        variableDefinitions: n,
        directives: r,
        selectionSet: i,
      }) => `fragment ${e}${at('(', Ce(n, ', '), ')')} on ${t} ${at('', Ce(r, ' '), ' ')}` + i,
    },
    IntValue: { leave: ({ value: e }) => e },
    FloatValue: { leave: ({ value: e }) => e },
    StringValue: { leave: ({ value: e, block: t }) => (t ? fz(e) : wz(e)) },
    BooleanValue: { leave: ({ value: e }) => (e ? 'true' : 'false') },
    NullValue: { leave: () => 'null' },
    EnumValue: { leave: ({ value: e }) => e },
    ListValue: { leave: ({ values: e }) => '[' + Ce(e, ', ') + ']' },
    ObjectValue: { leave: ({ fields: e }) => '{' + Ce(e, ', ') + '}' },
    ObjectField: { leave: ({ name: e, value: t }) => e + ': ' + t },
    Directive: { leave: ({ name: e, arguments: t }) => '@' + e + at('(', Ce(t, ', '), ')') },
    NamedType: { leave: ({ name: e }) => e },
    ListType: { leave: ({ type: e }) => '[' + e + ']' },
    NonNullType: { leave: ({ type: e }) => e + '!' },
    SchemaDefinition: {
      leave: ({ description: e, directives: t, operationTypes: n }) =>
        at(
          '',
          e,
          `
`
        ) + Ce(['schema', Ce(t, ' '), di(n)], ' '),
    },
    OperationTypeDefinition: { leave: ({ operation: e, type: t }) => e + ': ' + t },
    ScalarTypeDefinition: {
      leave: ({ description: e, name: t, directives: n }) =>
        at(
          '',
          e,
          `
`
        ) + Ce(['scalar', t, Ce(n, ' ')], ' '),
    },
    ObjectTypeDefinition: {
      leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) =>
        at(
          '',
          e,
          `
`
        ) + Ce(['type', t, at('implements ', Ce(n, ' & ')), Ce(r, ' '), di(i)], ' '),
    },
    FieldDefinition: {
      leave: ({ description: e, name: t, arguments: n, type: r, directives: i }) =>
        at(
          '',
          e,
          `
`
        ) +
        t +
        (tE(n)
          ? at(
              `(
`,
              Uh(
                Ce(
                  n,
                  `
`
                )
              ),
              `
)`
            )
          : at('(', Ce(n, ', '), ')')) +
        ': ' +
        r +
        at(' ', Ce(i, ' ')),
    },
    InputValueDefinition: {
      leave: ({ description: e, name: t, type: n, defaultValue: r, directives: i }) =>
        at(
          '',
          e,
          `
`
        ) + Ce([t + ': ' + n, at('= ', r), Ce(i, ' ')], ' '),
    },
    InterfaceTypeDefinition: {
      leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) =>
        at(
          '',
          e,
          `
`
        ) + Ce(['interface', t, at('implements ', Ce(n, ' & ')), Ce(r, ' '), di(i)], ' '),
    },
    UnionTypeDefinition: {
      leave: ({ description: e, name: t, directives: n, types: r }) =>
        at(
          '',
          e,
          `
`
        ) + Ce(['union', t, Ce(n, ' '), at('= ', Ce(r, ' | '))], ' '),
    },
    EnumTypeDefinition: {
      leave: ({ description: e, name: t, directives: n, values: r }) =>
        at(
          '',
          e,
          `
`
        ) + Ce(['enum', t, Ce(n, ' '), di(r)], ' '),
    },
    EnumValueDefinition: {
      leave: ({ description: e, name: t, directives: n }) =>
        at(
          '',
          e,
          `
`
        ) + Ce([t, Ce(n, ' ')], ' '),
    },
    InputObjectTypeDefinition: {
      leave: ({ description: e, name: t, directives: n, fields: r }) =>
        at(
          '',
          e,
          `
`
        ) + Ce(['input', t, Ce(n, ' '), di(r)], ' '),
    },
    DirectiveDefinition: {
      leave: ({ description: e, name: t, arguments: n, repeatable: r, locations: i }) =>
        at(
          '',
          e,
          `
`
        ) +
        'directive @' +
        t +
        (tE(n)
          ? at(
              `(
`,
              Uh(
                Ce(
                  n,
                  `
`
                )
              ),
              `
)`
            )
          : at('(', Ce(n, ', '), ')')) +
        (r ? ' repeatable' : '') +
        ' on ' +
        Ce(i, ' | '),
    },
    SchemaExtension: {
      leave: ({ directives: e, operationTypes: t }) =>
        Ce(['extend schema', Ce(e, ' '), di(t)], ' '),
    },
    ScalarTypeExtension: {
      leave: ({ name: e, directives: t }) => Ce(['extend scalar', e, Ce(t, ' ')], ' '),
    },
    ObjectTypeExtension: {
      leave: ({ name: e, interfaces: t, directives: n, fields: r }) =>
        Ce(['extend type', e, at('implements ', Ce(t, ' & ')), Ce(n, ' '), di(r)], ' '),
    },
    InterfaceTypeExtension: {
      leave: ({ name: e, interfaces: t, directives: n, fields: r }) =>
        Ce(['extend interface', e, at('implements ', Ce(t, ' & ')), Ce(n, ' '), di(r)], ' '),
    },
    UnionTypeExtension: {
      leave: ({ name: e, directives: t, types: n }) =>
        Ce(['extend union', e, Ce(t, ' '), at('= ', Ce(n, ' | '))], ' '),
    },
    EnumTypeExtension: {
      leave: ({ name: e, directives: t, values: n }) =>
        Ce(['extend enum', e, Ce(t, ' '), di(n)], ' '),
    },
    InputObjectTypeExtension: {
      leave: ({ name: e, directives: t, fields: n }) =>
        Ce(['extend input', e, Ce(t, ' '), di(n)], ' '),
    },
  }
function Ce(e, t = '') {
  var n
  return (n = e == null ? void 0 : e.filter((r) => r).join(t)) !== null && n !== void 0 ? n : ''
}
function di(e) {
  return at(
    `{
`,
    Uh(
      Ce(
        e,
        `
`
      )
    ),
    `
}`
  )
}
function at(e, t, n = '') {
  return t != null && t !== '' ? e + t + n : ''
}
function Uh(e) {
  return at(
    '  ',
    e.replace(
      /\n/g,
      `
  `
    )
  )
}
function tE(e) {
  var t
  return (t =
    e == null
      ? void 0
      : e.some((n) =>
          n.includes(`
`)
        )) !== null && t !== void 0
    ? t
    : !1
}
var bk = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  Wd = (e, t, n) => (bk(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  Vd = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  Hd = (e, t, n, r) => (bk(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  zh,
  Wh,
  Vh,
  Hh
class Az extends Error {}
class Rz {
  constructor({ url: t, fetch: n = fetch, headers: r = {}, queries: i = {} }) {
    Vd(this, zh, void 0),
      Vd(this, Wh, void 0),
      Vd(this, Vh, void 0),
      Vd(this, Hh, void 0),
      Hd(this, zh, t),
      Hd(this, Wh, i),
      Hd(this, Vh, r),
      Hd(this, Hh, (...s) => n(...s))
  }
  async query(t) {
    const n = await Wd(this, Hh).call(this, Wd(this, zh), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...Wd(this, Vh) },
      body: JSON.stringify({
        query: typeof t.query == 'string' ? String(t.query) : Oz(t.query),
        variables: t.variables,
        extensions: t.extensions,
        operationName: t.operationName,
      }),
    })
    if (!n.ok) throw new Az(`GraphQL request failed: ${n.statusText} (${n.status})`)
    return await n.json()
  }
  async execute(t, n) {
    return this.query({ ...n, query: Wd(this, Wh)[t] })
  }
}
zh = new WeakMap()
Wh = new WeakMap()
Vh = new WeakMap()
Hh = new WeakMap()
var qd = {
  NAME: 'Name',
  DOCUMENT: 'Document',
  OPERATION_DEFINITION: 'OperationDefinition',
  VARIABLE_DEFINITION: 'VariableDefinition',
  SELECTION_SET: 'SelectionSet',
  FIELD: 'Field',
  ARGUMENT: 'Argument',
  FRAGMENT_SPREAD: 'FragmentSpread',
  INLINE_FRAGMENT: 'InlineFragment',
  FRAGMENT_DEFINITION: 'FragmentDefinition',
  VARIABLE: 'Variable',
  INT: 'IntValue',
  FLOAT: 'FloatValue',
  STRING: 'StringValue',
  BOOLEAN: 'BooleanValue',
  NULL: 'NullValue',
  ENUM: 'EnumValue',
  LIST: 'ListValue',
  OBJECT: 'ObjectValue',
  OBJECT_FIELD: 'ObjectField',
  DIRECTIVE: 'Directive',
  NAMED_TYPE: 'NamedType',
  LIST_TYPE: 'ListType',
  NON_NULL_TYPE: 'NonNullType',
}
class Pz extends Error {
  constructor(t, n, r, i, s, o, a) {
    super(t),
      (this.name = 'GraphQLError'),
      (this.message = t),
      s && (this.path = s),
      n && (this.nodes = Array.isArray(n) ? n : [n]),
      r && (this.source = r),
      i && (this.positions = i),
      o && (this.originalError = o)
    var l = a
    if (!l && o) {
      var c = o.extensions
      c && typeof c == 'object' && (l = c)
    }
    this.extensions = l || {}
  }
  toJSON() {
    return { ...this, message: this.message }
  }
  toString() {
    return this.message
  }
  get [Symbol.toStringTag]() {
    return 'GraphQLError'
  }
}
var gt, Le
function tn(e) {
  return new Pz(`Syntax Error: Unexpected token at ${Le} in ${e}`)
}
function Or(e) {
  if (((e.lastIndex = Le), e.test(gt))) return gt.slice(Le, (Le = e.lastIndex))
}
var Kd = / +(?=[^\s])/y
function Iz(e) {
  for (
    var t = e.split(`
`),
      n = '',
      r = 0,
      i = 0,
      s = t.length - 1,
      o = 0;
    o < t.length;
    o++
  )
    (Kd.lastIndex = 0),
      Kd.test(t[o]) && (o && (!r || Kd.lastIndex < r) && (r = Kd.lastIndex), (i = i || o), (s = o))
  for (var a = i; a <= s; a++)
    a !== i &&
      (n += `
`),
      (n += t[a].slice(r).replace(/\\"""/g, '"""'))
  return n
}
function Qe() {
  for (
    var e = 0 | gt.charCodeAt(Le++);
    e === 9 || e === 10 || e === 13 || e === 32 || e === 35 || e === 44 || e === 65279;
    e = 0 | gt.charCodeAt(Le++)
  )
    if (e === 35) for (; (e = gt.charCodeAt(Le++)) !== 10 && e !== 13; );
  Le--
}
var Yn = /[_A-Za-z]\w*/y,
  Tm = new RegExp(
    '(?:(null|true|false)|\\$(' +
      Yn.source +
      ')|(-?\\d+)((?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+)?|("""(?:"""|(?:[\\s\\S]*?[^\\\\])"""))|("(?:"|[^\\r\\n]*?[^\\\\]"))|(' +
      Yn.source +
      '))',
    'y'
  ),
  ao = (function (e) {
    return (
      (e[(e.Const = 1)] = 'Const'),
      (e[(e.Var = 2)] = 'Var'),
      (e[(e.Int = 3)] = 'Int'),
      (e[(e.Float = 4)] = 'Float'),
      (e[(e.BlockString = 5)] = 'BlockString'),
      (e[(e.String = 6)] = 'String'),
      (e[(e.Enum = 7)] = 'Enum'),
      e
    )
  })(ao || {}),
  Dz = /\\/g
function n0(e) {
  var t, n
  if (((Tm.lastIndex = Le), gt.charCodeAt(Le) === 91)) {
    Le++, Qe()
    for (var r = []; gt.charCodeAt(Le) !== 93; ) r.push(n0(e))
    return Le++, Qe(), { kind: 'ListValue', values: r }
  } else if (gt.charCodeAt(Le) === 123) {
    Le++, Qe()
    for (var i = []; gt.charCodeAt(Le) !== 125; ) {
      if ((t = Or(Yn)) == null || (Qe(), gt.charCodeAt(Le++) !== 58)) throw tn('ObjectField')
      Qe(), i.push({ kind: 'ObjectField', name: { kind: 'Name', value: t }, value: n0(e) })
    }
    return Le++, Qe(), { kind: 'ObjectValue', fields: i }
  } else if ((n = Tm.exec(gt)) != null) {
    if (((Le = Tm.lastIndex), Qe(), (t = n[ao.Const]) != null))
      return t === 'null' ? { kind: 'NullValue' } : { kind: 'BooleanValue', value: t === 'true' }
    if ((t = n[ao.Var]) != null) {
      if (e) throw tn('Variable')
      return { kind: 'Variable', name: { kind: 'Name', value: t } }
    } else if ((t = n[ao.Int]) != null) {
      var s
      return (s = n[ao.Float]) != null
        ? { kind: 'FloatValue', value: t + s }
        : { kind: 'IntValue', value: t }
    } else {
      if ((t = n[ao.BlockString]) != null)
        return { kind: 'StringValue', value: Iz(t.slice(3, -3)), block: !0 }
      if ((t = n[ao.String]) != null)
        return {
          kind: 'StringValue',
          value: Dz.test(t) ? JSON.parse(t) : t.slice(1, -1),
          block: !1,
        }
      if ((t = n[ao.Enum]) != null) return { kind: 'EnumValue', value: t }
    }
  }
  throw tn('Value')
}
function xk(e) {
  if (gt.charCodeAt(Le) === 40) {
    var t = []
    Le++, Qe()
    var n
    do {
      if ((n = Or(Yn)) == null || (Qe(), gt.charCodeAt(Le++) !== 58)) throw tn('Argument')
      Qe(), t.push({ kind: 'Argument', name: { kind: 'Name', value: n }, value: n0(e) })
    } while (gt.charCodeAt(Le) !== 41)
    return Le++, Qe(), t
  }
}
function Hl(e) {
  if (gt.charCodeAt(Le) === 64) {
    var t = [],
      n
    do {
      if ((Le++, (n = Or(Yn)) == null)) throw tn('Directive')
      Qe(), t.push({ kind: 'Directive', name: { kind: 'Name', value: n }, arguments: xk(e) })
    } while (gt.charCodeAt(Le) === 64)
    return t
  }
}
function Nz() {
  for (var e, t = 0; gt.charCodeAt(Le) === 91; ) t++, Le++, Qe()
  if ((e = Or(Yn)) == null) throw tn('NamedType')
  Qe()
  var n = { kind: 'NamedType', name: { kind: 'Name', value: e } }
  do
    if ((gt.charCodeAt(Le) === 33 && (Le++, Qe(), (n = { kind: 'NonNullType', type: n })), t)) {
      if (gt.charCodeAt(Le++) !== 93) throw tn('NamedType')
      Qe(), (n = { kind: 'ListType', type: n })
    }
  while (t--)
  return n
}
var Am = new RegExp('(?:(\\.{3})|(' + Yn.source + '))', 'y'),
  Lv = (function (e) {
    return (e[(e.Spread = 1)] = 'Spread'), (e[(e.Name = 2)] = 'Name'), e
  })(Lv || {})
function r0() {
  var e = [],
    t,
    n
  do
    if (((Am.lastIndex = Le), (n = Am.exec(gt)) != null)) {
      if (((Le = Am.lastIndex), n[Lv.Spread] != null)) {
        Qe()
        var r = Or(Yn)
        if (r != null && r !== 'on')
          Qe(),
            e.push({ kind: 'FragmentSpread', name: { kind: 'Name', value: r }, directives: Hl(!1) })
        else {
          if ((Qe(), r === 'on')) {
            if ((r = Or(Yn)) == null) throw tn('NamedType')
            Qe()
          }
          var i = Hl(!1)
          if (gt.charCodeAt(Le++) !== 123) throw tn('InlineFragment')
          Qe(),
            e.push({
              kind: 'InlineFragment',
              typeCondition: r ? { kind: 'NamedType', name: { kind: 'Name', value: r } } : void 0,
              directives: i,
              selectionSet: r0(),
            })
        }
      } else if ((t = n[Lv.Name]) != null) {
        var s = void 0
        if ((Qe(), gt.charCodeAt(Le) === 58)) {
          if ((Le++, Qe(), (s = t), (t = Or(Yn)) == null)) throw tn('Field')
          Qe()
        }
        var o = xk(!1)
        Qe()
        var a = Hl(!1),
          l = void 0
        gt.charCodeAt(Le) === 123 && (Le++, Qe(), (l = r0())),
          e.push({
            kind: 'Field',
            alias: s ? { kind: 'Name', value: s } : void 0,
            name: { kind: 'Name', value: t },
            arguments: o,
            directives: a,
            selectionSet: l,
          })
      }
    } else throw tn('SelectionSet')
  while (gt.charCodeAt(Le) !== 125)
  return Le++, Qe(), { kind: 'SelectionSet', selections: e }
}
function Mz() {
  var e, t
  if ((e = Or(Yn)) == null || (Qe(), Or(Yn) !== 'on') || (Qe(), (t = Or(Yn)) == null))
    throw tn('FragmentDefinition')
  Qe()
  var n = Hl(!1)
  if (gt.charCodeAt(Le++) !== 123) throw tn('FragmentDefinition')
  return (
    Qe(),
    {
      kind: 'FragmentDefinition',
      name: { kind: 'Name', value: e },
      typeCondition: { kind: 'NamedType', name: { kind: 'Name', value: t } },
      directives: n,
      selectionSet: r0(),
    }
  )
}
var jz = /(?:query|mutation|subscription|fragment)/y
function Lz(e) {
  var t, n, r
  if (
    (e &&
      (Qe(),
      (t = Or(Yn)),
      (n = (function () {
        if ((Qe(), gt.charCodeAt(Le) === 40)) {
          var s = []
          Le++, Qe()
          var o
          do {
            if (gt.charCodeAt(Le++) !== 36 || (o = Or(Yn)) == null) throw tn('Variable')
            if ((Qe(), gt.charCodeAt(Le++) !== 58)) throw tn('VariableDefinition')
            Qe()
            var a = Nz(),
              l = void 0
            gt.charCodeAt(Le) === 61 && (Le++, Qe(), (l = n0(!0))),
              Qe(),
              s.push({
                kind: 'VariableDefinition',
                variable: { kind: 'Variable', name: { kind: 'Name', value: o } },
                type: a,
                defaultValue: l,
                directives: Hl(!0),
              })
          } while (gt.charCodeAt(Le) !== 41)
          return Le++, Qe(), s
        }
      })()),
      (r = Hl(!1))),
    gt.charCodeAt(Le) === 123)
  )
    return (
      Le++,
      Qe(),
      {
        kind: 'OperationDefinition',
        operation: e || 'query',
        name: t ? { kind: 'Name', value: t } : void 0,
        variableDefinitions: n,
        directives: r,
        selectionSet: r0(),
      }
    )
}
function $z(e, t) {
  return (
    (gt = typeof e.body == 'string' ? e.body : e),
    (Le = 0),
    (function () {
      var r, i
      Qe()
      var s = []
      do
        if ((r = Or(jz)) === 'fragment') Qe(), s.push(Mz())
        else if ((i = Lz(r)) != null) s.push(i)
        else throw tn('Document')
      while (Le < gt.length)
      return { kind: 'Document', definitions: s }
    })()
  )
}
function Sk() {
  function e(t, n) {
    var r = $z(t).definitions,
      i = new Set()
    for (var s of n || [])
      for (var o of s.definitions)
        o.kind === qd.FRAGMENT_DEFINITION && !i.has(o) && (r.push(o), i.add(o))
    return (
      r[0].kind === qd.FRAGMENT_DEFINITION &&
        r[0].directives &&
        (r[0].directives = r[0].directives.filter((a) => a.name.value !== '_unmask')),
      { kind: qd.DOCUMENT, definitions: r }
    )
  }
  return (
    (e.scalar = function (n, r) {
      return r
    }),
    (e.persisted = function (n, r) {
      return { kind: qd.DOCUMENT, definitions: r ? r.definitions : [], documentId: n }
    }),
    e
  )
}
Sk()
const Fz = Sk()
function Bz(e) {
  if (e.length !== 1) throw new Error('Invalid base64Url character: ' + e)
  const n = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.indexOf(e)
  if (n === -1) throw new Error('Invalid base64Url character: ' + e)
  const r = n.toString(2).padStart(6, '0')
  return Array.from(r).map(Number)
}
function Uz(e) {
  let t = []
  for (let n = 0; n < e.length; n++) {
    const r = e.charAt(n),
      i = Bz(r)
    t = t.concat(i)
  }
  return t
}
function zz(e, t) {
  if (e.length < 2) throw new Error(`Input (s = ${e}) is not tightly packed because s.length < 2`)
  let n = Uz(e)
  const r = t % 4
  if (r !== 0)
    if (r === 1) n = n.slice(2)
    else if (r === 2) n = n.slice(4)
    else throw new Error(`Input (s = ${e}) is not tightly packed because i%4 = 3 (i = ${t}))`)
  const i = (t + e.length - 1) % 4
  if (i !== 3)
    if (i === 2) n = n.slice(0, n.length - 2)
    else if (i === 1) n = n.slice(0, n.length - 4)
    else
      throw new Error(
        `Input (s = ${e}) is not tightly packed because (i + s.length - 1)%4 = 0 (i = ${t}))`
      )
  if (n.length % 8 !== 0) throw new Error('We should never reach here...')
  const s = new Uint8Array(Math.floor(n.length / 8))
  let o = 0
  for (let a = 0; a < n.length; a += 8) {
    const l = n.slice(a, a + 8),
      c = parseInt(l.join(''), 2)
    s[o++] = c
  }
  return new TextDecoder().decode(s)
}
function Wz(e) {
  if (!(e.slice(-1) === '}' || e.slice(-1) === ',')) throw new Error('Invalid claim')
  const t = JSON.parse('{' + e.slice(0, -1) + '}')
  if (Object.keys(t).length !== 1) throw new Error('Invalid claim')
  const n = Object.keys(t)[0]
  return [n, t[n]]
}
function Vz(e, t) {
  const n = zz(e.value, e.indexMod4),
    [r, i] = Wz(n)
  if (r !== t) throw new Error(`Invalid field name: found ${r} expected ${t}`)
  return i
}
const Hz = R.struct('ZkLoginSignature', {
  inputs: R.struct('ZkLoginSignatureInputs', {
    proofPoints: R.struct('ZkLoginSignatureInputsProofPoints', {
      a: R.vector(R.string()),
      b: R.vector(R.vector(R.string())),
      c: R.vector(R.string()),
    }),
    issBase64Details: R.struct('ZkLoginSignatureInputsClaim', {
      value: R.string(),
      indexMod4: R.u8(),
    }),
    headerBase64: R.string(),
    addressSeed: R.string(),
  }),
  maxEpoch: R.u64(),
  userSignature: R.vector(R.u8()),
})
function qz(e) {
  return Hz.parse(typeof e == 'string' ? Gn(e) : e)
}
function Kz(e, t) {
  const n = e.toString(16)
  return $9(n.padStart(t * 2, '0').slice(-t * 2))
}
var Ek = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  Rm = (e, t, n) => (Ek(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  nE = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  Gd = (e, t, n, r) => (Ek(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  fl,
  Cu
class Gz extends yk {
  constructor(t, { client: n } = {}) {
    super(),
      nE(this, fl, void 0),
      nE(this, Cu, void 0),
      Gd(this, Cu, n),
      typeof t == 'string'
        ? Gd(this, fl, Gn(t))
        : t instanceof Uint8Array
        ? Gd(this, fl, t)
        : Gd(this, fl, Uint8Array.from(t))
  }
  equals(t) {
    return super.equals(t)
  }
  toRawBytes() {
    return Rm(this, fl)
  }
  flag() {
    return sd.ZkLogin
  }
  async verify(t, n) {
    throw Error('does not support')
  }
  verifyPersonalMessage(t, n) {
    const r = $v(n)
    return rE({
      address: r.zkLogin.address,
      bytes: Pt(t),
      signature: r.serializedSignature,
      intentScope: 'PERSONAL_MESSAGE',
      client: Rm(this, Cu),
    })
  }
  verifyTransaction(t, n) {
    const r = $v(n)
    return rE({
      address: r.zkLogin.address,
      bytes: Pt(t),
      signature: r.serializedSignature,
      intentScope: 'TRANSACTION_DATA',
      client: Rm(this, Cu),
    })
  }
}
fl = new WeakMap()
Cu = new WeakMap()
function Yz(e, t, n) {
  const r = Kz(e, 32),
    i = new TextEncoder().encode(t),
    s = new Uint8Array(1 + i.length + r.length)
  return s.set([i.length], 0), s.set(i, 1), s.set(r, 1 + i.length), new Gz(s, n)
}
const Qz = Fz(`
	query Zklogin(
		$bytes: Base64!
		$signature: Base64!
		$intentScope: ZkLoginIntentScope!
		$author: SuiAddress!
	) {
		verifyZkloginSignature(
			bytes: $bytes
			signature: $signature
			intentScope: $intentScope
			author: $author
		) {
			success
			errors
		}
	}
`)
async function rE({
  address: e,
  bytes: t,
  signature: n,
  intentScope: r,
  client: i = new Rz({ url: 'https://sui-mainnet.mystenlabs.com/graphql' }),
}) {
  var o, a
  const s = await i.query({
    query: Qz,
    variables: { bytes: t, signature: n, intentScope: r, author: e },
  })
  return (
    ((o = s.data) == null ? void 0 : o.verifyZkloginSignature.success) === !0 &&
    ((a = s.data) == null ? void 0 : a.verifyZkloginSignature.errors.length) === 0
  )
}
function $v(e) {
  const t = typeof e == 'string' ? Gn(e) : e
  if (t[0] !== sd.ZkLogin) throw new Error('Invalid signature scheme')
  const n = t.slice(1),
    { inputs: r, maxEpoch: i, userSignature: s } = qz(n),
    { issBase64Details: o, addressSeed: a } = r,
    l = Vz(o, 'iss'),
    c = Yz(BigInt(a), l),
    u = c.toSuiAddress()
  return {
    serializedSignature: Pt(t),
    signatureScheme: 'ZkLogin',
    zkLogin: {
      inputs: r,
      maxEpoch: i,
      userSignature: s,
      iss: l,
      address: u,
      addressSeed: BigInt(a),
    },
    signature: t,
    publicKey: c.toRawBytes(),
  }
}
function Xz({ signature: e, signatureScheme: t, publicKey: n }) {
  if (!n) throw new Error('`publicKey` is required')
  const r = n.toRawBytes(),
    i = new Uint8Array(1 + e.length + r.length)
  return i.set([sd[t]]), i.set(e, 1), i.set(r, 1 + e.length), Pt(i)
}
function Zz(e) {
  const t = Gn(e),
    n = lz[t[0]]
  switch (n) {
    case 'MultiSig':
      const r = lt.MultiSig.parse(t.slice(1))
      return { serializedSignature: e, signatureScheme: n, multisig: r, bytes: t }
    case 'ZkLogin':
      return $v(e)
    case 'ED25519':
    case 'Secp256k1':
    case 'Secp256r1':
      const i = az[n],
        s = t.slice(1, t.length - i),
        o = t.slice(1 + s.length)
      return { serializedSignature: e, signatureScheme: n, signature: s, publicKey: o, bytes: t }
    default:
      throw new Error('Unsupported signature scheme')
  }
}
class Ck extends Kw {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), O6(t)
    const r = ts(n)
    if (((this.iHash = t.create()), typeof this.iHash.update != 'function'))
      throw new Error('Expected instance of class which extends utils.Hash')
    ;(this.blockLen = this.iHash.blockLen), (this.outputLen = this.iHash.outputLen)
    const i = this.blockLen,
      s = new Uint8Array(i)
    s.set(r.length > i ? t.create().update(r).digest() : r)
    for (let o = 0; o < s.length; o++) s[o] ^= 54
    this.iHash.update(s), (this.oHash = t.create())
    for (let o = 0; o < s.length; o++) s[o] ^= 106
    this.oHash.update(s), s.fill(0)
  }
  update(t) {
    return Ec(this), this.iHash.update(t), this
  }
  digestInto(t) {
    Ec(this),
      ig(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy()
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen)
    return this.digestInto(t), t
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}))
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = s),
      (t.blockLen = o),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    )
  }
  destroy() {
    ;(this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy()
  }
}
const lg = (e, t, n) => new Ck(e, t).update(n).digest()
lg.create = (e, t) => new Ck(e, t)
function Jz(e, t, n, r) {
  O6(e)
  const i = U9({ dkLen: 32, asyncTick: 10 }, r),
    { c: s, dkLen: o, asyncTick: a } = i
  if ((Mo(s), Mo(o), Mo(a), s < 1)) throw new Error('PBKDF2: iterations (c) should be >= 1')
  const l = ts(t),
    c = ts(n),
    u = new Uint8Array(o),
    f = lg.create(e, l),
    d = f._cloneInto().update(c)
  return { c: s, dkLen: o, asyncTick: a, DK: u, PRF: f, PRFSalt: d }
}
function eW(e, t, n, r, i) {
  return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n
}
function tW(e, t, n, r) {
  const { c: i, dkLen: s, DK: o, PRF: a, PRFSalt: l } = Jz(e, t, n, r)
  let c
  const u = new Uint8Array(4),
    f = jh(u),
    d = new Uint8Array(a.outputLen)
  for (let p = 1, h = 0; h < s; p++, h += a.outputLen) {
    const m = o.subarray(h, h + a.outputLen)
    f.setInt32(0, p, !1),
      (c = l._cloneInto(c)).update(u).digestInto(d),
      m.set(d.subarray(0, m.length))
    for (let b = 1; b < i; b++) {
      a._cloneInto(c).update(d).digestInto(d)
      for (let y = 0; y < m.length; y++) m[y] ^= d[y]
    }
  }
  return eW(a, l, o, c, d)
}
function nW(e, t, n, r) {
  if (typeof e.setBigUint64 == 'function') return e.setBigUint64(t, n, r)
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    l = r ? 4 : 0,
    c = r ? 0 : 4
  e.setUint32(t + l, o, r), e.setUint32(t + c, a, r)
}
class rW extends Kw {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = jh(this.buffer))
  }
  update(t) {
    Ec(this)
    const { view: n, buffer: r, blockLen: i } = this
    t = ts(t)
    const s = t.length
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o)
      if (a === i) {
        const l = jh(t)
        for (; i <= s - o; o += i) this.process(l, o)
        continue
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0))
    }
    return (this.length += t.length), this.roundClean(), this
  }
  digestInto(t) {
    Ec(this), k6(t, this), (this.finished = !0)
    const { buffer: n, view: r, blockLen: i, isLE: s } = this
    let { pos: o } = this
    ;(n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0))
    for (let f = o; f < i; f++) n[f] = 0
    nW(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0)
    const a = jh(t),
      l = this.outputLen
    if (l % 4) throw new Error('_sha2: outputLen should be aligned to 32bit')
    const c = l / 4,
      u = this.get()
    if (c > u.length) throw new Error('_sha2: outputLen bigger than state')
    for (let f = 0; f < c; f++) a.setUint32(4 * f, u[f], s)
  }
  digest() {
    const { buffer: t, outputLen: n } = this
    this.digestInto(t)
    const r = t.slice(0, n)
    return this.destroy(), r
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get())
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this
    return (
      (t.length = i), (t.pos = a), (t.finished = s), (t.destroyed = o), i % n && t.buffer.set(r), t
    )
  }
}
const [iW, sW] = (() =>
    je.split(
      [
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817',
      ].map((e) => BigInt(e))
    ))(),
  eo = new Uint32Array(80),
  to = new Uint32Array(80)
class oW extends rW {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209)
  }
  get() {
    const {
      Ah: t,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: s,
      Cl: o,
      Dh: a,
      Dl: l,
      Eh: c,
      El: u,
      Fh: f,
      Fl: d,
      Gh: p,
      Gl: h,
      Hh: m,
      Hl: b,
    } = this
    return [t, n, r, i, s, o, a, l, c, u, f, d, p, h, m, b]
  }
  set(t, n, r, i, s, o, a, l, c, u, f, d, p, h, m, b) {
    ;(this.Ah = t | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = s | 0),
      (this.Cl = o | 0),
      (this.Dh = a | 0),
      (this.Dl = l | 0),
      (this.Eh = c | 0),
      (this.El = u | 0),
      (this.Fh = f | 0),
      (this.Fl = d | 0),
      (this.Gh = p | 0),
      (this.Gl = h | 0),
      (this.Hh = m | 0),
      (this.Hl = b | 0)
  }
  process(t, n) {
    for (let S = 0; S < 16; S++, n += 4) (eo[S] = t.getUint32(n)), (to[S] = t.getUint32((n += 4)))
    for (let S = 16; S < 80; S++) {
      const T = eo[S - 15] | 0,
        A = to[S - 15] | 0,
        I = je.rotrSH(T, A, 1) ^ je.rotrSH(T, A, 8) ^ je.shrSH(T, A, 7),
        k = je.rotrSL(T, A, 1) ^ je.rotrSL(T, A, 8) ^ je.shrSL(T, A, 7),
        D = eo[S - 2] | 0,
        F = to[S - 2] | 0,
        V = je.rotrSH(D, F, 19) ^ je.rotrBH(D, F, 61) ^ je.shrSH(D, F, 6),
        ie = je.rotrSL(D, F, 19) ^ je.rotrBL(D, F, 61) ^ je.shrSL(D, F, 6),
        de = je.add4L(k, ie, to[S - 7], to[S - 16]),
        xe = je.add4H(de, I, V, eo[S - 7], eo[S - 16])
      ;(eo[S] = xe | 0), (to[S] = de | 0)
    }
    let {
      Ah: r,
      Al: i,
      Bh: s,
      Bl: o,
      Ch: a,
      Cl: l,
      Dh: c,
      Dl: u,
      Eh: f,
      El: d,
      Fh: p,
      Fl: h,
      Gh: m,
      Gl: b,
      Hh: y,
      Hl: v,
    } = this
    for (let S = 0; S < 80; S++) {
      const T = je.rotrSH(f, d, 14) ^ je.rotrSH(f, d, 18) ^ je.rotrBH(f, d, 41),
        A = je.rotrSL(f, d, 14) ^ je.rotrSL(f, d, 18) ^ je.rotrBL(f, d, 41),
        I = (f & p) ^ (~f & m),
        k = (d & h) ^ (~d & b),
        D = je.add5L(v, A, k, sW[S], to[S]),
        F = je.add5H(D, y, T, I, iW[S], eo[S]),
        V = D | 0,
        ie = je.rotrSH(r, i, 28) ^ je.rotrBH(r, i, 34) ^ je.rotrBH(r, i, 39),
        de = je.rotrSL(r, i, 28) ^ je.rotrBL(r, i, 34) ^ je.rotrBL(r, i, 39),
        xe = (r & s) ^ (r & a) ^ (s & a),
        we = (i & o) ^ (i & l) ^ (o & l)
      ;(y = m | 0),
        (v = b | 0),
        (m = p | 0),
        (b = h | 0),
        (p = f | 0),
        (h = d | 0),
        ({ h: f, l: d } = je.add(c | 0, u | 0, F | 0, V | 0)),
        (c = a | 0),
        (u = l | 0),
        (a = s | 0),
        (l = o | 0),
        (s = r | 0),
        (o = i | 0)
      const Pe = je.add3L(V, de, we)
      ;(r = je.add3H(Pe, F, ie, xe)), (i = Pe | 0)
    }
    ;({ h: r, l: i } = je.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: s, l: o } = je.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
      ({ h: a, l } = je.add(this.Ch | 0, this.Cl | 0, a | 0, l | 0)),
      ({ h: c, l: u } = je.add(this.Dh | 0, this.Dl | 0, c | 0, u | 0)),
      ({ h: f, l: d } = je.add(this.Eh | 0, this.El | 0, f | 0, d | 0)),
      ({ h: p, l: h } = je.add(this.Fh | 0, this.Fl | 0, p | 0, h | 0)),
      ({ h: m, l: b } = je.add(this.Gh | 0, this.Gl | 0, m | 0, b | 0)),
      ({ h: y, l: v } = je.add(this.Hh | 0, this.Hl | 0, y | 0, v | 0)),
      this.set(r, i, s, o, a, l, c, u, f, d, p, h, m, b, y, v)
  }
  roundClean() {
    eo.fill(0), to.fill(0)
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  }
}
const db = z9(() => new oW())
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */ function _k(
  e
) {
  if (typeof e != 'string') throw new TypeError(`Invalid mnemonic type: ${typeof e}`)
  return e.normalize('NFKD')
}
function aW(e) {
  const t = _k(e),
    n = t.split(' ')
  if (![12, 15, 18, 21, 24].includes(n.length)) throw new Error('Invalid mnemonic')
  return { nfkd: t, words: n }
}
const lW = (e) => _k(`mnemonic${e}`)
function cW(e, t = '') {
  return tW(db, aW(e).nfkd, lW(t), { c: 2048, dkLen: 64 })
}
function iE(e) {
  return !!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(e)
}
function uW(e) {
  return cW(e, '')
}
function fW(e) {
  return Sc(uW(e))
}
var Cf = {}
Object.defineProperty(Cf, '__esModule', { value: !0 })
Cf.bech32m = Fv = Cf.bech32 = void 0
const i0 = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l',
  Ok = {}
for (let e = 0; e < i0.length; e++) {
  const t = i0.charAt(e)
  Ok[t] = e
}
function ql(e) {
  const t = e >> 25
  return (
    ((e & 33554431) << 5) ^
    (-((t >> 0) & 1) & 996825010) ^
    (-((t >> 1) & 1) & 642813549) ^
    (-((t >> 2) & 1) & 513874426) ^
    (-((t >> 3) & 1) & 1027748829) ^
    (-((t >> 4) & 1) & 705979059)
  )
}
function sE(e) {
  let t = 1
  for (let n = 0; n < e.length; ++n) {
    const r = e.charCodeAt(n)
    if (r < 33 || r > 126) return 'Invalid prefix (' + e + ')'
    t = ql(t) ^ (r >> 5)
  }
  t = ql(t)
  for (let n = 0; n < e.length; ++n) {
    const r = e.charCodeAt(n)
    t = ql(t) ^ (r & 31)
  }
  return t
}
function hb(e, t, n, r) {
  let i = 0,
    s = 0
  const o = (1 << n) - 1,
    a = []
  for (let l = 0; l < e.length; ++l)
    for (i = (i << t) | e[l], s += t; s >= n; ) (s -= n), a.push((i >> s) & o)
  if (r) s > 0 && a.push((i << (n - s)) & o)
  else {
    if (s >= t) return 'Excess padding'
    if ((i << (n - s)) & o) return 'Non-zero padding'
  }
  return a
}
function dW(e) {
  return hb(e, 8, 5, !0)
}
function hW(e) {
  const t = hb(e, 5, 8, !1)
  if (Array.isArray(t)) return t
}
function pW(e) {
  const t = hb(e, 5, 8, !1)
  if (Array.isArray(t)) return t
  throw new Error(t)
}
function kk(e) {
  let t
  e === 'bech32' ? (t = 1) : (t = 734539939)
  function n(o, a, l) {
    if (((l = l || 90), o.length + 7 + a.length > l)) throw new TypeError('Exceeds length limit')
    o = o.toLowerCase()
    let c = sE(o)
    if (typeof c == 'string') throw new Error(c)
    let u = o + '1'
    for (let f = 0; f < a.length; ++f) {
      const d = a[f]
      if (d >> 5) throw new Error('Non 5-bit word')
      ;(c = ql(c) ^ d), (u += i0.charAt(d))
    }
    for (let f = 0; f < 6; ++f) c = ql(c)
    c ^= t
    for (let f = 0; f < 6; ++f) {
      const d = (c >> ((5 - f) * 5)) & 31
      u += i0.charAt(d)
    }
    return u
  }
  function r(o, a) {
    if (((a = a || 90), o.length < 8)) return o + ' too short'
    if (o.length > a) return 'Exceeds length limit'
    const l = o.toLowerCase(),
      c = o.toUpperCase()
    if (o !== l && o !== c) return 'Mixed-case string ' + o
    o = l
    const u = o.lastIndexOf('1')
    if (u === -1) return 'No separator character for ' + o
    if (u === 0) return 'Missing prefix for ' + o
    const f = o.slice(0, u),
      d = o.slice(u + 1)
    if (d.length < 6) return 'Data too short'
    let p = sE(f)
    if (typeof p == 'string') return p
    const h = []
    for (let m = 0; m < d.length; ++m) {
      const b = d.charAt(m),
        y = Ok[b]
      if (y === void 0) return 'Unknown character ' + b
      ;(p = ql(p) ^ y), !(m + 6 >= d.length) && h.push(y)
    }
    return p !== t ? 'Invalid checksum for ' + o : { prefix: f, words: h }
  }
  function i(o, a) {
    const l = r(o, a)
    if (typeof l == 'object') return l
  }
  function s(o, a) {
    const l = r(o, a)
    if (typeof l == 'object') return l
    throw new Error(l)
  }
  return { decodeUnsafe: i, decode: s, encode: n, toWords: dW, fromWordsUnsafe: hW, fromWords: pW }
}
var Fv = (Cf.bech32 = kk('bech32'))
Cf.bech32m = kk('bech32m')
const qh = 32,
  gW = 'suiprivkey'
class mW {
  async signWithIntent(t, n) {
    const r = gk(n, t),
      i = Gp(r, { dkLen: 32 })
    return {
      signature: Xz({
        signature: await this.sign(i),
        signatureScheme: this.getKeyScheme(),
        publicKey: this.getPublicKey(),
      }),
      bytes: Pt(t),
    }
  }
  async signTransaction(t) {
    return this.signWithIntent(t, 'TransactionData')
  }
  async signPersonalMessage(t) {
    const { signature: n } = await this.signWithIntent(
      R.vector(R.u8()).serialize(t).toBytes(),
      'PersonalMessage'
    )
    return { bytes: Pt(t), signature: n }
  }
  toSuiAddress() {
    return this.getPublicKey().toSuiAddress()
  }
}
class yW extends mW {}
function vW(e, t) {
  if (e.length !== qh) throw new Error('Invalid bytes length')
  const n = sd[t],
    r = new Uint8Array(e.length + 1)
  return r.set([n]), r.set(e, 1), Fv.encode(gW, Fv.toWords(r))
}
function wW(e) {
  throw new Error(
    'Could not dynamically require "' +
      e +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
  )
}
var Tk = { exports: {} }
const bW = {},
  xW = Object.freeze(
    Object.defineProperty({ __proto__: null, default: bW }, Symbol.toStringTag, { value: 'Module' })
  ),
  SW = a4(xW)
;(function (e) {
  ;(function (t) {
    var n = function (x) {
        var C,
          _ = new Float64Array(16)
        if (x) for (C = 0; C < x.length; C++) _[C] = x[C]
        return _
      },
      r = function () {
        throw new Error('no PRNG')
      },
      i = new Uint8Array(16),
      s = new Uint8Array(32)
    s[0] = 9
    var o = n(),
      a = n([1]),
      l = n([56129, 1]),
      c = n([
        30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139,
        11119, 27886, 20995,
      ]),
      u = n([
        61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239,
        55772, 9222,
      ]),
      f = n([
        54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502,
        52590, 14035, 8553,
      ]),
      d = n([
        26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
        26214, 26214, 26214,
      ]),
      p = n([
        41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099,
        20417, 9344, 11139,
      ])
    function h(x, C, _, g) {
      ;(x[C] = (_ >> 24) & 255),
        (x[C + 1] = (_ >> 16) & 255),
        (x[C + 2] = (_ >> 8) & 255),
        (x[C + 3] = _ & 255),
        (x[C + 4] = (g >> 24) & 255),
        (x[C + 5] = (g >> 16) & 255),
        (x[C + 6] = (g >> 8) & 255),
        (x[C + 7] = g & 255)
    }
    function m(x, C, _, g, O) {
      var N,
        L = 0
      for (N = 0; N < O; N++) L |= x[C + N] ^ _[g + N]
      return (1 & ((L - 1) >>> 8)) - 1
    }
    function b(x, C, _, g) {
      return m(x, C, _, g, 16)
    }
    function y(x, C, _, g) {
      return m(x, C, _, g, 32)
    }
    function v(x, C, _, g) {
      for (
        var O = (g[0] & 255) | ((g[1] & 255) << 8) | ((g[2] & 255) << 16) | ((g[3] & 255) << 24),
          N = (_[0] & 255) | ((_[1] & 255) << 8) | ((_[2] & 255) << 16) | ((_[3] & 255) << 24),
          L = (_[4] & 255) | ((_[5] & 255) << 8) | ((_[6] & 255) << 16) | ((_[7] & 255) << 24),
          q = (_[8] & 255) | ((_[9] & 255) << 8) | ((_[10] & 255) << 16) | ((_[11] & 255) << 24),
          X = (_[12] & 255) | ((_[13] & 255) << 8) | ((_[14] & 255) << 16) | ((_[15] & 255) << 24),
          ye = (g[4] & 255) | ((g[5] & 255) << 8) | ((g[6] & 255) << 16) | ((g[7] & 255) << 24),
          ae = (C[0] & 255) | ((C[1] & 255) << 8) | ((C[2] & 255) << 16) | ((C[3] & 255) << 24),
          et = (C[4] & 255) | ((C[5] & 255) << 8) | ((C[6] & 255) << 16) | ((C[7] & 255) << 24),
          ce = (C[8] & 255) | ((C[9] & 255) << 8) | ((C[10] & 255) << 16) | ((C[11] & 255) << 24),
          $e = (C[12] & 255) | ((C[13] & 255) << 8) | ((C[14] & 255) << 16) | ((C[15] & 255) << 24),
          Be = (g[8] & 255) | ((g[9] & 255) << 8) | ((g[10] & 255) << 16) | ((g[11] & 255) << 24),
          ze = (_[16] & 255) | ((_[17] & 255) << 8) | ((_[18] & 255) << 16) | ((_[19] & 255) << 24),
          ue = (_[20] & 255) | ((_[21] & 255) << 8) | ((_[22] & 255) << 16) | ((_[23] & 255) << 24),
          Oe = (_[24] & 255) | ((_[25] & 255) << 8) | ((_[26] & 255) << 16) | ((_[27] & 255) << 24),
          Ne = (_[28] & 255) | ((_[29] & 255) << 8) | ((_[30] & 255) << 16) | ((_[31] & 255) << 24),
          Se = (g[12] & 255) | ((g[13] & 255) << 8) | ((g[14] & 255) << 16) | ((g[15] & 255) << 24),
          me = O,
          Re = N,
          ge = L,
          Ee = q,
          ke = X,
          he = ye,
          B = ae,
          U = et,
          Q = ce,
          G = $e,
          Y = Be,
          J = ze,
          Fe = ue,
          Ke = Oe,
          Je = Ne,
          Ge = Se,
          P,
          st = 0;
        st < 20;
        st += 2
      )
        (P = (me + Fe) | 0),
          (ke ^= (P << 7) | (P >>> (32 - 7))),
          (P = (ke + me) | 0),
          (Q ^= (P << 9) | (P >>> (32 - 9))),
          (P = (Q + ke) | 0),
          (Fe ^= (P << 13) | (P >>> (32 - 13))),
          (P = (Fe + Q) | 0),
          (me ^= (P << 18) | (P >>> (32 - 18))),
          (P = (he + Re) | 0),
          (G ^= (P << 7) | (P >>> (32 - 7))),
          (P = (G + he) | 0),
          (Ke ^= (P << 9) | (P >>> (32 - 9))),
          (P = (Ke + G) | 0),
          (Re ^= (P << 13) | (P >>> (32 - 13))),
          (P = (Re + Ke) | 0),
          (he ^= (P << 18) | (P >>> (32 - 18))),
          (P = (Y + B) | 0),
          (Je ^= (P << 7) | (P >>> (32 - 7))),
          (P = (Je + Y) | 0),
          (ge ^= (P << 9) | (P >>> (32 - 9))),
          (P = (ge + Je) | 0),
          (B ^= (P << 13) | (P >>> (32 - 13))),
          (P = (B + ge) | 0),
          (Y ^= (P << 18) | (P >>> (32 - 18))),
          (P = (Ge + J) | 0),
          (Ee ^= (P << 7) | (P >>> (32 - 7))),
          (P = (Ee + Ge) | 0),
          (U ^= (P << 9) | (P >>> (32 - 9))),
          (P = (U + Ee) | 0),
          (J ^= (P << 13) | (P >>> (32 - 13))),
          (P = (J + U) | 0),
          (Ge ^= (P << 18) | (P >>> (32 - 18))),
          (P = (me + Ee) | 0),
          (Re ^= (P << 7) | (P >>> (32 - 7))),
          (P = (Re + me) | 0),
          (ge ^= (P << 9) | (P >>> (32 - 9))),
          (P = (ge + Re) | 0),
          (Ee ^= (P << 13) | (P >>> (32 - 13))),
          (P = (Ee + ge) | 0),
          (me ^= (P << 18) | (P >>> (32 - 18))),
          (P = (he + ke) | 0),
          (B ^= (P << 7) | (P >>> (32 - 7))),
          (P = (B + he) | 0),
          (U ^= (P << 9) | (P >>> (32 - 9))),
          (P = (U + B) | 0),
          (ke ^= (P << 13) | (P >>> (32 - 13))),
          (P = (ke + U) | 0),
          (he ^= (P << 18) | (P >>> (32 - 18))),
          (P = (Y + G) | 0),
          (J ^= (P << 7) | (P >>> (32 - 7))),
          (P = (J + Y) | 0),
          (Q ^= (P << 9) | (P >>> (32 - 9))),
          (P = (Q + J) | 0),
          (G ^= (P << 13) | (P >>> (32 - 13))),
          (P = (G + Q) | 0),
          (Y ^= (P << 18) | (P >>> (32 - 18))),
          (P = (Ge + Je) | 0),
          (Fe ^= (P << 7) | (P >>> (32 - 7))),
          (P = (Fe + Ge) | 0),
          (Ke ^= (P << 9) | (P >>> (32 - 9))),
          (P = (Ke + Fe) | 0),
          (Je ^= (P << 13) | (P >>> (32 - 13))),
          (P = (Je + Ke) | 0),
          (Ge ^= (P << 18) | (P >>> (32 - 18)))
      ;(me = (me + O) | 0),
        (Re = (Re + N) | 0),
        (ge = (ge + L) | 0),
        (Ee = (Ee + q) | 0),
        (ke = (ke + X) | 0),
        (he = (he + ye) | 0),
        (B = (B + ae) | 0),
        (U = (U + et) | 0),
        (Q = (Q + ce) | 0),
        (G = (G + $e) | 0),
        (Y = (Y + Be) | 0),
        (J = (J + ze) | 0),
        (Fe = (Fe + ue) | 0),
        (Ke = (Ke + Oe) | 0),
        (Je = (Je + Ne) | 0),
        (Ge = (Ge + Se) | 0),
        (x[0] = (me >>> 0) & 255),
        (x[1] = (me >>> 8) & 255),
        (x[2] = (me >>> 16) & 255),
        (x[3] = (me >>> 24) & 255),
        (x[4] = (Re >>> 0) & 255),
        (x[5] = (Re >>> 8) & 255),
        (x[6] = (Re >>> 16) & 255),
        (x[7] = (Re >>> 24) & 255),
        (x[8] = (ge >>> 0) & 255),
        (x[9] = (ge >>> 8) & 255),
        (x[10] = (ge >>> 16) & 255),
        (x[11] = (ge >>> 24) & 255),
        (x[12] = (Ee >>> 0) & 255),
        (x[13] = (Ee >>> 8) & 255),
        (x[14] = (Ee >>> 16) & 255),
        (x[15] = (Ee >>> 24) & 255),
        (x[16] = (ke >>> 0) & 255),
        (x[17] = (ke >>> 8) & 255),
        (x[18] = (ke >>> 16) & 255),
        (x[19] = (ke >>> 24) & 255),
        (x[20] = (he >>> 0) & 255),
        (x[21] = (he >>> 8) & 255),
        (x[22] = (he >>> 16) & 255),
        (x[23] = (he >>> 24) & 255),
        (x[24] = (B >>> 0) & 255),
        (x[25] = (B >>> 8) & 255),
        (x[26] = (B >>> 16) & 255),
        (x[27] = (B >>> 24) & 255),
        (x[28] = (U >>> 0) & 255),
        (x[29] = (U >>> 8) & 255),
        (x[30] = (U >>> 16) & 255),
        (x[31] = (U >>> 24) & 255),
        (x[32] = (Q >>> 0) & 255),
        (x[33] = (Q >>> 8) & 255),
        (x[34] = (Q >>> 16) & 255),
        (x[35] = (Q >>> 24) & 255),
        (x[36] = (G >>> 0) & 255),
        (x[37] = (G >>> 8) & 255),
        (x[38] = (G >>> 16) & 255),
        (x[39] = (G >>> 24) & 255),
        (x[40] = (Y >>> 0) & 255),
        (x[41] = (Y >>> 8) & 255),
        (x[42] = (Y >>> 16) & 255),
        (x[43] = (Y >>> 24) & 255),
        (x[44] = (J >>> 0) & 255),
        (x[45] = (J >>> 8) & 255),
        (x[46] = (J >>> 16) & 255),
        (x[47] = (J >>> 24) & 255),
        (x[48] = (Fe >>> 0) & 255),
        (x[49] = (Fe >>> 8) & 255),
        (x[50] = (Fe >>> 16) & 255),
        (x[51] = (Fe >>> 24) & 255),
        (x[52] = (Ke >>> 0) & 255),
        (x[53] = (Ke >>> 8) & 255),
        (x[54] = (Ke >>> 16) & 255),
        (x[55] = (Ke >>> 24) & 255),
        (x[56] = (Je >>> 0) & 255),
        (x[57] = (Je >>> 8) & 255),
        (x[58] = (Je >>> 16) & 255),
        (x[59] = (Je >>> 24) & 255),
        (x[60] = (Ge >>> 0) & 255),
        (x[61] = (Ge >>> 8) & 255),
        (x[62] = (Ge >>> 16) & 255),
        (x[63] = (Ge >>> 24) & 255)
    }
    function S(x, C, _, g) {
      for (
        var O = (g[0] & 255) | ((g[1] & 255) << 8) | ((g[2] & 255) << 16) | ((g[3] & 255) << 24),
          N = (_[0] & 255) | ((_[1] & 255) << 8) | ((_[2] & 255) << 16) | ((_[3] & 255) << 24),
          L = (_[4] & 255) | ((_[5] & 255) << 8) | ((_[6] & 255) << 16) | ((_[7] & 255) << 24),
          q = (_[8] & 255) | ((_[9] & 255) << 8) | ((_[10] & 255) << 16) | ((_[11] & 255) << 24),
          X = (_[12] & 255) | ((_[13] & 255) << 8) | ((_[14] & 255) << 16) | ((_[15] & 255) << 24),
          ye = (g[4] & 255) | ((g[5] & 255) << 8) | ((g[6] & 255) << 16) | ((g[7] & 255) << 24),
          ae = (C[0] & 255) | ((C[1] & 255) << 8) | ((C[2] & 255) << 16) | ((C[3] & 255) << 24),
          et = (C[4] & 255) | ((C[5] & 255) << 8) | ((C[6] & 255) << 16) | ((C[7] & 255) << 24),
          ce = (C[8] & 255) | ((C[9] & 255) << 8) | ((C[10] & 255) << 16) | ((C[11] & 255) << 24),
          $e = (C[12] & 255) | ((C[13] & 255) << 8) | ((C[14] & 255) << 16) | ((C[15] & 255) << 24),
          Be = (g[8] & 255) | ((g[9] & 255) << 8) | ((g[10] & 255) << 16) | ((g[11] & 255) << 24),
          ze = (_[16] & 255) | ((_[17] & 255) << 8) | ((_[18] & 255) << 16) | ((_[19] & 255) << 24),
          ue = (_[20] & 255) | ((_[21] & 255) << 8) | ((_[22] & 255) << 16) | ((_[23] & 255) << 24),
          Oe = (_[24] & 255) | ((_[25] & 255) << 8) | ((_[26] & 255) << 16) | ((_[27] & 255) << 24),
          Ne = (_[28] & 255) | ((_[29] & 255) << 8) | ((_[30] & 255) << 16) | ((_[31] & 255) << 24),
          Se = (g[12] & 255) | ((g[13] & 255) << 8) | ((g[14] & 255) << 16) | ((g[15] & 255) << 24),
          me = O,
          Re = N,
          ge = L,
          Ee = q,
          ke = X,
          he = ye,
          B = ae,
          U = et,
          Q = ce,
          G = $e,
          Y = Be,
          J = ze,
          Fe = ue,
          Ke = Oe,
          Je = Ne,
          Ge = Se,
          P,
          st = 0;
        st < 20;
        st += 2
      )
        (P = (me + Fe) | 0),
          (ke ^= (P << 7) | (P >>> (32 - 7))),
          (P = (ke + me) | 0),
          (Q ^= (P << 9) | (P >>> (32 - 9))),
          (P = (Q + ke) | 0),
          (Fe ^= (P << 13) | (P >>> (32 - 13))),
          (P = (Fe + Q) | 0),
          (me ^= (P << 18) | (P >>> (32 - 18))),
          (P = (he + Re) | 0),
          (G ^= (P << 7) | (P >>> (32 - 7))),
          (P = (G + he) | 0),
          (Ke ^= (P << 9) | (P >>> (32 - 9))),
          (P = (Ke + G) | 0),
          (Re ^= (P << 13) | (P >>> (32 - 13))),
          (P = (Re + Ke) | 0),
          (he ^= (P << 18) | (P >>> (32 - 18))),
          (P = (Y + B) | 0),
          (Je ^= (P << 7) | (P >>> (32 - 7))),
          (P = (Je + Y) | 0),
          (ge ^= (P << 9) | (P >>> (32 - 9))),
          (P = (ge + Je) | 0),
          (B ^= (P << 13) | (P >>> (32 - 13))),
          (P = (B + ge) | 0),
          (Y ^= (P << 18) | (P >>> (32 - 18))),
          (P = (Ge + J) | 0),
          (Ee ^= (P << 7) | (P >>> (32 - 7))),
          (P = (Ee + Ge) | 0),
          (U ^= (P << 9) | (P >>> (32 - 9))),
          (P = (U + Ee) | 0),
          (J ^= (P << 13) | (P >>> (32 - 13))),
          (P = (J + U) | 0),
          (Ge ^= (P << 18) | (P >>> (32 - 18))),
          (P = (me + Ee) | 0),
          (Re ^= (P << 7) | (P >>> (32 - 7))),
          (P = (Re + me) | 0),
          (ge ^= (P << 9) | (P >>> (32 - 9))),
          (P = (ge + Re) | 0),
          (Ee ^= (P << 13) | (P >>> (32 - 13))),
          (P = (Ee + ge) | 0),
          (me ^= (P << 18) | (P >>> (32 - 18))),
          (P = (he + ke) | 0),
          (B ^= (P << 7) | (P >>> (32 - 7))),
          (P = (B + he) | 0),
          (U ^= (P << 9) | (P >>> (32 - 9))),
          (P = (U + B) | 0),
          (ke ^= (P << 13) | (P >>> (32 - 13))),
          (P = (ke + U) | 0),
          (he ^= (P << 18) | (P >>> (32 - 18))),
          (P = (Y + G) | 0),
          (J ^= (P << 7) | (P >>> (32 - 7))),
          (P = (J + Y) | 0),
          (Q ^= (P << 9) | (P >>> (32 - 9))),
          (P = (Q + J) | 0),
          (G ^= (P << 13) | (P >>> (32 - 13))),
          (P = (G + Q) | 0),
          (Y ^= (P << 18) | (P >>> (32 - 18))),
          (P = (Ge + Je) | 0),
          (Fe ^= (P << 7) | (P >>> (32 - 7))),
          (P = (Fe + Ge) | 0),
          (Ke ^= (P << 9) | (P >>> (32 - 9))),
          (P = (Ke + Fe) | 0),
          (Je ^= (P << 13) | (P >>> (32 - 13))),
          (P = (Je + Ke) | 0),
          (Ge ^= (P << 18) | (P >>> (32 - 18)))
      ;(x[0] = (me >>> 0) & 255),
        (x[1] = (me >>> 8) & 255),
        (x[2] = (me >>> 16) & 255),
        (x[3] = (me >>> 24) & 255),
        (x[4] = (he >>> 0) & 255),
        (x[5] = (he >>> 8) & 255),
        (x[6] = (he >>> 16) & 255),
        (x[7] = (he >>> 24) & 255),
        (x[8] = (Y >>> 0) & 255),
        (x[9] = (Y >>> 8) & 255),
        (x[10] = (Y >>> 16) & 255),
        (x[11] = (Y >>> 24) & 255),
        (x[12] = (Ge >>> 0) & 255),
        (x[13] = (Ge >>> 8) & 255),
        (x[14] = (Ge >>> 16) & 255),
        (x[15] = (Ge >>> 24) & 255),
        (x[16] = (B >>> 0) & 255),
        (x[17] = (B >>> 8) & 255),
        (x[18] = (B >>> 16) & 255),
        (x[19] = (B >>> 24) & 255),
        (x[20] = (U >>> 0) & 255),
        (x[21] = (U >>> 8) & 255),
        (x[22] = (U >>> 16) & 255),
        (x[23] = (U >>> 24) & 255),
        (x[24] = (Q >>> 0) & 255),
        (x[25] = (Q >>> 8) & 255),
        (x[26] = (Q >>> 16) & 255),
        (x[27] = (Q >>> 24) & 255),
        (x[28] = (G >>> 0) & 255),
        (x[29] = (G >>> 8) & 255),
        (x[30] = (G >>> 16) & 255),
        (x[31] = (G >>> 24) & 255)
    }
    function T(x, C, _, g) {
      v(x, C, _, g)
    }
    function A(x, C, _, g) {
      S(x, C, _, g)
    }
    var I = new Uint8Array([
      101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107,
    ])
    function k(x, C, _, g, O, N, L) {
      var q = new Uint8Array(16),
        X = new Uint8Array(64),
        ye,
        ae
      for (ae = 0; ae < 16; ae++) q[ae] = 0
      for (ae = 0; ae < 8; ae++) q[ae] = N[ae]
      for (; O >= 64; ) {
        for (T(X, q, L, I), ae = 0; ae < 64; ae++) x[C + ae] = _[g + ae] ^ X[ae]
        for (ye = 1, ae = 8; ae < 16; ae++)
          (ye = (ye + (q[ae] & 255)) | 0), (q[ae] = ye & 255), (ye >>>= 8)
        ;(O -= 64), (C += 64), (g += 64)
      }
      if (O > 0) for (T(X, q, L, I), ae = 0; ae < O; ae++) x[C + ae] = _[g + ae] ^ X[ae]
      return 0
    }
    function D(x, C, _, g, O) {
      var N = new Uint8Array(16),
        L = new Uint8Array(64),
        q,
        X
      for (X = 0; X < 16; X++) N[X] = 0
      for (X = 0; X < 8; X++) N[X] = g[X]
      for (; _ >= 64; ) {
        for (T(L, N, O, I), X = 0; X < 64; X++) x[C + X] = L[X]
        for (q = 1, X = 8; X < 16; X++) (q = (q + (N[X] & 255)) | 0), (N[X] = q & 255), (q >>>= 8)
        ;(_ -= 64), (C += 64)
      }
      if (_ > 0) for (T(L, N, O, I), X = 0; X < _; X++) x[C + X] = L[X]
      return 0
    }
    function F(x, C, _, g, O) {
      var N = new Uint8Array(32)
      A(N, g, O, I)
      for (var L = new Uint8Array(8), q = 0; q < 8; q++) L[q] = g[q + 16]
      return D(x, C, _, L, N)
    }
    function V(x, C, _, g, O, N, L) {
      var q = new Uint8Array(32)
      A(q, N, L, I)
      for (var X = new Uint8Array(8), ye = 0; ye < 8; ye++) X[ye] = N[ye + 16]
      return k(x, C, _, g, O, X, q)
    }
    var ie = function (x) {
      ;(this.buffer = new Uint8Array(16)),
        (this.r = new Uint16Array(10)),
        (this.h = new Uint16Array(10)),
        (this.pad = new Uint16Array(8)),
        (this.leftover = 0),
        (this.fin = 0)
      var C, _, g, O, N, L, q, X
      ;(C = (x[0] & 255) | ((x[1] & 255) << 8)),
        (this.r[0] = C & 8191),
        (_ = (x[2] & 255) | ((x[3] & 255) << 8)),
        (this.r[1] = ((C >>> 13) | (_ << 3)) & 8191),
        (g = (x[4] & 255) | ((x[5] & 255) << 8)),
        (this.r[2] = ((_ >>> 10) | (g << 6)) & 7939),
        (O = (x[6] & 255) | ((x[7] & 255) << 8)),
        (this.r[3] = ((g >>> 7) | (O << 9)) & 8191),
        (N = (x[8] & 255) | ((x[9] & 255) << 8)),
        (this.r[4] = ((O >>> 4) | (N << 12)) & 255),
        (this.r[5] = (N >>> 1) & 8190),
        (L = (x[10] & 255) | ((x[11] & 255) << 8)),
        (this.r[6] = ((N >>> 14) | (L << 2)) & 8191),
        (q = (x[12] & 255) | ((x[13] & 255) << 8)),
        (this.r[7] = ((L >>> 11) | (q << 5)) & 8065),
        (X = (x[14] & 255) | ((x[15] & 255) << 8)),
        (this.r[8] = ((q >>> 8) | (X << 8)) & 8191),
        (this.r[9] = (X >>> 5) & 127),
        (this.pad[0] = (x[16] & 255) | ((x[17] & 255) << 8)),
        (this.pad[1] = (x[18] & 255) | ((x[19] & 255) << 8)),
        (this.pad[2] = (x[20] & 255) | ((x[21] & 255) << 8)),
        (this.pad[3] = (x[22] & 255) | ((x[23] & 255) << 8)),
        (this.pad[4] = (x[24] & 255) | ((x[25] & 255) << 8)),
        (this.pad[5] = (x[26] & 255) | ((x[27] & 255) << 8)),
        (this.pad[6] = (x[28] & 255) | ((x[29] & 255) << 8)),
        (this.pad[7] = (x[30] & 255) | ((x[31] & 255) << 8))
    }
    ;(ie.prototype.blocks = function (x, C, _) {
      for (
        var g = this.fin ? 0 : 2048,
          O,
          N,
          L,
          q,
          X,
          ye,
          ae,
          et,
          ce,
          $e,
          Be,
          ze,
          ue,
          Oe,
          Ne,
          Se,
          me,
          Re,
          ge,
          Ee = this.h[0],
          ke = this.h[1],
          he = this.h[2],
          B = this.h[3],
          U = this.h[4],
          Q = this.h[5],
          G = this.h[6],
          Y = this.h[7],
          J = this.h[8],
          Fe = this.h[9],
          Ke = this.r[0],
          Je = this.r[1],
          Ge = this.r[2],
          P = this.r[3],
          st = this.r[4],
          ht = this.r[5],
          pt = this.r[6],
          tt = this.r[7],
          ft = this.r[8],
          dt = this.r[9];
        _ >= 16;

      )
        (O = (x[C + 0] & 255) | ((x[C + 1] & 255) << 8)),
          (Ee += O & 8191),
          (N = (x[C + 2] & 255) | ((x[C + 3] & 255) << 8)),
          (ke += ((O >>> 13) | (N << 3)) & 8191),
          (L = (x[C + 4] & 255) | ((x[C + 5] & 255) << 8)),
          (he += ((N >>> 10) | (L << 6)) & 8191),
          (q = (x[C + 6] & 255) | ((x[C + 7] & 255) << 8)),
          (B += ((L >>> 7) | (q << 9)) & 8191),
          (X = (x[C + 8] & 255) | ((x[C + 9] & 255) << 8)),
          (U += ((q >>> 4) | (X << 12)) & 8191),
          (Q += (X >>> 1) & 8191),
          (ye = (x[C + 10] & 255) | ((x[C + 11] & 255) << 8)),
          (G += ((X >>> 14) | (ye << 2)) & 8191),
          (ae = (x[C + 12] & 255) | ((x[C + 13] & 255) << 8)),
          (Y += ((ye >>> 11) | (ae << 5)) & 8191),
          (et = (x[C + 14] & 255) | ((x[C + 15] & 255) << 8)),
          (J += ((ae >>> 8) | (et << 8)) & 8191),
          (Fe += (et >>> 5) | g),
          (ce = 0),
          ($e = ce),
          ($e += Ee * Ke),
          ($e += ke * (5 * dt)),
          ($e += he * (5 * ft)),
          ($e += B * (5 * tt)),
          ($e += U * (5 * pt)),
          (ce = $e >>> 13),
          ($e &= 8191),
          ($e += Q * (5 * ht)),
          ($e += G * (5 * st)),
          ($e += Y * (5 * P)),
          ($e += J * (5 * Ge)),
          ($e += Fe * (5 * Je)),
          (ce += $e >>> 13),
          ($e &= 8191),
          (Be = ce),
          (Be += Ee * Je),
          (Be += ke * Ke),
          (Be += he * (5 * dt)),
          (Be += B * (5 * ft)),
          (Be += U * (5 * tt)),
          (ce = Be >>> 13),
          (Be &= 8191),
          (Be += Q * (5 * pt)),
          (Be += G * (5 * ht)),
          (Be += Y * (5 * st)),
          (Be += J * (5 * P)),
          (Be += Fe * (5 * Ge)),
          (ce += Be >>> 13),
          (Be &= 8191),
          (ze = ce),
          (ze += Ee * Ge),
          (ze += ke * Je),
          (ze += he * Ke),
          (ze += B * (5 * dt)),
          (ze += U * (5 * ft)),
          (ce = ze >>> 13),
          (ze &= 8191),
          (ze += Q * (5 * tt)),
          (ze += G * (5 * pt)),
          (ze += Y * (5 * ht)),
          (ze += J * (5 * st)),
          (ze += Fe * (5 * P)),
          (ce += ze >>> 13),
          (ze &= 8191),
          (ue = ce),
          (ue += Ee * P),
          (ue += ke * Ge),
          (ue += he * Je),
          (ue += B * Ke),
          (ue += U * (5 * dt)),
          (ce = ue >>> 13),
          (ue &= 8191),
          (ue += Q * (5 * ft)),
          (ue += G * (5 * tt)),
          (ue += Y * (5 * pt)),
          (ue += J * (5 * ht)),
          (ue += Fe * (5 * st)),
          (ce += ue >>> 13),
          (ue &= 8191),
          (Oe = ce),
          (Oe += Ee * st),
          (Oe += ke * P),
          (Oe += he * Ge),
          (Oe += B * Je),
          (Oe += U * Ke),
          (ce = Oe >>> 13),
          (Oe &= 8191),
          (Oe += Q * (5 * dt)),
          (Oe += G * (5 * ft)),
          (Oe += Y * (5 * tt)),
          (Oe += J * (5 * pt)),
          (Oe += Fe * (5 * ht)),
          (ce += Oe >>> 13),
          (Oe &= 8191),
          (Ne = ce),
          (Ne += Ee * ht),
          (Ne += ke * st),
          (Ne += he * P),
          (Ne += B * Ge),
          (Ne += U * Je),
          (ce = Ne >>> 13),
          (Ne &= 8191),
          (Ne += Q * Ke),
          (Ne += G * (5 * dt)),
          (Ne += Y * (5 * ft)),
          (Ne += J * (5 * tt)),
          (Ne += Fe * (5 * pt)),
          (ce += Ne >>> 13),
          (Ne &= 8191),
          (Se = ce),
          (Se += Ee * pt),
          (Se += ke * ht),
          (Se += he * st),
          (Se += B * P),
          (Se += U * Ge),
          (ce = Se >>> 13),
          (Se &= 8191),
          (Se += Q * Je),
          (Se += G * Ke),
          (Se += Y * (5 * dt)),
          (Se += J * (5 * ft)),
          (Se += Fe * (5 * tt)),
          (ce += Se >>> 13),
          (Se &= 8191),
          (me = ce),
          (me += Ee * tt),
          (me += ke * pt),
          (me += he * ht),
          (me += B * st),
          (me += U * P),
          (ce = me >>> 13),
          (me &= 8191),
          (me += Q * Ge),
          (me += G * Je),
          (me += Y * Ke),
          (me += J * (5 * dt)),
          (me += Fe * (5 * ft)),
          (ce += me >>> 13),
          (me &= 8191),
          (Re = ce),
          (Re += Ee * ft),
          (Re += ke * tt),
          (Re += he * pt),
          (Re += B * ht),
          (Re += U * st),
          (ce = Re >>> 13),
          (Re &= 8191),
          (Re += Q * P),
          (Re += G * Ge),
          (Re += Y * Je),
          (Re += J * Ke),
          (Re += Fe * (5 * dt)),
          (ce += Re >>> 13),
          (Re &= 8191),
          (ge = ce),
          (ge += Ee * dt),
          (ge += ke * ft),
          (ge += he * tt),
          (ge += B * pt),
          (ge += U * ht),
          (ce = ge >>> 13),
          (ge &= 8191),
          (ge += Q * st),
          (ge += G * P),
          (ge += Y * Ge),
          (ge += J * Je),
          (ge += Fe * Ke),
          (ce += ge >>> 13),
          (ge &= 8191),
          (ce = ((ce << 2) + ce) | 0),
          (ce = (ce + $e) | 0),
          ($e = ce & 8191),
          (ce = ce >>> 13),
          (Be += ce),
          (Ee = $e),
          (ke = Be),
          (he = ze),
          (B = ue),
          (U = Oe),
          (Q = Ne),
          (G = Se),
          (Y = me),
          (J = Re),
          (Fe = ge),
          (C += 16),
          (_ -= 16)
      ;(this.h[0] = Ee),
        (this.h[1] = ke),
        (this.h[2] = he),
        (this.h[3] = B),
        (this.h[4] = U),
        (this.h[5] = Q),
        (this.h[6] = G),
        (this.h[7] = Y),
        (this.h[8] = J),
        (this.h[9] = Fe)
    }),
      (ie.prototype.finish = function (x, C) {
        var _ = new Uint16Array(10),
          g,
          O,
          N,
          L
        if (this.leftover) {
          for (L = this.leftover, this.buffer[L++] = 1; L < 16; L++) this.buffer[L] = 0
          ;(this.fin = 1), this.blocks(this.buffer, 0, 16)
        }
        for (g = this.h[1] >>> 13, this.h[1] &= 8191, L = 2; L < 10; L++)
          (this.h[L] += g), (g = this.h[L] >>> 13), (this.h[L] &= 8191)
        for (
          this.h[0] += g * 5,
            g = this.h[0] >>> 13,
            this.h[0] &= 8191,
            this.h[1] += g,
            g = this.h[1] >>> 13,
            this.h[1] &= 8191,
            this.h[2] += g,
            _[0] = this.h[0] + 5,
            g = _[0] >>> 13,
            _[0] &= 8191,
            L = 1;
          L < 10;
          L++
        )
          (_[L] = this.h[L] + g), (g = _[L] >>> 13), (_[L] &= 8191)
        for (_[9] -= 8192, O = (g ^ 1) - 1, L = 0; L < 10; L++) _[L] &= O
        for (O = ~O, L = 0; L < 10; L++) this.h[L] = (this.h[L] & O) | _[L]
        for (
          this.h[0] = (this.h[0] | (this.h[1] << 13)) & 65535,
            this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 65535,
            this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 65535,
            this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 65535,
            this.h[4] = ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 65535,
            this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 65535,
            this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 65535,
            this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 65535,
            N = this.h[0] + this.pad[0],
            this.h[0] = N & 65535,
            L = 1;
          L < 8;
          L++
        )
          (N = (((this.h[L] + this.pad[L]) | 0) + (N >>> 16)) | 0), (this.h[L] = N & 65535)
        ;(x[C + 0] = (this.h[0] >>> 0) & 255),
          (x[C + 1] = (this.h[0] >>> 8) & 255),
          (x[C + 2] = (this.h[1] >>> 0) & 255),
          (x[C + 3] = (this.h[1] >>> 8) & 255),
          (x[C + 4] = (this.h[2] >>> 0) & 255),
          (x[C + 5] = (this.h[2] >>> 8) & 255),
          (x[C + 6] = (this.h[3] >>> 0) & 255),
          (x[C + 7] = (this.h[3] >>> 8) & 255),
          (x[C + 8] = (this.h[4] >>> 0) & 255),
          (x[C + 9] = (this.h[4] >>> 8) & 255),
          (x[C + 10] = (this.h[5] >>> 0) & 255),
          (x[C + 11] = (this.h[5] >>> 8) & 255),
          (x[C + 12] = (this.h[6] >>> 0) & 255),
          (x[C + 13] = (this.h[6] >>> 8) & 255),
          (x[C + 14] = (this.h[7] >>> 0) & 255),
          (x[C + 15] = (this.h[7] >>> 8) & 255)
      }),
      (ie.prototype.update = function (x, C, _) {
        var g, O
        if (this.leftover) {
          for (O = 16 - this.leftover, O > _ && (O = _), g = 0; g < O; g++)
            this.buffer[this.leftover + g] = x[C + g]
          if (((_ -= O), (C += O), (this.leftover += O), this.leftover < 16)) return
          this.blocks(this.buffer, 0, 16), (this.leftover = 0)
        }
        if ((_ >= 16 && ((O = _ - (_ % 16)), this.blocks(x, C, O), (C += O), (_ -= O)), _)) {
          for (g = 0; g < _; g++) this.buffer[this.leftover + g] = x[C + g]
          this.leftover += _
        }
      })
    function de(x, C, _, g, O, N) {
      var L = new ie(N)
      return L.update(_, g, O), L.finish(x, C), 0
    }
    function xe(x, C, _, g, O, N) {
      var L = new Uint8Array(16)
      return de(L, 0, _, g, O, N), b(x, C, L, 0)
    }
    function we(x, C, _, g, O) {
      var N
      if (_ < 32) return -1
      for (V(x, 0, C, 0, _, g, O), de(x, 16, x, 32, _ - 32, x), N = 0; N < 16; N++) x[N] = 0
      return 0
    }
    function Pe(x, C, _, g, O) {
      var N,
        L = new Uint8Array(32)
      if (_ < 32 || (F(L, 0, 32, g, O), xe(C, 16, C, 32, _ - 32, L) !== 0)) return -1
      for (V(x, 0, C, 0, _, g, O), N = 0; N < 32; N++) x[N] = 0
      return 0
    }
    function We(x, C) {
      var _
      for (_ = 0; _ < 16; _++) x[_] = C[_] | 0
    }
    function Me(x) {
      var C,
        _,
        g = 1
      for (C = 0; C < 16; C++)
        (_ = x[C] + g + 65535), (g = Math.floor(_ / 65536)), (x[C] = _ - g * 65536)
      x[0] += g - 1 + 37 * (g - 1)
    }
    function K(x, C, _) {
      for (var g, O = ~(_ - 1), N = 0; N < 16; N++)
        (g = O & (x[N] ^ C[N])), (x[N] ^= g), (C[N] ^= g)
    }
    function H(x, C) {
      var _,
        g,
        O,
        N = n(),
        L = n()
      for (_ = 0; _ < 16; _++) L[_] = C[_]
      for (Me(L), Me(L), Me(L), g = 0; g < 2; g++) {
        for (N[0] = L[0] - 65517, _ = 1; _ < 15; _++)
          (N[_] = L[_] - 65535 - ((N[_ - 1] >> 16) & 1)), (N[_ - 1] &= 65535)
        ;(N[15] = L[15] - 32767 - ((N[14] >> 16) & 1)),
          (O = (N[15] >> 16) & 1),
          (N[14] &= 65535),
          K(L, N, 1 - O)
      }
      for (_ = 0; _ < 16; _++) (x[2 * _] = L[_] & 255), (x[2 * _ + 1] = L[_] >> 8)
    }
    function oe(x, C) {
      var _ = new Uint8Array(32),
        g = new Uint8Array(32)
      return H(_, x), H(g, C), y(_, 0, g, 0)
    }
    function Ae(x) {
      var C = new Uint8Array(32)
      return H(C, x), C[0] & 1
    }
    function Ie(x, C) {
      var _
      for (_ = 0; _ < 16; _++) x[_] = C[2 * _] + (C[2 * _ + 1] << 8)
      x[15] &= 32767
    }
    function fe(x, C, _) {
      for (var g = 0; g < 16; g++) x[g] = C[g] + _[g]
    }
    function _e(x, C, _) {
      for (var g = 0; g < 16; g++) x[g] = C[g] - _[g]
    }
    function re(x, C, _) {
      var g,
        O,
        N = 0,
        L = 0,
        q = 0,
        X = 0,
        ye = 0,
        ae = 0,
        et = 0,
        ce = 0,
        $e = 0,
        Be = 0,
        ze = 0,
        ue = 0,
        Oe = 0,
        Ne = 0,
        Se = 0,
        me = 0,
        Re = 0,
        ge = 0,
        Ee = 0,
        ke = 0,
        he = 0,
        B = 0,
        U = 0,
        Q = 0,
        G = 0,
        Y = 0,
        J = 0,
        Fe = 0,
        Ke = 0,
        Je = 0,
        Ge = 0,
        P = _[0],
        st = _[1],
        ht = _[2],
        pt = _[3],
        tt = _[4],
        ft = _[5],
        dt = _[6],
        Xt = _[7],
        Ot = _[8],
        Vt = _[9],
        Ht = _[10],
        qt = _[11],
        an = _[12],
        An = _[13],
        Rn = _[14],
        Pn = _[15]
      ;(g = C[0]),
        (N += g * P),
        (L += g * st),
        (q += g * ht),
        (X += g * pt),
        (ye += g * tt),
        (ae += g * ft),
        (et += g * dt),
        (ce += g * Xt),
        ($e += g * Ot),
        (Be += g * Vt),
        (ze += g * Ht),
        (ue += g * qt),
        (Oe += g * an),
        (Ne += g * An),
        (Se += g * Rn),
        (me += g * Pn),
        (g = C[1]),
        (L += g * P),
        (q += g * st),
        (X += g * ht),
        (ye += g * pt),
        (ae += g * tt),
        (et += g * ft),
        (ce += g * dt),
        ($e += g * Xt),
        (Be += g * Ot),
        (ze += g * Vt),
        (ue += g * Ht),
        (Oe += g * qt),
        (Ne += g * an),
        (Se += g * An),
        (me += g * Rn),
        (Re += g * Pn),
        (g = C[2]),
        (q += g * P),
        (X += g * st),
        (ye += g * ht),
        (ae += g * pt),
        (et += g * tt),
        (ce += g * ft),
        ($e += g * dt),
        (Be += g * Xt),
        (ze += g * Ot),
        (ue += g * Vt),
        (Oe += g * Ht),
        (Ne += g * qt),
        (Se += g * an),
        (me += g * An),
        (Re += g * Rn),
        (ge += g * Pn),
        (g = C[3]),
        (X += g * P),
        (ye += g * st),
        (ae += g * ht),
        (et += g * pt),
        (ce += g * tt),
        ($e += g * ft),
        (Be += g * dt),
        (ze += g * Xt),
        (ue += g * Ot),
        (Oe += g * Vt),
        (Ne += g * Ht),
        (Se += g * qt),
        (me += g * an),
        (Re += g * An),
        (ge += g * Rn),
        (Ee += g * Pn),
        (g = C[4]),
        (ye += g * P),
        (ae += g * st),
        (et += g * ht),
        (ce += g * pt),
        ($e += g * tt),
        (Be += g * ft),
        (ze += g * dt),
        (ue += g * Xt),
        (Oe += g * Ot),
        (Ne += g * Vt),
        (Se += g * Ht),
        (me += g * qt),
        (Re += g * an),
        (ge += g * An),
        (Ee += g * Rn),
        (ke += g * Pn),
        (g = C[5]),
        (ae += g * P),
        (et += g * st),
        (ce += g * ht),
        ($e += g * pt),
        (Be += g * tt),
        (ze += g * ft),
        (ue += g * dt),
        (Oe += g * Xt),
        (Ne += g * Ot),
        (Se += g * Vt),
        (me += g * Ht),
        (Re += g * qt),
        (ge += g * an),
        (Ee += g * An),
        (ke += g * Rn),
        (he += g * Pn),
        (g = C[6]),
        (et += g * P),
        (ce += g * st),
        ($e += g * ht),
        (Be += g * pt),
        (ze += g * tt),
        (ue += g * ft),
        (Oe += g * dt),
        (Ne += g * Xt),
        (Se += g * Ot),
        (me += g * Vt),
        (Re += g * Ht),
        (ge += g * qt),
        (Ee += g * an),
        (ke += g * An),
        (he += g * Rn),
        (B += g * Pn),
        (g = C[7]),
        (ce += g * P),
        ($e += g * st),
        (Be += g * ht),
        (ze += g * pt),
        (ue += g * tt),
        (Oe += g * ft),
        (Ne += g * dt),
        (Se += g * Xt),
        (me += g * Ot),
        (Re += g * Vt),
        (ge += g * Ht),
        (Ee += g * qt),
        (ke += g * an),
        (he += g * An),
        (B += g * Rn),
        (U += g * Pn),
        (g = C[8]),
        ($e += g * P),
        (Be += g * st),
        (ze += g * ht),
        (ue += g * pt),
        (Oe += g * tt),
        (Ne += g * ft),
        (Se += g * dt),
        (me += g * Xt),
        (Re += g * Ot),
        (ge += g * Vt),
        (Ee += g * Ht),
        (ke += g * qt),
        (he += g * an),
        (B += g * An),
        (U += g * Rn),
        (Q += g * Pn),
        (g = C[9]),
        (Be += g * P),
        (ze += g * st),
        (ue += g * ht),
        (Oe += g * pt),
        (Ne += g * tt),
        (Se += g * ft),
        (me += g * dt),
        (Re += g * Xt),
        (ge += g * Ot),
        (Ee += g * Vt),
        (ke += g * Ht),
        (he += g * qt),
        (B += g * an),
        (U += g * An),
        (Q += g * Rn),
        (G += g * Pn),
        (g = C[10]),
        (ze += g * P),
        (ue += g * st),
        (Oe += g * ht),
        (Ne += g * pt),
        (Se += g * tt),
        (me += g * ft),
        (Re += g * dt),
        (ge += g * Xt),
        (Ee += g * Ot),
        (ke += g * Vt),
        (he += g * Ht),
        (B += g * qt),
        (U += g * an),
        (Q += g * An),
        (G += g * Rn),
        (Y += g * Pn),
        (g = C[11]),
        (ue += g * P),
        (Oe += g * st),
        (Ne += g * ht),
        (Se += g * pt),
        (me += g * tt),
        (Re += g * ft),
        (ge += g * dt),
        (Ee += g * Xt),
        (ke += g * Ot),
        (he += g * Vt),
        (B += g * Ht),
        (U += g * qt),
        (Q += g * an),
        (G += g * An),
        (Y += g * Rn),
        (J += g * Pn),
        (g = C[12]),
        (Oe += g * P),
        (Ne += g * st),
        (Se += g * ht),
        (me += g * pt),
        (Re += g * tt),
        (ge += g * ft),
        (Ee += g * dt),
        (ke += g * Xt),
        (he += g * Ot),
        (B += g * Vt),
        (U += g * Ht),
        (Q += g * qt),
        (G += g * an),
        (Y += g * An),
        (J += g * Rn),
        (Fe += g * Pn),
        (g = C[13]),
        (Ne += g * P),
        (Se += g * st),
        (me += g * ht),
        (Re += g * pt),
        (ge += g * tt),
        (Ee += g * ft),
        (ke += g * dt),
        (he += g * Xt),
        (B += g * Ot),
        (U += g * Vt),
        (Q += g * Ht),
        (G += g * qt),
        (Y += g * an),
        (J += g * An),
        (Fe += g * Rn),
        (Ke += g * Pn),
        (g = C[14]),
        (Se += g * P),
        (me += g * st),
        (Re += g * ht),
        (ge += g * pt),
        (Ee += g * tt),
        (ke += g * ft),
        (he += g * dt),
        (B += g * Xt),
        (U += g * Ot),
        (Q += g * Vt),
        (G += g * Ht),
        (Y += g * qt),
        (J += g * an),
        (Fe += g * An),
        (Ke += g * Rn),
        (Je += g * Pn),
        (g = C[15]),
        (me += g * P),
        (Re += g * st),
        (ge += g * ht),
        (Ee += g * pt),
        (ke += g * tt),
        (he += g * ft),
        (B += g * dt),
        (U += g * Xt),
        (Q += g * Ot),
        (G += g * Vt),
        (Y += g * Ht),
        (J += g * qt),
        (Fe += g * an),
        (Ke += g * An),
        (Je += g * Rn),
        (Ge += g * Pn),
        (N += 38 * Re),
        (L += 38 * ge),
        (q += 38 * Ee),
        (X += 38 * ke),
        (ye += 38 * he),
        (ae += 38 * B),
        (et += 38 * U),
        (ce += 38 * Q),
        ($e += 38 * G),
        (Be += 38 * Y),
        (ze += 38 * J),
        (ue += 38 * Fe),
        (Oe += 38 * Ke),
        (Ne += 38 * Je),
        (Se += 38 * Ge),
        (O = 1),
        (g = N + O + 65535),
        (O = Math.floor(g / 65536)),
        (N = g - O * 65536),
        (g = L + O + 65535),
        (O = Math.floor(g / 65536)),
        (L = g - O * 65536),
        (g = q + O + 65535),
        (O = Math.floor(g / 65536)),
        (q = g - O * 65536),
        (g = X + O + 65535),
        (O = Math.floor(g / 65536)),
        (X = g - O * 65536),
        (g = ye + O + 65535),
        (O = Math.floor(g / 65536)),
        (ye = g - O * 65536),
        (g = ae + O + 65535),
        (O = Math.floor(g / 65536)),
        (ae = g - O * 65536),
        (g = et + O + 65535),
        (O = Math.floor(g / 65536)),
        (et = g - O * 65536),
        (g = ce + O + 65535),
        (O = Math.floor(g / 65536)),
        (ce = g - O * 65536),
        (g = $e + O + 65535),
        (O = Math.floor(g / 65536)),
        ($e = g - O * 65536),
        (g = Be + O + 65535),
        (O = Math.floor(g / 65536)),
        (Be = g - O * 65536),
        (g = ze + O + 65535),
        (O = Math.floor(g / 65536)),
        (ze = g - O * 65536),
        (g = ue + O + 65535),
        (O = Math.floor(g / 65536)),
        (ue = g - O * 65536),
        (g = Oe + O + 65535),
        (O = Math.floor(g / 65536)),
        (Oe = g - O * 65536),
        (g = Ne + O + 65535),
        (O = Math.floor(g / 65536)),
        (Ne = g - O * 65536),
        (g = Se + O + 65535),
        (O = Math.floor(g / 65536)),
        (Se = g - O * 65536),
        (g = me + O + 65535),
        (O = Math.floor(g / 65536)),
        (me = g - O * 65536),
        (N += O - 1 + 37 * (O - 1)),
        (O = 1),
        (g = N + O + 65535),
        (O = Math.floor(g / 65536)),
        (N = g - O * 65536),
        (g = L + O + 65535),
        (O = Math.floor(g / 65536)),
        (L = g - O * 65536),
        (g = q + O + 65535),
        (O = Math.floor(g / 65536)),
        (q = g - O * 65536),
        (g = X + O + 65535),
        (O = Math.floor(g / 65536)),
        (X = g - O * 65536),
        (g = ye + O + 65535),
        (O = Math.floor(g / 65536)),
        (ye = g - O * 65536),
        (g = ae + O + 65535),
        (O = Math.floor(g / 65536)),
        (ae = g - O * 65536),
        (g = et + O + 65535),
        (O = Math.floor(g / 65536)),
        (et = g - O * 65536),
        (g = ce + O + 65535),
        (O = Math.floor(g / 65536)),
        (ce = g - O * 65536),
        (g = $e + O + 65535),
        (O = Math.floor(g / 65536)),
        ($e = g - O * 65536),
        (g = Be + O + 65535),
        (O = Math.floor(g / 65536)),
        (Be = g - O * 65536),
        (g = ze + O + 65535),
        (O = Math.floor(g / 65536)),
        (ze = g - O * 65536),
        (g = ue + O + 65535),
        (O = Math.floor(g / 65536)),
        (ue = g - O * 65536),
        (g = Oe + O + 65535),
        (O = Math.floor(g / 65536)),
        (Oe = g - O * 65536),
        (g = Ne + O + 65535),
        (O = Math.floor(g / 65536)),
        (Ne = g - O * 65536),
        (g = Se + O + 65535),
        (O = Math.floor(g / 65536)),
        (Se = g - O * 65536),
        (g = me + O + 65535),
        (O = Math.floor(g / 65536)),
        (me = g - O * 65536),
        (N += O - 1 + 37 * (O - 1)),
        (x[0] = N),
        (x[1] = L),
        (x[2] = q),
        (x[3] = X),
        (x[4] = ye),
        (x[5] = ae),
        (x[6] = et),
        (x[7] = ce),
        (x[8] = $e),
        (x[9] = Be),
        (x[10] = ze),
        (x[11] = ue),
        (x[12] = Oe),
        (x[13] = Ne),
        (x[14] = Se),
        (x[15] = me)
    }
    function Z(x, C) {
      re(x, C, C)
    }
    function it(x, C) {
      var _ = n(),
        g
      for (g = 0; g < 16; g++) _[g] = C[g]
      for (g = 253; g >= 0; g--) Z(_, _), g !== 2 && g !== 4 && re(_, _, C)
      for (g = 0; g < 16; g++) x[g] = _[g]
    }
    function wt(x, C) {
      var _ = n(),
        g
      for (g = 0; g < 16; g++) _[g] = C[g]
      for (g = 250; g >= 0; g--) Z(_, _), g !== 1 && re(_, _, C)
      for (g = 0; g < 16; g++) x[g] = _[g]
    }
    function Ze(x, C, _) {
      var g = new Uint8Array(32),
        O = new Float64Array(80),
        N,
        L,
        q = n(),
        X = n(),
        ye = n(),
        ae = n(),
        et = n(),
        ce = n()
      for (L = 0; L < 31; L++) g[L] = C[L]
      for (g[31] = (C[31] & 127) | 64, g[0] &= 248, Ie(O, _), L = 0; L < 16; L++)
        (X[L] = O[L]), (ae[L] = q[L] = ye[L] = 0)
      for (q[0] = ae[0] = 1, L = 254; L >= 0; --L)
        (N = (g[L >>> 3] >>> (L & 7)) & 1),
          K(q, X, N),
          K(ye, ae, N),
          fe(et, q, ye),
          _e(q, q, ye),
          fe(ye, X, ae),
          _e(X, X, ae),
          Z(ae, et),
          Z(ce, q),
          re(q, ye, q),
          re(ye, X, et),
          fe(et, q, ye),
          _e(q, q, ye),
          Z(X, q),
          _e(ye, ae, ce),
          re(q, ye, l),
          fe(q, q, ae),
          re(ye, ye, q),
          re(q, ae, ce),
          re(ae, X, O),
          Z(X, et),
          K(q, X, N),
          K(ye, ae, N)
      for (L = 0; L < 16; L++)
        (O[L + 16] = q[L]), (O[L + 32] = ye[L]), (O[L + 48] = X[L]), (O[L + 64] = ae[L])
      var $e = O.subarray(32),
        Be = O.subarray(16)
      return it($e, $e), re(Be, Be, $e), H(x, Be), 0
    }
    function _t(x, C) {
      return Ze(x, C, s)
    }
    function gn(x, C) {
      return r(C, 32), _t(x, C)
    }
    function bt(x, C, _) {
      var g = new Uint8Array(32)
      return Ze(g, _, C), A(x, i, g, I)
    }
    var Jn = we,
      hr = Pe
    function si(x, C, _, g, O, N) {
      var L = new Uint8Array(32)
      return bt(L, O, N), Jn(x, C, _, g, L)
    }
    function Tn(x, C, _, g, O, N) {
      var L = new Uint8Array(32)
      return bt(L, O, N), hr(x, C, _, g, L)
    }
    var Vs = [
      1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548,
      961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560,
      3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
      1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868,
      3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933,
      770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
      2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956,
      3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936,
      666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
      1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627,
      2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008,
      3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
      430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280,
      958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899,
      1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
      2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427,
      3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992,
      116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
      685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676,
      1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
    ]
    function ls(x, C, _, g) {
      for (
        var O = new Int32Array(16),
          N = new Int32Array(16),
          L,
          q,
          X,
          ye,
          ae,
          et,
          ce,
          $e,
          Be,
          ze,
          ue,
          Oe,
          Ne,
          Se,
          me,
          Re,
          ge,
          Ee,
          ke,
          he,
          B,
          U,
          Q,
          G,
          Y,
          J,
          Fe = x[0],
          Ke = x[1],
          Je = x[2],
          Ge = x[3],
          P = x[4],
          st = x[5],
          ht = x[6],
          pt = x[7],
          tt = C[0],
          ft = C[1],
          dt = C[2],
          Xt = C[3],
          Ot = C[4],
          Vt = C[5],
          Ht = C[6],
          qt = C[7],
          an = 0;
        g >= 128;

      ) {
        for (ke = 0; ke < 16; ke++)
          (he = 8 * ke + an),
            (O[ke] = (_[he + 0] << 24) | (_[he + 1] << 16) | (_[he + 2] << 8) | _[he + 3]),
            (N[ke] = (_[he + 4] << 24) | (_[he + 5] << 16) | (_[he + 6] << 8) | _[he + 7])
        for (ke = 0; ke < 80; ke++)
          if (
            ((L = Fe),
            (q = Ke),
            (X = Je),
            (ye = Ge),
            (ae = P),
            (et = st),
            (ce = ht),
            ($e = pt),
            (Be = tt),
            (ze = ft),
            (ue = dt),
            (Oe = Xt),
            (Ne = Ot),
            (Se = Vt),
            (me = Ht),
            (Re = qt),
            (B = pt),
            (U = qt),
            (Q = U & 65535),
            (G = U >>> 16),
            (Y = B & 65535),
            (J = B >>> 16),
            (B =
              ((P >>> 14) | (Ot << (32 - 14))) ^
              ((P >>> 18) | (Ot << (32 - 18))) ^
              ((Ot >>> (41 - 32)) | (P << (32 - (41 - 32))))),
            (U =
              ((Ot >>> 14) | (P << (32 - 14))) ^
              ((Ot >>> 18) | (P << (32 - 18))) ^
              ((P >>> (41 - 32)) | (Ot << (32 - (41 - 32))))),
            (Q += U & 65535),
            (G += U >>> 16),
            (Y += B & 65535),
            (J += B >>> 16),
            (B = (P & st) ^ (~P & ht)),
            (U = (Ot & Vt) ^ (~Ot & Ht)),
            (Q += U & 65535),
            (G += U >>> 16),
            (Y += B & 65535),
            (J += B >>> 16),
            (B = Vs[ke * 2]),
            (U = Vs[ke * 2 + 1]),
            (Q += U & 65535),
            (G += U >>> 16),
            (Y += B & 65535),
            (J += B >>> 16),
            (B = O[ke % 16]),
            (U = N[ke % 16]),
            (Q += U & 65535),
            (G += U >>> 16),
            (Y += B & 65535),
            (J += B >>> 16),
            (G += Q >>> 16),
            (Y += G >>> 16),
            (J += Y >>> 16),
            (ge = (Y & 65535) | (J << 16)),
            (Ee = (Q & 65535) | (G << 16)),
            (B = ge),
            (U = Ee),
            (Q = U & 65535),
            (G = U >>> 16),
            (Y = B & 65535),
            (J = B >>> 16),
            (B =
              ((Fe >>> 28) | (tt << (32 - 28))) ^
              ((tt >>> (34 - 32)) | (Fe << (32 - (34 - 32)))) ^
              ((tt >>> (39 - 32)) | (Fe << (32 - (39 - 32))))),
            (U =
              ((tt >>> 28) | (Fe << (32 - 28))) ^
              ((Fe >>> (34 - 32)) | (tt << (32 - (34 - 32)))) ^
              ((Fe >>> (39 - 32)) | (tt << (32 - (39 - 32))))),
            (Q += U & 65535),
            (G += U >>> 16),
            (Y += B & 65535),
            (J += B >>> 16),
            (B = (Fe & Ke) ^ (Fe & Je) ^ (Ke & Je)),
            (U = (tt & ft) ^ (tt & dt) ^ (ft & dt)),
            (Q += U & 65535),
            (G += U >>> 16),
            (Y += B & 65535),
            (J += B >>> 16),
            (G += Q >>> 16),
            (Y += G >>> 16),
            (J += Y >>> 16),
            ($e = (Y & 65535) | (J << 16)),
            (Re = (Q & 65535) | (G << 16)),
            (B = ye),
            (U = Oe),
            (Q = U & 65535),
            (G = U >>> 16),
            (Y = B & 65535),
            (J = B >>> 16),
            (B = ge),
            (U = Ee),
            (Q += U & 65535),
            (G += U >>> 16),
            (Y += B & 65535),
            (J += B >>> 16),
            (G += Q >>> 16),
            (Y += G >>> 16),
            (J += Y >>> 16),
            (ye = (Y & 65535) | (J << 16)),
            (Oe = (Q & 65535) | (G << 16)),
            (Ke = L),
            (Je = q),
            (Ge = X),
            (P = ye),
            (st = ae),
            (ht = et),
            (pt = ce),
            (Fe = $e),
            (ft = Be),
            (dt = ze),
            (Xt = ue),
            (Ot = Oe),
            (Vt = Ne),
            (Ht = Se),
            (qt = me),
            (tt = Re),
            ke % 16 === 15)
          )
            for (he = 0; he < 16; he++)
              (B = O[he]),
                (U = N[he]),
                (Q = U & 65535),
                (G = U >>> 16),
                (Y = B & 65535),
                (J = B >>> 16),
                (B = O[(he + 9) % 16]),
                (U = N[(he + 9) % 16]),
                (Q += U & 65535),
                (G += U >>> 16),
                (Y += B & 65535),
                (J += B >>> 16),
                (ge = O[(he + 1) % 16]),
                (Ee = N[(he + 1) % 16]),
                (B =
                  ((ge >>> 1) | (Ee << (32 - 1))) ^ ((ge >>> 8) | (Ee << (32 - 8))) ^ (ge >>> 7)),
                (U =
                  ((Ee >>> 1) | (ge << (32 - 1))) ^
                  ((Ee >>> 8) | (ge << (32 - 8))) ^
                  ((Ee >>> 7) | (ge << (32 - 7)))),
                (Q += U & 65535),
                (G += U >>> 16),
                (Y += B & 65535),
                (J += B >>> 16),
                (ge = O[(he + 14) % 16]),
                (Ee = N[(he + 14) % 16]),
                (B =
                  ((ge >>> 19) | (Ee << (32 - 19))) ^
                  ((Ee >>> (61 - 32)) | (ge << (32 - (61 - 32)))) ^
                  (ge >>> 6)),
                (U =
                  ((Ee >>> 19) | (ge << (32 - 19))) ^
                  ((ge >>> (61 - 32)) | (Ee << (32 - (61 - 32)))) ^
                  ((Ee >>> 6) | (ge << (32 - 6)))),
                (Q += U & 65535),
                (G += U >>> 16),
                (Y += B & 65535),
                (J += B >>> 16),
                (G += Q >>> 16),
                (Y += G >>> 16),
                (J += Y >>> 16),
                (O[he] = (Y & 65535) | (J << 16)),
                (N[he] = (Q & 65535) | (G << 16))
        ;(B = Fe),
          (U = tt),
          (Q = U & 65535),
          (G = U >>> 16),
          (Y = B & 65535),
          (J = B >>> 16),
          (B = x[0]),
          (U = C[0]),
          (Q += U & 65535),
          (G += U >>> 16),
          (Y += B & 65535),
          (J += B >>> 16),
          (G += Q >>> 16),
          (Y += G >>> 16),
          (J += Y >>> 16),
          (x[0] = Fe = (Y & 65535) | (J << 16)),
          (C[0] = tt = (Q & 65535) | (G << 16)),
          (B = Ke),
          (U = ft),
          (Q = U & 65535),
          (G = U >>> 16),
          (Y = B & 65535),
          (J = B >>> 16),
          (B = x[1]),
          (U = C[1]),
          (Q += U & 65535),
          (G += U >>> 16),
          (Y += B & 65535),
          (J += B >>> 16),
          (G += Q >>> 16),
          (Y += G >>> 16),
          (J += Y >>> 16),
          (x[1] = Ke = (Y & 65535) | (J << 16)),
          (C[1] = ft = (Q & 65535) | (G << 16)),
          (B = Je),
          (U = dt),
          (Q = U & 65535),
          (G = U >>> 16),
          (Y = B & 65535),
          (J = B >>> 16),
          (B = x[2]),
          (U = C[2]),
          (Q += U & 65535),
          (G += U >>> 16),
          (Y += B & 65535),
          (J += B >>> 16),
          (G += Q >>> 16),
          (Y += G >>> 16),
          (J += Y >>> 16),
          (x[2] = Je = (Y & 65535) | (J << 16)),
          (C[2] = dt = (Q & 65535) | (G << 16)),
          (B = Ge),
          (U = Xt),
          (Q = U & 65535),
          (G = U >>> 16),
          (Y = B & 65535),
          (J = B >>> 16),
          (B = x[3]),
          (U = C[3]),
          (Q += U & 65535),
          (G += U >>> 16),
          (Y += B & 65535),
          (J += B >>> 16),
          (G += Q >>> 16),
          (Y += G >>> 16),
          (J += Y >>> 16),
          (x[3] = Ge = (Y & 65535) | (J << 16)),
          (C[3] = Xt = (Q & 65535) | (G << 16)),
          (B = P),
          (U = Ot),
          (Q = U & 65535),
          (G = U >>> 16),
          (Y = B & 65535),
          (J = B >>> 16),
          (B = x[4]),
          (U = C[4]),
          (Q += U & 65535),
          (G += U >>> 16),
          (Y += B & 65535),
          (J += B >>> 16),
          (G += Q >>> 16),
          (Y += G >>> 16),
          (J += Y >>> 16),
          (x[4] = P = (Y & 65535) | (J << 16)),
          (C[4] = Ot = (Q & 65535) | (G << 16)),
          (B = st),
          (U = Vt),
          (Q = U & 65535),
          (G = U >>> 16),
          (Y = B & 65535),
          (J = B >>> 16),
          (B = x[5]),
          (U = C[5]),
          (Q += U & 65535),
          (G += U >>> 16),
          (Y += B & 65535),
          (J += B >>> 16),
          (G += Q >>> 16),
          (Y += G >>> 16),
          (J += Y >>> 16),
          (x[5] = st = (Y & 65535) | (J << 16)),
          (C[5] = Vt = (Q & 65535) | (G << 16)),
          (B = ht),
          (U = Ht),
          (Q = U & 65535),
          (G = U >>> 16),
          (Y = B & 65535),
          (J = B >>> 16),
          (B = x[6]),
          (U = C[6]),
          (Q += U & 65535),
          (G += U >>> 16),
          (Y += B & 65535),
          (J += B >>> 16),
          (G += Q >>> 16),
          (Y += G >>> 16),
          (J += Y >>> 16),
          (x[6] = ht = (Y & 65535) | (J << 16)),
          (C[6] = Ht = (Q & 65535) | (G << 16)),
          (B = pt),
          (U = qt),
          (Q = U & 65535),
          (G = U >>> 16),
          (Y = B & 65535),
          (J = B >>> 16),
          (B = x[7]),
          (U = C[7]),
          (Q += U & 65535),
          (G += U >>> 16),
          (Y += B & 65535),
          (J += B >>> 16),
          (G += Q >>> 16),
          (Y += G >>> 16),
          (J += Y >>> 16),
          (x[7] = pt = (Y & 65535) | (J << 16)),
          (C[7] = qt = (Q & 65535) | (G << 16)),
          (an += 128),
          (g -= 128)
      }
      return g
    }
    function pr(x, C, _) {
      var g = new Int32Array(8),
        O = new Int32Array(8),
        N = new Uint8Array(256),
        L,
        q = _
      for (
        g[0] = 1779033703,
          g[1] = 3144134277,
          g[2] = 1013904242,
          g[3] = 2773480762,
          g[4] = 1359893119,
          g[5] = 2600822924,
          g[6] = 528734635,
          g[7] = 1541459225,
          O[0] = 4089235720,
          O[1] = 2227873595,
          O[2] = 4271175723,
          O[3] = 1595750129,
          O[4] = 2917565137,
          O[5] = 725511199,
          O[6] = 4215389547,
          O[7] = 327033209,
          ls(g, O, C, _),
          _ %= 128,
          L = 0;
        L < _;
        L++
      )
        N[L] = C[q - _ + L]
      for (
        N[_] = 128,
          _ = 256 - 128 * (_ < 112 ? 1 : 0),
          N[_ - 9] = 0,
          h(N, _ - 8, (q / 536870912) | 0, q << 3),
          ls(g, O, N, _),
          L = 0;
        L < 8;
        L++
      )
        h(x, 8 * L, g[L], O[L])
      return 0
    }
    function Ir(x, C) {
      var _ = n(),
        g = n(),
        O = n(),
        N = n(),
        L = n(),
        q = n(),
        X = n(),
        ye = n(),
        ae = n()
      _e(_, x[1], x[0]),
        _e(ae, C[1], C[0]),
        re(_, _, ae),
        fe(g, x[0], x[1]),
        fe(ae, C[0], C[1]),
        re(g, g, ae),
        re(O, x[3], C[3]),
        re(O, O, u),
        re(N, x[2], C[2]),
        fe(N, N, N),
        _e(L, g, _),
        _e(q, N, O),
        fe(X, N, O),
        fe(ye, g, _),
        re(x[0], L, q),
        re(x[1], ye, X),
        re(x[2], X, q),
        re(x[3], L, ye)
    }
    function Dr(x, C, _) {
      var g
      for (g = 0; g < 4; g++) K(x[g], C[g], _)
    }
    function gr(x, C) {
      var _ = n(),
        g = n(),
        O = n()
      it(O, C[2]), re(_, C[0], O), re(g, C[1], O), H(x, g), (x[31] ^= Ae(_) << 7)
    }
    function mn(x, C, _) {
      var g, O
      for (We(x[0], o), We(x[1], a), We(x[2], a), We(x[3], o), O = 255; O >= 0; --O)
        (g = (_[(O / 8) | 0] >> (O & 7)) & 1), Dr(x, C, g), Ir(C, x), Ir(x, x), Dr(x, C, g)
    }
    function oi(x, C) {
      var _ = [n(), n(), n(), n()]
      We(_[0], f), We(_[1], d), We(_[2], a), re(_[3], f, d), mn(x, _, C)
    }
    function Nr(x, C, _) {
      var g = new Uint8Array(64),
        O = [n(), n(), n(), n()],
        N
      for (
        _ || r(C, 32),
          pr(g, C, 32),
          g[0] &= 248,
          g[31] &= 127,
          g[31] |= 64,
          oi(O, g),
          gr(x, O),
          N = 0;
        N < 32;
        N++
      )
        C[N + 32] = x[N]
      return 0
    }
    var Bn = new Float64Array([
      237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 16,
    ])
    function ai(x, C) {
      var _, g, O, N
      for (g = 63; g >= 32; --g) {
        for (_ = 0, O = g - 32, N = g - 12; O < N; ++O)
          (C[O] += _ - 16 * C[g] * Bn[O - (g - 32)]),
            (_ = Math.floor((C[O] + 128) / 256)),
            (C[O] -= _ * 256)
        ;(C[O] += _), (C[g] = 0)
      }
      for (_ = 0, O = 0; O < 32; O++)
        (C[O] += _ - (C[31] >> 4) * Bn[O]), (_ = C[O] >> 8), (C[O] &= 255)
      for (O = 0; O < 32; O++) C[O] -= _ * Bn[O]
      for (g = 0; g < 32; g++) (C[g + 1] += C[g] >> 8), (x[g] = C[g] & 255)
    }
    function Hs(x) {
      var C = new Float64Array(64),
        _
      for (_ = 0; _ < 64; _++) C[_] = x[_]
      for (_ = 0; _ < 64; _++) x[_] = 0
      ai(x, C)
    }
    function Mr(x, C, _, g) {
      var O = new Uint8Array(64),
        N = new Uint8Array(64),
        L = new Uint8Array(64),
        q,
        X,
        ye = new Float64Array(64),
        ae = [n(), n(), n(), n()]
      pr(O, g, 32), (O[0] &= 248), (O[31] &= 127), (O[31] |= 64)
      var et = _ + 64
      for (q = 0; q < _; q++) x[64 + q] = C[q]
      for (q = 0; q < 32; q++) x[32 + q] = O[32 + q]
      for (pr(L, x.subarray(32), _ + 32), Hs(L), oi(ae, L), gr(x, ae), q = 32; q < 64; q++)
        x[q] = g[q]
      for (pr(N, x, _ + 64), Hs(N), q = 0; q < 64; q++) ye[q] = 0
      for (q = 0; q < 32; q++) ye[q] = L[q]
      for (q = 0; q < 32; q++) for (X = 0; X < 32; X++) ye[q + X] += N[q] * O[X]
      return ai(x.subarray(32), ye), et
    }
    function Go(x, C) {
      var _ = n(),
        g = n(),
        O = n(),
        N = n(),
        L = n(),
        q = n(),
        X = n()
      return (
        We(x[2], a),
        Ie(x[1], C),
        Z(O, x[1]),
        re(N, O, c),
        _e(O, O, x[2]),
        fe(N, x[2], N),
        Z(L, N),
        Z(q, L),
        re(X, q, L),
        re(_, X, O),
        re(_, _, N),
        wt(_, _),
        re(_, _, O),
        re(_, _, N),
        re(_, _, N),
        re(x[0], _, N),
        Z(g, x[0]),
        re(g, g, N),
        oe(g, O) && re(x[0], x[0], p),
        Z(g, x[0]),
        re(g, g, N),
        oe(g, O) ? -1 : (Ae(x[0]) === C[31] >> 7 && _e(x[0], o, x[0]), re(x[3], x[0], x[1]), 0)
      )
    }
    function er(x, C, _, g) {
      var O,
        N = new Uint8Array(32),
        L = new Uint8Array(64),
        q = [n(), n(), n(), n()],
        X = [n(), n(), n(), n()]
      if (_ < 64 || Go(X, g)) return -1
      for (O = 0; O < _; O++) x[O] = C[O]
      for (O = 0; O < 32; O++) x[O + 32] = g[O]
      if (
        (pr(L, x, _),
        Hs(L),
        mn(q, X, L),
        oi(X, C.subarray(32)),
        Ir(q, X),
        gr(N, q),
        (_ -= 64),
        y(C, 0, N, 0))
      ) {
        for (O = 0; O < _; O++) x[O] = 0
        return -1
      }
      for (O = 0; O < _; O++) x[O] = C[O + 64]
      return _
    }
    var li = 32,
      jr = 24,
      ji = 32,
      Li = 16,
      $i = 32,
      ci = 32,
      Lr = 32,
      ui = 32,
      Yo = 32,
      Qo = jr,
      Xo = ji,
      cs = Li,
      Un = 64,
      j = 32,
      $ = 64,
      W = 32,
      te = 64
    t.lowlevel = {
      crypto_core_hsalsa20: A,
      crypto_stream_xor: V,
      crypto_stream: F,
      crypto_stream_salsa20_xor: k,
      crypto_stream_salsa20: D,
      crypto_onetimeauth: de,
      crypto_onetimeauth_verify: xe,
      crypto_verify_16: b,
      crypto_verify_32: y,
      crypto_secretbox: we,
      crypto_secretbox_open: Pe,
      crypto_scalarmult: Ze,
      crypto_scalarmult_base: _t,
      crypto_box_beforenm: bt,
      crypto_box_afternm: Jn,
      crypto_box: si,
      crypto_box_open: Tn,
      crypto_box_keypair: gn,
      crypto_hash: pr,
      crypto_sign: Mr,
      crypto_sign_keypair: Nr,
      crypto_sign_open: er,
      crypto_secretbox_KEYBYTES: li,
      crypto_secretbox_NONCEBYTES: jr,
      crypto_secretbox_ZEROBYTES: ji,
      crypto_secretbox_BOXZEROBYTES: Li,
      crypto_scalarmult_BYTES: $i,
      crypto_scalarmult_SCALARBYTES: ci,
      crypto_box_PUBLICKEYBYTES: Lr,
      crypto_box_SECRETKEYBYTES: ui,
      crypto_box_BEFORENMBYTES: Yo,
      crypto_box_NONCEBYTES: Qo,
      crypto_box_ZEROBYTES: Xo,
      crypto_box_BOXZEROBYTES: cs,
      crypto_sign_BYTES: Un,
      crypto_sign_PUBLICKEYBYTES: j,
      crypto_sign_SECRETKEYBYTES: $,
      crypto_sign_SEEDBYTES: W,
      crypto_hash_BYTES: te,
      gf: n,
      D: c,
      L: Bn,
      pack25519: H,
      unpack25519: Ie,
      M: re,
      A: fe,
      S: Z,
      Z: _e,
      pow2523: wt,
      add: Ir,
      set25519: We,
      modL: ai,
      scalarmult: mn,
      scalarbase: oi,
    }
    function ne(x, C) {
      if (x.length !== li) throw new Error('bad key size')
      if (C.length !== jr) throw new Error('bad nonce size')
    }
    function Te(x, C) {
      if (x.length !== Lr) throw new Error('bad public key size')
      if (C.length !== ui) throw new Error('bad secret key size')
    }
    function le() {
      for (var x = 0; x < arguments.length; x++)
        if (!(arguments[x] instanceof Uint8Array))
          throw new TypeError('unexpected type, use Uint8Array')
    }
    function se(x) {
      for (var C = 0; C < x.length; C++) x[C] = 0
    }
    ;(t.randomBytes = function (x) {
      var C = new Uint8Array(x)
      return r(C, x), C
    }),
      (t.secretbox = function (x, C, _) {
        le(x, C, _), ne(_, C)
        for (
          var g = new Uint8Array(ji + x.length), O = new Uint8Array(g.length), N = 0;
          N < x.length;
          N++
        )
          g[N + ji] = x[N]
        return we(O, g, g.length, C, _), O.subarray(Li)
      }),
      (t.secretbox.open = function (x, C, _) {
        le(x, C, _), ne(_, C)
        for (
          var g = new Uint8Array(Li + x.length), O = new Uint8Array(g.length), N = 0;
          N < x.length;
          N++
        )
          g[N + Li] = x[N]
        return g.length < 32 || Pe(O, g, g.length, C, _) !== 0 ? null : O.subarray(ji)
      }),
      (t.secretbox.keyLength = li),
      (t.secretbox.nonceLength = jr),
      (t.secretbox.overheadLength = Li),
      (t.scalarMult = function (x, C) {
        if ((le(x, C), x.length !== ci)) throw new Error('bad n size')
        if (C.length !== $i) throw new Error('bad p size')
        var _ = new Uint8Array($i)
        return Ze(_, x, C), _
      }),
      (t.scalarMult.base = function (x) {
        if ((le(x), x.length !== ci)) throw new Error('bad n size')
        var C = new Uint8Array($i)
        return _t(C, x), C
      }),
      (t.scalarMult.scalarLength = ci),
      (t.scalarMult.groupElementLength = $i),
      (t.box = function (x, C, _, g) {
        var O = t.box.before(_, g)
        return t.secretbox(x, C, O)
      }),
      (t.box.before = function (x, C) {
        le(x, C), Te(x, C)
        var _ = new Uint8Array(Yo)
        return bt(_, x, C), _
      }),
      (t.box.after = t.secretbox),
      (t.box.open = function (x, C, _, g) {
        var O = t.box.before(_, g)
        return t.secretbox.open(x, C, O)
      }),
      (t.box.open.after = t.secretbox.open),
      (t.box.keyPair = function () {
        var x = new Uint8Array(Lr),
          C = new Uint8Array(ui)
        return gn(x, C), { publicKey: x, secretKey: C }
      }),
      (t.box.keyPair.fromSecretKey = function (x) {
        if ((le(x), x.length !== ui)) throw new Error('bad secret key size')
        var C = new Uint8Array(Lr)
        return _t(C, x), { publicKey: C, secretKey: new Uint8Array(x) }
      }),
      (t.box.publicKeyLength = Lr),
      (t.box.secretKeyLength = ui),
      (t.box.sharedKeyLength = Yo),
      (t.box.nonceLength = Qo),
      (t.box.overheadLength = t.secretbox.overheadLength),
      (t.sign = function (x, C) {
        if ((le(x, C), C.length !== $)) throw new Error('bad secret key size')
        var _ = new Uint8Array(Un + x.length)
        return Mr(_, x, x.length, C), _
      }),
      (t.sign.open = function (x, C) {
        if ((le(x, C), C.length !== j)) throw new Error('bad public key size')
        var _ = new Uint8Array(x.length),
          g = er(_, x, x.length, C)
        if (g < 0) return null
        for (var O = new Uint8Array(g), N = 0; N < O.length; N++) O[N] = _[N]
        return O
      }),
      (t.sign.detached = function (x, C) {
        for (var _ = t.sign(x, C), g = new Uint8Array(Un), O = 0; O < g.length; O++) g[O] = _[O]
        return g
      }),
      (t.sign.detached.verify = function (x, C, _) {
        if ((le(x, C, _), C.length !== Un)) throw new Error('bad signature size')
        if (_.length !== j) throw new Error('bad public key size')
        var g = new Uint8Array(Un + x.length),
          O = new Uint8Array(Un + x.length),
          N
        for (N = 0; N < Un; N++) g[N] = C[N]
        for (N = 0; N < x.length; N++) g[N + Un] = x[N]
        return er(O, g, g.length, _) >= 0
      }),
      (t.sign.keyPair = function () {
        var x = new Uint8Array(j),
          C = new Uint8Array($)
        return Nr(x, C), { publicKey: x, secretKey: C }
      }),
      (t.sign.keyPair.fromSecretKey = function (x) {
        if ((le(x), x.length !== $)) throw new Error('bad secret key size')
        for (var C = new Uint8Array(j), _ = 0; _ < C.length; _++) C[_] = x[32 + _]
        return { publicKey: C, secretKey: new Uint8Array(x) }
      }),
      (t.sign.keyPair.fromSeed = function (x) {
        if ((le(x), x.length !== W)) throw new Error('bad seed size')
        for (var C = new Uint8Array(j), _ = new Uint8Array($), g = 0; g < 32; g++) _[g] = x[g]
        return Nr(C, _, !0), { publicKey: C, secretKey: _ }
      }),
      (t.sign.publicKeyLength = j),
      (t.sign.secretKeyLength = $),
      (t.sign.seedLength = W),
      (t.sign.signatureLength = Un),
      (t.hash = function (x) {
        le(x)
        var C = new Uint8Array(te)
        return pr(C, x, x.length), C
      }),
      (t.hash.hashLength = te),
      (t.verify = function (x, C) {
        return (
          le(x, C),
          x.length === 0 || C.length === 0 || x.length !== C.length
            ? !1
            : m(x, 0, C, 0, x.length) === 0
        )
      }),
      (t.setPRNG = function (x) {
        r = x
      }),
      (function () {
        var x = typeof self < 'u' ? self.crypto || self.msCrypto : null
        if (x && x.getRandomValues) {
          var C = 65536
          t.setPRNG(function (_, g) {
            var O,
              N = new Uint8Array(g)
            for (O = 0; O < g; O += C) x.getRandomValues(N.subarray(O, O + Math.min(g - O, C)))
            for (O = 0; O < g; O++) _[O] = N[O]
            se(N)
          })
        } else
          typeof wW < 'u' &&
            ((x = SW),
            x &&
              x.randomBytes &&
              t.setPRNG(function (_, g) {
                var O,
                  N = x.randomBytes(g)
                for (O = 0; O < g; O++) _[O] = N[O]
                se(N)
              }))
      })()
  })(e.exports ? e.exports : (self.nacl = self.nacl || {}))
})(Tk)
var EW = Tk.exports
const oa = Ic(EW),
  CW = 'ed25519 seed',
  _W = 2147483648,
  OW = new RegExp("^m(\\/[0-9]+')+$"),
  Ak = (e) => e.replace("'", ''),
  kW = (e) => {
    const n = lg.create(db, CW).update(Lw(e)).digest(),
      r = n.slice(0, 32),
      i = n.slice(32)
    return { key: r, chainCode: i }
  },
  TW = ({ key: e, chainCode: t }, n) => {
    const r = new ArrayBuffer(4)
    new DataView(r).setUint32(0, n)
    const s = new Uint8Array(1 + e.length + r.byteLength)
    s.set(new Uint8Array(1).fill(0)),
      s.set(e, 1),
      s.set(new Uint8Array(r, 0, r.byteLength), e.length + 1)
    const o = lg.create(db, t).update(s).digest(),
      a = o.slice(0, 32),
      l = o.slice(32)
    return { key: a, chainCode: l }
  },
  AW = (e) => (OW.test(e) ? !e.split('/').slice(1).map(Ak).some(isNaN) : !1),
  oE = (e, t, n = _W) => {
    if (!AW(e)) throw new Error('Invalid derivation path')
    const { key: r, chainCode: i } = kW(t)
    return e
      .split('/')
      .slice(1)
      .map(Ak)
      .map((o) => parseInt(o, 10))
      .reduce((o, a) => TW(o, a + n), { key: r, chainCode: i })
  },
  Bv = 32
class Rk extends yk {
  constructor(t) {
    if (
      (super(),
      typeof t == 'string'
        ? (this.data = Gn(t))
        : t instanceof Uint8Array
        ? (this.data = t)
        : (this.data = Uint8Array.from(t)),
      this.data.length !== Bv)
    )
      throw new Error(`Invalid public key input. Expected ${Bv} bytes, got ${this.data.length}`)
  }
  equals(t) {
    return super.equals(t)
  }
  toRawBytes() {
    return this.data
  }
  flag() {
    return sd.ED25519
  }
  async verify(t, n) {
    let r
    if (typeof n == 'string') {
      const i = Zz(n)
      if (i.signatureScheme !== 'ED25519') throw new Error('Invalid signature scheme')
      if (!mk(this.toRawBytes(), i.publicKey))
        throw new Error('Signature does not match public key')
      r = i.signature
    } else r = n
    return oa.sign.detached.verify(t, r, this.toRawBytes())
  }
}
Rk.SIZE = Bv
const aE = "m/44'/784'/0'/0'/0'"
class Rl extends yW {
  constructor(t) {
    super(), t ? (this.keypair = t) : (this.keypair = oa.sign.keyPair())
  }
  getKeyScheme() {
    return 'ED25519'
  }
  static generate() {
    return new Rl(oa.sign.keyPair())
  }
  static fromSecretKey(t, n) {
    const r = t.length
    if (r !== qh) throw new Error(`Wrong secretKey size. Expected ${qh} bytes, got ${r}.`)
    const i = oa.sign.keyPair.fromSeed(t)
    if (!n || !n.skipValidation) {
      const o = new TextEncoder().encode('sui validation'),
        a = oa.sign.detached(o, i.secretKey)
      if (!oa.sign.detached.verify(o, a, i.publicKey))
        throw new Error('provided secretKey is invalid')
    }
    return new Rl(i)
  }
  getPublicKey() {
    return new Rk(this.keypair.publicKey)
  }
  getSecretKey() {
    return vW(this.keypair.secretKey.slice(0, qh), this.getKeyScheme())
  }
  async sign(t) {
    return oa.sign.detached(t, this.keypair.secretKey)
  }
  static deriveKeypair(t, n) {
    if ((n == null && (n = aE), !iE(n))) throw new Error('Invalid derivation path')
    const { key: r } = oE(n, fW(t))
    return Rl.fromSecretKey(r)
  }
  static deriveKeypairFromSeed(t, n) {
    if ((n == null && (n = aE), !iE(n))) throw new Error('Invalid derivation path')
    const { key: r } = oE(n, t)
    return Rl.fromSecretKey(r)
  }
}
function RW(e) {
  return {
    all: (e = e || new Map()),
    on: function (t, n) {
      var r = e.get(t)
      r ? r.push(n) : e.set(t, [n])
    },
    off: function (t, n) {
      var r = e.get(t)
      r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : e.set(t, []))
    },
    emit: function (t, n) {
      var r = e.get(t)
      r &&
        r.slice().map(function (i) {
          i(n)
        }),
        (r = e.get('*')) &&
          r.slice().map(function (i) {
            i(t, n)
          })
    },
  }
}
function PW() {
  let e, t
  return {
    promise: new Promise((r, i) => {
      ;(e = r), (t = i)
    }),
    reject: t,
    resolve: e,
  }
}
const IW = S6('type', [
    Ue({ type: Lt('connect'), address: yt() }),
    Ue({ type: Lt('sign-transaction-block'), bytes: yt(), signature: yt() }),
    Ue({ type: Lt('sign-personal-message'), bytes: yt(), signature: yt() }),
  ]),
  DW = S6('type', [Ue({ type: Lt('reject') }), Ue({ type: Lt('resolve'), data: IW })]),
  NW = Ue({ id: yt([r9()]), source: Lt('zksend-channel'), payload: DW })
var pb = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  Wn = (e, t, n) => (pb(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  Bi = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  ms = (e, t, n, r) => (pb(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  Pm = (e, t, n) => (pb(e, t, 'access private method'), n),
  dl,
  _u,
  Ou,
  Kh,
  Gh,
  Yh,
  Qh,
  Kl,
  s0,
  ku,
  Xh
const Pk = 'https://getstashed.com'
class Yd {
  constructor({ name: t, origin: n = Pk }) {
    Bi(this, ku),
      Bi(this, dl, void 0),
      Bi(this, _u, void 0),
      Bi(this, Ou, void 0),
      Bi(this, Kh, void 0),
      Bi(this, Gh, void 0),
      Bi(this, Yh, void 0),
      Bi(this, Qh, void 0),
      Bi(this, Kl, null),
      Bi(this, s0, (a) => {
        if (a.origin !== Wn(this, Ou)) return
        const { success: l, output: c } = t9(NW, a.data)
        !l ||
          c.id !== Wn(this, _u) ||
          (Pm(this, ku, Xh).call(this),
          c.payload.type === 'reject'
            ? Wn(this, Qh).call(this, new Error('User rejected the request'))
            : c.payload.type === 'resolve' && Wn(this, Yh).call(this, c.payload.data))
      })
    const r = window.open('about:blank', '_blank')
    if (!r) throw new Error('Failed to open new window')
    ms(this, dl, r), ms(this, _u, crypto.randomUUID()), ms(this, Ou, n), ms(this, Kh, t)
    const { promise: i, resolve: s, reject: o } = PW()
    ms(this, Gh, i),
      ms(this, Yh, s),
      ms(this, Qh, o),
      ms(
        this,
        Kl,
        setInterval(() => {
          try {
            Wn(this, dl).closed &&
              (Pm(this, ku, Xh).call(this), o(new Error('User closed the Stashed window')))
          } catch {}
        }, 1e3)
      )
  }
  send({ type: t, ...n }) {
    return (
      window.addEventListener('message', Wn(this, s0)),
      Wn(this, dl).location.assign(
        `${Wn(this, Ou)}/dapp/${t}?${new URLSearchParams({
          id: Wn(this, _u),
          origin: window.origin,
          name: Wn(this, Kh),
        })}${n ? `#${new URLSearchParams(n)}` : ''}`
      ),
      Wn(this, Gh)
    )
  }
  close() {
    Pm(this, ku, Xh).call(this), Wn(this, dl).close()
  }
}
dl = new WeakMap()
_u = new WeakMap()
Ou = new WeakMap()
Kh = new WeakMap()
Gh = new WeakMap()
Yh = new WeakMap()
Qh = new WeakMap()
Kl = new WeakMap()
s0 = new WeakMap()
ku = new WeakSet()
Xh = function () {
  Wn(this, Kl) && (clearInterval(Wn(this, Kl)), ms(this, Kl, null)),
    window.removeEventListener('message', Wn(this, s0))
}
var gb = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  yn = (e, t, n) => (gb(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  hi = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  Pl = (e, t, n, r) => (gb(e, t, 'write to private field'), r ? r.call(e, n) : t.set(e, n), n),
  Qd = (e, t, n) => (gb(e, t, 'access private method'), n),
  Il,
  Gl,
  aa,
  la,
  Uv,
  zv,
  Wv,
  Vv,
  hl,
  Tu,
  Hv,
  qv
const Kv = 'stashed:recentAddress',
  Ik = 'Stashed'
class MW {
  constructor({ name: t, address: n, origin: r = Pk }) {
    hi(this, hl),
      hi(this, Il, void 0),
      hi(this, Gl, void 0),
      hi(this, aa, void 0),
      hi(this, la, void 0),
      hi(this, Uv, async ({ transactionBlock: i, account: s }) => {
        i.setSenderIfNotSet(s.address)
        const o = i.serialize(),
          l = await new Yd({ name: yn(this, la), origin: yn(this, aa) }).send({
            type: 'sign-transaction-block',
            data: o,
            address: s.address,
          })
        return { transactionBlockBytes: l.bytes, signature: l.signature }
      }),
      hi(this, zv, async ({ transaction: i, account: s }) => {
        const o = new Yd({ name: yn(this, la), origin: yn(this, aa) }),
          a = Ov.from(await i.toJSON())
        a.setSenderIfNotSet(s.address)
        const l = a.serialize(),
          c = await o.send({ type: 'sign-transaction-block', data: l, address: s.address })
        return { bytes: c.bytes, signature: c.signature }
      }),
      hi(this, Wv, async ({ message: i, account: s }) => {
        const o = new Yd({ name: yn(this, la), origin: yn(this, aa) }),
          a = Pt(i),
          l = await o.send({ type: 'sign-personal-message', bytes: a, address: s.address })
        return { bytes: a, signature: l.signature }
      }),
      hi(this, Vv, (i, s) => (yn(this, Il).on(i, s), () => yn(this, Il).off(i, s))),
      hi(this, Hv, async (i) => {
        if (i != null && i.silent) {
          const a = localStorage.getItem(Kv)
          return a && Qd(this, hl, Tu).call(this, a), { accounts: this.accounts }
        }
        const o = await new Yd({ name: yn(this, la), origin: yn(this, aa) }).send({
          type: 'connect',
        })
        if (!('address' in o)) throw new Error('Unexpected response')
        return Qd(this, hl, Tu).call(this, o.address), { accounts: this.accounts }
      }),
      hi(this, qv, async () => {
        localStorage.removeItem(Kv), Qd(this, hl, Tu).call(this)
      }),
      Pl(this, Gl, []),
      Pl(this, Il, RW()),
      Pl(this, aa, r),
      Pl(this, la, t),
      n && Qd(this, hl, Tu).call(this, n)
  }
  get name() {
    return Ik
  }
  get icon() {
    return 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1NiIgaGVpZ2h0PSI1NiIgZmlsbD0ibm9uZSI+PHJlY3Qgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiB4PSIxIiB5PSIxIiBmaWxsPSIjNTE5REU5IiByeD0iMjciLz48cmVjdCB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHg9IjEiIHk9IjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIiByeD0iMjciLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTguMzUzIDM1LjA2NGMuOTIxIDMuNDM4IDQuMzYzIDYuNTUxIDExLjQ4MyA0LjY0NCA2Ljc5NC0xLjgyMSAxMS4wNTItNy40MSA5Ljk0OC0xMS41My0uMzgxLTEuNDIzLTEuNTMtMi4zODctMy4zLTIuMjNsLTE1LjgzMiAxLjMyYy0uOTk3LjA3Ni0xLjQ1NC0uMDg4LTEuNzE4LS43MTYtLjI1Ni0uNTk5LS4xMS0xLjI0MSAxLjA5NC0xLjg1bDEyLjA0OC02LjE4M2MuOTI0LS40NyAxLjUzOS0uNjY2IDIuMTAxLS40NjguMzUyLjEyOC41ODQuNjM4LjM3MSAxLjI2N2wtLjc4MSAyLjMwNmMtLjk1OSAyLjgzIDEuMDk0IDMuNDg4IDIuMjUgMy4xNzggMS43NTEtLjQ2OSAyLjE2My0yLjEzNiAxLjU5OS00LjI0LTEuNDMtNS4zMzctNy4wOS02LjE3LTEyLjIyMy00Ljc5Ni01LjIyMiAxLjQtOS43NDggNS42My04LjM2NiAxMC43ODkuMzI1IDEuMjE1IDEuNDQ0IDIuMTg2IDIuNzQgMi4xNTdsMS45NzgtLjAwNWMuNDA3LS4wMS4yNi4wMjQgMS4wNDYtLjA0MS43ODQtLjA2NSAyLjg4LS4zMjMgMi44OC0uMzIzbDEwLjI4Ni0xLjE2NC4yNjUtLjAzOGMuNjAyLS4xMDMgMS4wNTYuMDUzIDEuNDQuNzE1LjU3Ni45OTEtLjMwMiAxLjczOC0xLjM1MiAyLjYzM2wtLjA4NS4wNzItOS4wNDEgNy43OTJjLTEuNTUgMS4zMzctMi42MzkuODM0LTMuMDItLjU4OWwtMS4zNS01LjA0Yy0uMzM0LTEuMjQ0LTEuNTUtMi4yMjEtMi45NzQtMS44NC0xLjc4LjQ3Ny0xLjkyNCAyLjU1LTEuNDg3IDQuMThaIi8+PC9zdmc+Cg=='
  }
  get version() {
    return '1.0.0'
  }
  get chains() {
    return [Xw]
  }
  get accounts() {
    return yn(this, Gl)
  }
  get features() {
    return {
      'standard:connect': { version: '1.0.0', connect: yn(this, Hv) },
      'standard:disconnect': { version: '1.0.0', disconnect: yn(this, qv) },
      'standard:events': { version: '1.0.0', on: yn(this, Vv) },
      'sui:signTransactionBlock': { version: '1.0.0', signTransactionBlock: yn(this, Uv) },
      'sui:signTransaction': { version: '2.0.0', signTransaction: yn(this, zv) },
      'sui:signPersonalMessage': { version: '1.0.0', signPersonalMessage: yn(this, Wv) },
    }
  }
}
Il = new WeakMap()
Gl = new WeakMap()
aa = new WeakMap()
la = new WeakMap()
Uv = new WeakMap()
zv = new WeakMap()
Wv = new WeakMap()
Vv = new WeakMap()
hl = new WeakSet()
Tu = function (e) {
  e
    ? (Pl(this, Gl, [
        new eg({
          address: e,
          chains: [Xw],
          features: ['sui:signTransactionBlock', 'sui:signPersonalMessage'],
          publicKey: new Uint8Array(),
        }),
      ]),
      localStorage.setItem(Kv, e))
    : Pl(this, Gl, []),
    yn(this, Il).emit('change', { accounts: this.accounts })
}
Hv = new WeakMap()
qv = new WeakMap()
function jW(e, { origin: t }) {
  const n = J0()
  let r = null
  try {
    const o = new URLSearchParams(window.location.search)
    r = o.get('stashed_address') || o.get('zksend_address')
  } catch {}
  const i = new MW({ name: e, origin: t, address: r }),
    s = n.register(i)
  return { wallet: i, unregister: s, addressFromRedirect: r }
}
function Dk(e, t) {
  let n
  try {
    n = e()
  } catch {
    return
  }
  return {
    getItem: (i) => {
      var s
      const o = (l) => (l === null ? null : JSON.parse(l, t == null ? void 0 : t.reviver)),
        a = (s = n.getItem(i)) != null ? s : null
      return a instanceof Promise ? a.then(o) : o(a)
    },
    setItem: (i, s) => n.setItem(i, JSON.stringify(s, t == null ? void 0 : t.replacer)),
    removeItem: (i) => n.removeItem(i),
  }
}
const _f = (e) => (t) => {
    try {
      const n = e(t)
      return n instanceof Promise
        ? n
        : {
            then(r) {
              return _f(r)(n)
            },
            catch(r) {
              return this
            },
          }
    } catch (n) {
      return {
        then(r) {
          return this
        },
        catch(r) {
          return _f(r)(n)
        },
      }
    }
  },
  LW = (e, t) => (n, r, i) => {
    let s = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: (b) => b,
        version: 0,
        merge: (b, y) => ({ ...y, ...b }),
        ...t,
      },
      o = !1
    const a = new Set(),
      l = new Set()
    let c
    try {
      c = s.getStorage()
    } catch {}
    if (!c)
      return e(
        (...b) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
          ),
            n(...b)
        },
        r,
        i
      )
    const u = _f(s.serialize),
      f = () => {
        const b = s.partialize({ ...r() })
        let y
        const v = u({ state: b, version: s.version })
          .then((S) => c.setItem(s.name, S))
          .catch((S) => {
            y = S
          })
        if (y) throw y
        return v
      },
      d = i.setState
    i.setState = (b, y) => {
      d(b, y), f()
    }
    const p = e(
      (...b) => {
        n(...b), f()
      },
      r,
      i
    )
    let h
    const m = () => {
      var b
      if (!c) return
      ;(o = !1), a.forEach((v) => v(r()))
      const y = ((b = s.onRehydrateStorage) == null ? void 0 : b.call(s, r())) || void 0
      return _f(c.getItem.bind(c))(s.name)
        .then((v) => {
          if (v) return s.deserialize(v)
        })
        .then((v) => {
          if (v)
            if (typeof v.version == 'number' && v.version !== s.version) {
              if (s.migrate) return s.migrate(v.state, v.version)
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              )
            } else return v.state
        })
        .then((v) => {
          var S
          return (h = s.merge(v, (S = r()) != null ? S : p)), n(h, !0), f()
        })
        .then(() => {
          y == null || y(h, void 0), (o = !0), l.forEach((v) => v(h))
        })
        .catch((v) => {
          y == null || y(void 0, v)
        })
    }
    return (
      (i.persist = {
        setOptions: (b) => {
          ;(s = { ...s, ...b }), b.getStorage && (c = b.getStorage())
        },
        clearStorage: () => {
          c == null || c.removeItem(s.name)
        },
        getOptions: () => s,
        rehydrate: () => m(),
        hasHydrated: () => o,
        onHydrate: (b) => (
          a.add(b),
          () => {
            a.delete(b)
          }
        ),
        onFinishHydration: (b) => (
          l.add(b),
          () => {
            l.delete(b)
          }
        ),
      }),
      m(),
      h || p
    )
  },
  $W = (e, t) => (n, r, i) => {
    let s = {
        storage: Dk(() => localStorage),
        partialize: (m) => m,
        version: 0,
        merge: (m, b) => ({ ...b, ...m }),
        ...t,
      },
      o = !1
    const a = new Set(),
      l = new Set()
    let c = s.storage
    if (!c)
      return e(
        (...m) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
          ),
            n(...m)
        },
        r,
        i
      )
    const u = () => {
        const m = s.partialize({ ...r() })
        return c.setItem(s.name, { state: m, version: s.version })
      },
      f = i.setState
    i.setState = (m, b) => {
      f(m, b), u()
    }
    const d = e(
      (...m) => {
        n(...m), u()
      },
      r,
      i
    )
    i.getInitialState = () => d
    let p
    const h = () => {
      var m, b
      if (!c) return
      ;(o = !1),
        a.forEach((v) => {
          var S
          return v((S = r()) != null ? S : d)
        })
      const y =
        ((b = s.onRehydrateStorage) == null ? void 0 : b.call(s, (m = r()) != null ? m : d)) ||
        void 0
      return _f(c.getItem.bind(c))(s.name)
        .then((v) => {
          if (v)
            if (typeof v.version == 'number' && v.version !== s.version) {
              if (s.migrate) return s.migrate(v.state, v.version)
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              )
            } else return v.state
        })
        .then((v) => {
          var S
          return (p = s.merge(v, (S = r()) != null ? S : d)), n(p, !0), u()
        })
        .then(() => {
          y == null || y(p, void 0), (p = r()), (o = !0), l.forEach((v) => v(p))
        })
        .catch((v) => {
          y == null || y(void 0, v)
        })
    }
    return (
      (i.persist = {
        setOptions: (m) => {
          ;(s = { ...s, ...m }), m.storage && (c = m.storage)
        },
        clearStorage: () => {
          c == null || c.removeItem(s.name)
        },
        getOptions: () => s,
        rehydrate: () => h(),
        hasHydrated: () => o,
        onHydrate: (m) => (
          a.add(m),
          () => {
            a.delete(m)
          }
        ),
        onFinishHydration: (m) => (
          l.add(m),
          () => {
            l.delete(m)
          }
        ),
      }),
      s.skipHydration || h(),
      p || d
    )
  },
  FW = (e, t) =>
    'getStorage' in t || 'serialize' in t || 'deserialize' in t ? LW(e, t) : $W(e, t),
  BW = FW
function Gv(e) {
  var t = e.match(/^var\((.*)\)$/)
  return t ? t[1] : e
}
function UW(e, t) {
  var n = e
  for (var r of t) {
    if (!(r in n)) throw new Error('Path '.concat(t.join(' -> '), ' does not exist in object'))
    n = n[r]
  }
  return n
}
function mb(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [],
    r = {}
  for (var i in e) {
    var s = e[i],
      o = [...n, i]
    typeof s == 'string' || typeof s == 'number' || s == null
      ? (r[i] = t(s, o))
      : typeof s == 'object' && !Array.isArray(s)
      ? (r[i] = mb(s, t, o))
      : console.warn(
          'Skipping invalid key "'
            .concat(o.join('.'), '". Should be a string, number, null or object. Received: "')
            .concat(Array.isArray(s) ? 'Array' : typeof s, '"')
        )
  }
  return r
}
function zW(e, t) {
  var n = {}
  if (typeof t == 'object') {
    var r = e
    mb(t, (a, l) => {
      if (a != null) {
        var c = UW(r, l)
        n[Gv(c)] = String(a)
      }
    })
  } else {
    var i = e
    for (var s in i) {
      var o = i[s]
      o != null && (n[Gv(s)] = o)
    }
  }
  return (
    Object.defineProperty(n, 'toString', {
      value: function () {
        return Object.keys(this)
          .map((l) => ''.concat(l, ':').concat(this[l]))
          .join(';')
      },
      writable: !1,
    }),
    n
  )
}
var lE = {},
  WW = (e) => {
    var { fileScope: t, css: n } = e,
      r = t.packageName ? [t.packageName, t.filePath].join('/') : t.filePath,
      i = lE[r]
    if (!i) {
      var s = document.createElement('style')
      t.packageName && s.setAttribute('data-package', t.packageName),
        s.setAttribute('data-file', t.filePath),
        s.setAttribute('type', 'text/css'),
        (i = lE[r] = s),
        document.head.appendChild(s)
    }
    i.innerHTML = n
  }
/*! https://mths.be/cssesc v3.0.0 by @mathias */ var VW = {},
  HW = VW.hasOwnProperty,
  qW = function (t, n) {
    if (!t) return n
    var r = {}
    for (var i in n) r[i] = HW.call(t, i) ? t[i] : n[i]
    return r
  },
  KW = /[ -,\.\/:-@\[-\^`\{-~]/,
  GW = /[ -,\.\/:-@\[\]\^`\{-~]/,
  YW = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g,
  yb = function e(t, n) {
    ;(n = qW(n, e.options)), n.quotes != 'single' && n.quotes != 'double' && (n.quotes = 'single')
    for (
      var r = n.quotes == 'double' ? '"' : "'",
        i = n.isIdentifier,
        s = t.charAt(0),
        o = '',
        a = 0,
        l = t.length;
      a < l;

    ) {
      var c = t.charAt(a++),
        u = c.charCodeAt(),
        f = void 0
      if (u < 32 || u > 126) {
        if (u >= 55296 && u <= 56319 && a < l) {
          var d = t.charCodeAt(a++)
          ;(d & 64512) == 56320 ? (u = ((u & 1023) << 10) + (d & 1023) + 65536) : a--
        }
        f = '\\' + u.toString(16).toUpperCase() + ' '
      } else
        n.escapeEverything
          ? KW.test(c)
            ? (f = '\\' + c)
            : (f = '\\' + u.toString(16).toUpperCase() + ' ')
          : /[\t\n\f\r\x0B]/.test(c)
          ? (f = '\\' + u.toString(16).toUpperCase() + ' ')
          : c == '\\' || (!i && ((c == '"' && r == c) || (c == "'" && r == c))) || (i && GW.test(c))
          ? (f = '\\' + c)
          : (f = c)
      o += f
    }
    return (
      i &&
        (/^-[-\d]/.test(o)
          ? (o = '\\-' + o.slice(1))
          : /\d/.test(s) && (o = '\\3' + s + ' ' + o.slice(1))),
      (o = o.replace(YW, function (p, h, m) {
        return h && h.length % 2 ? p : (h || '') + m
      })),
      !i && n.wrap ? r + o + r : o
    )
  }
yb.options = { escapeEverything: !1, isIdentifier: !1, quotes: 'single', wrap: !1 }
yb.version = '3.0.0'
var QW = yb
const vb = Ic(QW)
class XW {
  constructor(t) {
    const { failure: n, gotoFn: r, output: i } = this._buildTables(t)
    ;(this.gotoFn = r), (this.output = i), (this.failure = n)
  }
  _buildTables(t) {
    const n = { 0: {} },
      r = {}
    let i = 0
    for (const a of t) {
      let l = 0
      for (const c of a)
        n[l] && c in n[l] ? (l = n[l][c]) : (i++, (n[l][c] = i), (n[i] = {}), (l = i), (r[i] = []))
      r[l].push(a)
    }
    const s = {},
      o = []
    for (const a in n[0]) {
      const l = n[0][a]
      ;(s[l] = 0), o.push(l)
    }
    for (; o.length > 0; ) {
      const a = o.shift()
      if (a !== void 0)
        for (const l in n[a]) {
          const c = n[a][l]
          o.push(c)
          let u = s[a]
          for (; u > 0 && !(l in n[u]); ) u = s[u]
          if (l in n[u]) {
            const f = n[u][l]
            ;(s[c] = f), (r[c] = [...r[c], ...r[f]])
          } else s[c] = 0
        }
    }
    return { gotoFn: n, output: r, failure: s }
  }
  search(t) {
    let n = 0
    const r = []
    for (let i = 0; i < t.length; i++) {
      const s = t[i]
      for (; n > 0 && !(s in this.gotoFn[n]); ) n = this.failure[n]
      if (s in this.gotoFn[n] && ((n = this.gotoFn[n][s]), this.output[n].length > 0)) {
        const o = this.output[n]
        r.push([i, o])
      }
    }
    return r
  }
}
var ZW = {
    appendCss: () => {},
    registerClassName: () => {},
    onEndFileScope: () => {},
    registerComposition: () => {},
    markCompositionUsed: () => {},
    getIdentOption: () => 'short',
  },
  Zh = [ZW],
  JW = () => {
    if (Zh.length < 1) throw new Error('No adapter configured')
    return Zh[Zh.length - 1]
  },
  Nk = !1,
  eV = (e) => {
    Nk || tV(e)
  },
  tV = (e) => {
    if (!e) throw new Error('No adapter provided when calling "setAdapter"')
    ;(Nk = !0), Zh.push(e)
  },
  nV = function () {
    return JW().markCompositionUsed(...arguments)
  }
function Mk(e, t) {
  return (
    t || (t = e.slice(0)),
    Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } }))
  )
}
var Ft
;(function (e) {
  ;(e.Attribute = 'attribute'),
    (e.Pseudo = 'pseudo'),
    (e.PseudoElement = 'pseudo-element'),
    (e.Tag = 'tag'),
    (e.Universal = 'universal'),
    (e.Adjacent = 'adjacent'),
    (e.Child = 'child'),
    (e.Descendant = 'descendant'),
    (e.Parent = 'parent'),
    (e.Sibling = 'sibling'),
    (e.ColumnCombinator = 'column-combinator')
})(Ft || (Ft = {}))
var Yr
;(function (e) {
  ;(e.Any = 'any'),
    (e.Element = 'element'),
    (e.End = 'end'),
    (e.Equals = 'equals'),
    (e.Exists = 'exists'),
    (e.Hyphen = 'hyphen'),
    (e.Not = 'not'),
    (e.Start = 'start')
})(Yr || (Yr = {}))
const cE = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/,
  rV = /\\([\da-f]{1,6}\s?|(\s)|.)/gi,
  iV = new Map([
    [126, Yr.Element],
    [94, Yr.Start],
    [36, Yr.End],
    [42, Yr.Any],
    [33, Yr.Not],
    [124, Yr.Hyphen],
  ]),
  sV = new Set(['has', 'not', 'matches', 'is', 'where', 'host', 'host-context'])
function oV(e) {
  switch (e.type) {
    case Ft.Adjacent:
    case Ft.Child:
    case Ft.Descendant:
    case Ft.Parent:
    case Ft.Sibling:
    case Ft.ColumnCombinator:
      return !0
    default:
      return !1
  }
}
const aV = new Set(['contains', 'icontains'])
function lV(e, t, n) {
  const r = parseInt(t, 16) - 65536
  return r !== r || n
    ? t
    : r < 0
    ? String.fromCharCode(r + 65536)
    : String.fromCharCode((r >> 10) | 55296, (r & 1023) | 56320)
}
function du(e) {
  return e.replace(rV, lV)
}
function Im(e) {
  return e === 39 || e === 34
}
function uE(e) {
  return e === 32 || e === 9 || e === 10 || e === 12 || e === 13
}
function cV(e) {
  const t = [],
    n = jk(t, `${e}`, 0)
  if (n < e.length) throw new Error(`Unmatched selector: ${e.slice(n)}`)
  return t
}
function jk(e, t, n) {
  let r = []
  function i(d) {
    const p = t.slice(n + d).match(cE)
    if (!p) throw new Error(`Expected name, found ${t.slice(n)}`)
    const [h] = p
    return (n += d + h.length), du(h)
  }
  function s(d) {
    for (n += d; n < t.length && uE(t.charCodeAt(n)); ) n++
  }
  function o() {
    n += 1
    const d = n
    let p = 1
    for (; p > 0 && n < t.length; n++)
      t.charCodeAt(n) === 40 && !a(n) ? p++ : t.charCodeAt(n) === 41 && !a(n) && p--
    if (p) throw new Error('Parenthesis not matched')
    return du(t.slice(d, n - 1))
  }
  function a(d) {
    let p = 0
    for (; t.charCodeAt(--d) === 92; ) p++
    return (p & 1) === 1
  }
  function l() {
    if (r.length > 0 && oV(r[r.length - 1]))
      throw new Error('Did not expect successive traversals.')
  }
  function c(d) {
    if (r.length > 0 && r[r.length - 1].type === Ft.Descendant) {
      r[r.length - 1].type = d
      return
    }
    l(), r.push({ type: d })
  }
  function u(d, p) {
    r.push({
      type: Ft.Attribute,
      name: d,
      action: p,
      value: i(1),
      namespace: null,
      ignoreCase: 'quirks',
    })
  }
  function f() {
    if ((r.length && r[r.length - 1].type === Ft.Descendant && r.pop(), r.length === 0))
      throw new Error('Empty sub-selector')
    e.push(r)
  }
  if ((s(0), t.length === n)) return n
  e: for (; n < t.length; ) {
    const d = t.charCodeAt(n)
    switch (d) {
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        ;(r.length === 0 || r[0].type !== Ft.Descendant) && (l(), r.push({ type: Ft.Descendant })),
          s(1)
        break
      }
      case 62: {
        c(Ft.Child), s(1)
        break
      }
      case 60: {
        c(Ft.Parent), s(1)
        break
      }
      case 126: {
        c(Ft.Sibling), s(1)
        break
      }
      case 43: {
        c(Ft.Adjacent), s(1)
        break
      }
      case 46: {
        u('class', Yr.Element)
        break
      }
      case 35: {
        u('id', Yr.Equals)
        break
      }
      case 91: {
        s(1)
        let p,
          h = null
        t.charCodeAt(n) === 124
          ? (p = i(1))
          : t.startsWith('*|', n)
          ? ((h = '*'), (p = i(2)))
          : ((p = i(0)),
            t.charCodeAt(n) === 124 && t.charCodeAt(n + 1) !== 61 && ((h = p), (p = i(1)))),
          s(0)
        let m = Yr.Exists
        const b = iV.get(t.charCodeAt(n))
        if (b) {
          if (((m = b), t.charCodeAt(n + 1) !== 61)) throw new Error('Expected `=`')
          s(2)
        } else t.charCodeAt(n) === 61 && ((m = Yr.Equals), s(1))
        let y = '',
          v = null
        if (m !== 'exists') {
          if (Im(t.charCodeAt(n))) {
            const A = t.charCodeAt(n)
            let I = n + 1
            for (; I < t.length && (t.charCodeAt(I) !== A || a(I)); ) I += 1
            if (t.charCodeAt(I) !== A) throw new Error("Attribute value didn't end")
            ;(y = du(t.slice(n + 1, I))), (n = I + 1)
          } else {
            const A = n
            for (; n < t.length && ((!uE(t.charCodeAt(n)) && t.charCodeAt(n) !== 93) || a(n)); )
              n += 1
            y = du(t.slice(A, n))
          }
          s(0)
          const T = t.charCodeAt(n) | 32
          T === 115 ? ((v = !1), s(1)) : T === 105 && ((v = !0), s(1))
        }
        if (t.charCodeAt(n) !== 93) throw new Error("Attribute selector didn't terminate")
        n += 1
        const S = { type: Ft.Attribute, name: p, action: m, value: y, namespace: h, ignoreCase: v }
        r.push(S)
        break
      }
      case 58: {
        if (t.charCodeAt(n + 1) === 58) {
          r.push({
            type: Ft.PseudoElement,
            name: i(2).toLowerCase(),
            data: t.charCodeAt(n) === 40 ? o() : null,
          })
          continue
        }
        const p = i(1).toLowerCase()
        let h = null
        if (t.charCodeAt(n) === 40)
          if (sV.has(p)) {
            if (Im(t.charCodeAt(n + 1))) throw new Error(`Pseudo-selector ${p} cannot be quoted`)
            if (((h = []), (n = jk(h, t, n + 1)), t.charCodeAt(n) !== 41))
              throw new Error(`Missing closing parenthesis in :${p} (${t})`)
            n += 1
          } else {
            if (((h = o()), aV.has(p))) {
              const m = h.charCodeAt(0)
              m === h.charCodeAt(h.length - 1) && Im(m) && (h = h.slice(1, -1))
            }
            h = du(h)
          }
        r.push({ type: Ft.Pseudo, name: p, data: h })
        break
      }
      case 44: {
        f(), (r = []), s(1)
        break
      }
      default: {
        if (t.startsWith('/*', n)) {
          const m = t.indexOf('*/', n + 2)
          if (m < 0) throw new Error('Comment was not terminated')
          ;(n = m + 2), r.length === 0 && s(0)
          break
        }
        let p = null,
          h
        if (d === 42) (n += 1), (h = '*')
        else if (d === 124) {
          if (((h = ''), t.charCodeAt(n + 1) === 124)) {
            c(Ft.ColumnCombinator), s(2)
            break
          }
        } else if (cE.test(t.slice(n))) h = i(0)
        else break e
        t.charCodeAt(n) === 124 &&
          t.charCodeAt(n + 1) !== 124 &&
          ((p = h), t.charCodeAt(n + 1) === 42 ? ((h = '*'), (n += 2)) : (h = i(1))),
          r.push(
            h === '*'
              ? { type: Ft.Universal, namespace: p }
              : { type: Ft.Tag, name: h, namespace: p }
          )
      }
    }
  }
  return f(), n
}
function fE(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function dE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? fE(Object(n), !0).forEach(function (r) {
          uV(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : fE(Object(n)).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
  }
  return e
}
function uV(e, t, n) {
  return (
    (t = fV(t)),
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function fV(e) {
  var t = dV(e, 'string')
  return typeof t == 'symbol' ? t : String(t)
}
function dV(e, t) {
  if (typeof e != 'object' || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || 'default')
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
const Lk = $k({})
function $k(e) {
  return (t.withOptions = (n) => $k(dE(dE({}, e), n))), t
  function t(n, ...r) {
    const i = typeof n == 'string' ? [n] : n.raw,
      { escapeSpecialCharacters: s = Array.isArray(n) } = e
    let o = ''
    for (let c = 0; c < i.length; c++) {
      let u = i[c]
      s &&
        (u = u
          .replace(/\\\n[ \t]*/g, '')
          .replace(/\\`/g, '`')
          .replace(/\\\$/g, '$')
          .replace(/\\\{/g, '{')),
        (o += u),
        c < r.length && (o += r[c])
    }
    const a = o.split(`
`)
    let l = null
    for (const c of a) {
      const u = c.match(/^(\s+)\S+/)
      if (u) {
        const f = u[1].length
        l ? (l = Math.min(l, f)) : (l = f)
      }
    }
    if (l !== null) {
      const c = l
      o = a.map((u) => (u[0] === ' ' || u[0] === '	' ? u.slice(c) : u)).join(`
`)
    }
    return (
      (o = o.trim()),
      s &&
        (o = o.replace(
          /\\n/g,
          `
`
        )),
      o
    )
  }
}
/*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) */ /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var o0 =
  function () {
    return (
      (o0 =
        Object.assign ||
        function (t) {
          for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r]
            for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s])
          }
          return t
        }),
      o0.apply(this, arguments)
    )
  }
function Yv(e, t) {
  var n = {}
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
        (n[r[i]] = e[r[i]])
  return n
}
function hV(e) {
  var t = typeof Symbol == 'function' && Symbol.iterator,
    n = t && e[t],
    r = 0
  if (n) return n.call(e)
  if (e && typeof e.length == 'number')
    return {
      next: function () {
        return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }
      },
    }
  throw new TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
}
function un(e, t) {
  var n = typeof Symbol == 'function' && e[Symbol.iterator]
  if (!n) return e
  var r = n.call(e),
    i,
    s = [],
    o
  try {
    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) s.push(i.value)
  } catch (a) {
    o = { error: a }
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r)
    } finally {
      if (o) throw o.error
    }
  }
  return s
}
var pV = /(\u000D|\u000C|\u000D\u000A)/g,
  gV = /[\u0000\uD800-\uDFFF]/g,
  mV = /(\/\*)[\s\S]*?(\*\/)/g,
  yV = function (t, n) {
    n === void 0 && (n = 0),
      (t = t
        .replace(
          pV,
          `
`
        )
        .replace(gV, '')),
      (t = t.replace(mV, ''))
    for (var r = []; n < t.length; n += 1) {
      var i = t.charCodeAt(n)
      if (i === 9 || i === 32 || i === 10) {
        for (var s = t.charCodeAt(++n); s === 9 || s === 32 || s === 10; ) s = t.charCodeAt(++n)
        ;(n -= 1), r.push({ type: '<whitespace-token>' })
      } else if (i === 34) {
        var o = hE(t, n)
        if (o === null) return null
        var a = un(o, 2),
          l = a[0],
          c = a[1]
        r.push({ type: '<string-token>', value: c }), (n = l)
      } else if (i === 35) {
        if (n + 1 < t.length) {
          var u = t.charCodeAt(n + 1)
          if (
            u === 95 ||
            (u >= 65 && u <= 90) ||
            (u >= 97 && u <= 122) ||
            u >= 128 ||
            (u >= 48 && u <= 57) ||
            (u === 92 && n + 2 < t.length && t.charCodeAt(n + 2) !== 10)
          ) {
            var f = Fk(t, n + 1) ? 'id' : 'unrestricted',
              o = wV(t, n + 1)
            if (o !== null) {
              var d = un(o, 2),
                l = d[0],
                c = d[1]
              r.push({ type: '<hash-token>', value: c.toLowerCase(), flag: f }), (n = l)
              continue
            }
          }
        }
        r.push({ type: '<delim-token>', value: i })
      } else if (i === 39) {
        var o = hE(t, n)
        if (o === null) return null
        var p = un(o, 2),
          l = p[0],
          c = p[1]
        r.push({ type: '<string-token>', value: c }), (n = l)
      } else if (i === 40) r.push({ type: '<(-token>' })
      else if (i === 41) r.push({ type: '<)-token>' })
      else if (i === 43) {
        var h = Xd(t, n)
        if (h === null) r.push({ type: '<delim-token>', value: i })
        else {
          var m = un(h, 2),
            l = m[0],
            b = m[1]
          b[0] === '<dimension-token>'
            ? r.push({
                type: '<dimension-token>',
                value: b[1],
                unit: b[2].toLowerCase(),
                flag: 'number',
              })
            : b[0] === '<number-token>'
            ? r.push({ type: b[0], value: b[1], flag: b[2] })
            : r.push({ type: b[0], value: b[1], flag: 'number' }),
            (n = l)
        }
      } else if (i === 44) r.push({ type: '<comma-token>' })
      else if (i === 45) {
        var y = Xd(t, n)
        if (y !== null) {
          var v = un(y, 2),
            l = v[0],
            b = v[1]
          b[0] === '<dimension-token>'
            ? r.push({
                type: '<dimension-token>',
                value: b[1],
                unit: b[2].toLowerCase(),
                flag: 'number',
              })
            : b[0] === '<number-token>'
            ? r.push({ type: b[0], value: b[1], flag: b[2] })
            : r.push({ type: b[0], value: b[1], flag: 'number' }),
            (n = l)
          continue
        }
        if (n + 2 < t.length) {
          var u = t.charCodeAt(n + 1),
            S = t.charCodeAt(n + 2)
          if (u === 45 && S === 62) {
            r.push({ type: '<CDC-token>' }), (n += 2)
            continue
          }
        }
        var o = pE(t, n)
        if (o !== null) {
          var T = un(o, 3),
            l = T[0],
            c = T[1],
            A = T[2]
          r.push({ type: A, value: c }), (n = l)
          continue
        }
        r.push({ type: '<delim-token>', value: i })
      } else if (i === 46) {
        var y = Xd(t, n)
        if (y === null) r.push({ type: '<delim-token>', value: i })
        else {
          var I = un(y, 2),
            l = I[0],
            b = I[1]
          b[0] === '<dimension-token>'
            ? r.push({
                type: '<dimension-token>',
                value: b[1],
                unit: b[2].toLowerCase(),
                flag: 'number',
              })
            : b[0] === '<number-token>'
            ? r.push({ type: b[0], value: b[1], flag: b[2] })
            : r.push({ type: b[0], value: b[1], flag: 'number' }),
            (n = l)
          continue
        }
      } else if (i === 58) r.push({ type: '<colon-token>' })
      else if (i === 59) r.push({ type: '<semicolon-token>' })
      else if (i === 60) {
        if (n + 3 < t.length) {
          var u = t.charCodeAt(n + 1),
            S = t.charCodeAt(n + 2),
            k = t.charCodeAt(n + 3)
          if (u === 33 && S === 45 && k === 45) {
            r.push({ type: '<CDO-token>' }), (n += 3)
            continue
          }
        }
        r.push({ type: '<delim-token>', value: i })
      } else if (i === 64) {
        var o = wb(t, n + 1)
        if (o !== null) {
          var D = un(o, 2),
            l = D[0],
            c = D[1]
          r.push({ type: '<at-keyword-token>', value: c.toLowerCase() }), (n = l)
          continue
        }
        r.push({ type: '<delim-token>', value: i })
      } else if (i === 91) r.push({ type: '<[-token>' })
      else if (i === 92) {
        var o = od(t, n)
        if (o === null) return null
        var F = un(o, 2),
          l = F[0],
          c = F[1]
        ;(t = t.slice(0, n) + c + t.slice(l + 1)), (n -= 1)
      } else if (i === 93) r.push({ type: '<]-token>' })
      else if (i === 123) r.push({ type: '<{-token>' })
      else if (i === 125) r.push({ type: '<}-token>' })
      else if (i >= 48 && i <= 57) {
        var o = Xd(t, n),
          V = un(o, 2),
          l = V[0],
          b = V[1]
        b[0] === '<dimension-token>'
          ? r.push({
              type: '<dimension-token>',
              value: b[1],
              unit: b[2].toLowerCase(),
              flag: 'number',
            })
          : b[0] === '<number-token>'
          ? r.push({ type: b[0], value: b[1], flag: b[2] })
          : r.push({ type: b[0], value: b[1], flag: 'number' }),
          (n = l)
      } else if (i === 95 || (i >= 65 && i <= 90) || (i >= 97 && i <= 122) || i >= 128) {
        var o = pE(t, n)
        if (o === null) return null
        var ie = un(o, 3),
          l = ie[0],
          c = ie[1],
          A = ie[2]
        r.push({ type: A, value: c }), (n = l)
      } else r.push({ type: '<delim-token>', value: i })
    }
    return r.push({ type: '<EOF-token>' }), r
  },
  hE = function (t, n) {
    if (t.length <= n + 1) return null
    for (var r = t.charCodeAt(n), i = [], s = n + 1; s < t.length; s += 1) {
      var o = t.charCodeAt(s)
      if (o === r) return [s, String.fromCharCode.apply(null, i)]
      if (o === 92) {
        var a = od(t, s)
        if (a === null) return null
        var l = un(a, 2),
          c = l[0],
          u = l[1]
        i.push(u), (s = c)
      } else {
        if (o === 10) return null
        i.push(o)
      }
    }
    return null
  },
  Fk = function (t, n) {
    if (t.length <= n) return !1
    var r = t.charCodeAt(n)
    if (r === 45) {
      if (t.length <= n + 1) return !1
      var i = t.charCodeAt(n + 1)
      if (i === 45 || i === 95 || (i >= 65 && i <= 90) || (i >= 97 && i <= 122) || i >= 128)
        return !0
      if (i === 92) {
        if (t.length <= n + 2) return !1
        var s = t.charCodeAt(n + 2)
        return s !== 10
      } else return !1
    } else {
      if (r === 95 || (r >= 65 && r <= 90) || (r >= 97 && r <= 122) || r >= 128) return !0
      if (r === 92) {
        if (t.length <= n + 1) return !1
        var i = t.charCodeAt(n + 1)
        return i !== 10
      } else return !1
    }
  },
  od = function (t, n) {
    if (t.length <= n + 1 || t.charCodeAt(n) !== 92) return null
    var r = t.charCodeAt(n + 1)
    if (r === 10) return null
    if ((r >= 48 && r <= 57) || (r >= 65 && r <= 70) || (r >= 97 && r <= 102)) {
      for (var i = [r], s = Math.min(n + 7, t.length), o = n + 2; o < s; o += 1) {
        var a = t.charCodeAt(o)
        if ((a >= 48 && a <= 57) || (a >= 65 && a <= 70) || (a >= 97 && a <= 102)) i.push(a)
        else break
      }
      if (o < t.length) {
        var l = t.charCodeAt(o)
        ;(l === 9 || l === 32 || l === 10) && (o += 1)
      }
      return [o - 1, parseInt(String.fromCharCode.apply(null, i), 16)]
    } else return [n + 1, r]
  },
  Xd = function (t, n) {
    var r = vV(t, n)
    if (r === null) return null
    var i = un(r, 3),
      s = i[0],
      o = i[1],
      a = i[2],
      l = wb(t, s + 1)
    if (l !== null) {
      var c = un(l, 2),
        u = c[0],
        f = c[1]
      return [u, ['<dimension-token>', o, f]]
    }
    return s + 1 < t.length && t.charCodeAt(s + 1) === 37
      ? [s + 1, ['<percentage-token>', o]]
      : [s, ['<number-token>', o, a]]
  },
  vV = function (t, n) {
    if (t.length <= n) return null
    var r = 'integer',
      i = [],
      s = t.charCodeAt(n)
    for ((s === 43 || s === 45) && ((n += 1), s === 45 && i.push(45)); n < t.length; ) {
      var o = t.charCodeAt(n)
      if (o >= 48 && o <= 57) i.push(o), (n += 1)
      else break
    }
    if (n + 1 < t.length) {
      var a = t.charCodeAt(n),
        l = t.charCodeAt(n + 1)
      if (a === 46 && l >= 48 && l <= 57)
        for (i.push(a, l), r = 'number', n += 2; n < t.length; ) {
          var o = t.charCodeAt(n)
          if (o >= 48 && o <= 57) i.push(o), (n += 1)
          else break
        }
    }
    if (n + 1 < t.length) {
      var a = t.charCodeAt(n),
        l = t.charCodeAt(n + 1),
        c = t.charCodeAt(n + 2)
      if (a === 69 || a === 101) {
        var u = l >= 48 && l <= 57
        if (u || ((l === 43 || l === 45) && c >= 48 && c <= 57))
          for (
            r = 'number',
              u
                ? (i.push(69, l), (n += 2))
                : l === 45
                ? (i.push(69, 45, c), (n += 3))
                : (i.push(69, c), (n += 3));
            n < t.length;

          ) {
            var o = t.charCodeAt(n)
            if (o >= 48 && o <= 57) i.push(o), (n += 1)
            else break
          }
      }
    }
    var f = String.fromCharCode.apply(null, i),
      d = r === 'number' ? parseFloat(f) : parseInt(f)
    return d === -0 && (d = 0), Number.isNaN(d) ? null : [n - 1, d, r]
  },
  wV = function (t, n) {
    if (t.length <= n) return null
    for (var r = [], i = t.charCodeAt(n); n < t.length; i = t.charCodeAt(++n)) {
      if (
        i === 45 ||
        i === 95 ||
        (i >= 65 && i <= 90) ||
        (i >= 97 && i <= 122) ||
        i >= 128 ||
        (i >= 48 && i <= 57)
      ) {
        r.push(i)
        continue
      } else {
        var s = od(t, n)
        if (s !== null) {
          var o = un(s, 2),
            a = o[0],
            l = o[1]
          r.push(l), (n = a)
          continue
        }
      }
      break
    }
    return n === 0 ? null : [n - 1, String.fromCharCode.apply(null, r)]
  },
  wb = function (t, n) {
    if (t.length <= n || !Fk(t, n)) return null
    for (var r = [], i = t.charCodeAt(n); n < t.length; i = t.charCodeAt(++n)) {
      if (
        i === 45 ||
        i === 95 ||
        (i >= 65 && i <= 90) ||
        (i >= 97 && i <= 122) ||
        i >= 128 ||
        (i >= 48 && i <= 57)
      ) {
        r.push(i)
        continue
      } else {
        var s = od(t, n)
        if (s !== null) {
          var o = un(s, 2),
            a = o[0],
            l = o[1]
          r.push(l), (n = a)
          continue
        }
      }
      break
    }
    return [n - 1, String.fromCharCode.apply(null, r)]
  },
  bV = function (t, n) {
    for (var r = t.charCodeAt(n); r === 9 || r === 32 || r === 10; ) r = t.charCodeAt(++n)
    for (var i = [], s = !1; n < t.length; ) {
      if (r === 41) return [n, String.fromCharCode.apply(null, i)]
      if (r === 34 || r === 39 || r === 40) return null
      if (r === 9 || r === 32 || r === 10) !s && i.length !== 0 && (s = !0)
      else if (r === 92) {
        var o = od(t, n)
        if (o === null || s) return null
        var a = un(o, 2),
          l = a[0],
          c = a[1]
        i.push(c), (n = l)
      } else {
        if (s) return null
        i.push(r)
      }
      r = t.charCodeAt(++n)
    }
    return null
  },
  pE = function (t, n) {
    var r = wb(t, n)
    if (r === null) return null
    var i = un(r, 2),
      s = i[0],
      o = i[1]
    if (o.toLowerCase() === 'url') {
      if (t.length > s + 1) {
        var a = t.charCodeAt(s + 1)
        if (a === 40) {
          for (var l = 2; s + l < t.length; l += 1) {
            var c = t.charCodeAt(s + l)
            if (c === 34 || c === 39) return [s + 1, o.toLowerCase(), '<function-token>']
            if (c !== 9 && c !== 32 && c !== 10) {
              var u = bV(t, s + l)
              if (u === null) return null
              var f = un(u, 2),
                d = f[0],
                p = f[1]
              return [d, p, '<url-token>']
            }
          }
          return [s + 1, o.toLowerCase(), '<function-token>']
        }
      }
    } else if (t.length > s + 1) {
      var a = t.charCodeAt(s + 1)
      if (a === 40) return [s + 1, o.toLowerCase(), '<function-token>']
    }
    return [s, o.toLowerCase(), '<ident-token>']
  },
  xV = function (t) {
    for (var n = t.length - 1; n >= 0; n--) t[n] = SV(t[n])
    return t
  },
  SV = function (t) {
    if (t.mediaCondition === null) return t
    var n = EV(t.mediaCondition)
    return (
      n.operator === null &&
        n.children.length === 1 &&
        'children' in n.children[0] &&
        (n = n.children[0]),
      { mediaPrefix: t.mediaPrefix, mediaType: t.mediaType, mediaCondition: n }
    )
  },
  EV = function e(t) {
    for (var n = t.children.length - 1; n >= 0; n--) {
      var r = t.children[n]
      if (!('context' in r)) {
        var i = e(r)
        if (i.operator === null && i.children.length === 1) t.children[n] = i.children[0]
        else if (i.operator === t.operator && (i.operator === 'and' || i.operator === 'or')) {
          for (var s = [n, 1], o = 0; o < i.children.length; o++) s.push(i.children[o])
          t.children.splice.apply(t.children, s)
        }
      }
    }
    return t
  },
  ir = function (t, n) {
    return n instanceof Error
      ? new Error(
          ''
            .concat(
              n.message.trim(),
              `
`
            )
            .concat(t.trim())
        )
      : new Error(t.trim())
  },
  CV = function (t) {
    return xV(_V(t))
  },
  _V = function (t) {
    var n = yV(t.trim())
    if (n === null) throw ir('Failed tokenizing')
    var r = 0,
      i = n.length - 1
    if (n[0].type === '<at-keyword-token>' && n[0].value === 'media') {
      if (n[1].type !== '<whitespace-token>') throw ir('Expected whitespace after media')
      r = 2
      for (var s = 2; s < n.length - 1; s++) {
        var o = n[s]
        if (o.type === '<{-token>') {
          i = s
          break
        } else if (o.type === '<semicolon-token>')
          throw ir("Expected '{' in media query but found ';'")
      }
    }
    return (n = n.slice(r, i)), kV(n)
  },
  OV = function (t) {
    for (var n = [], r = !1, i = 0; i < t.length; i++)
      t[i].type === '<whitespace-token>'
        ? ((r = !0), n.length > 0 && (n[n.length - 1].wsAfter = !0))
        : (n.push(o0(o0({}, t[i]), { wsBefore: r, wsAfter: !1 })), (r = !1))
    return n
  },
  kV = function (t) {
    for (var n, r, i = [[]], s = 0; s < t.length; s++) {
      var o = t[s]
      o.type === '<comma-token>' ? i.push([]) : i[i.length - 1].push(o)
    }
    var a = i.map(OV)
    if (a.length === 1 && a[0].length === 0)
      return [{ mediaCondition: null, mediaPrefix: null, mediaType: 'all' }]
    var l = a.map(function (p) {
        return p.length === 0 ? null : TV(p)
      }),
      c = []
    try {
      for (var u = hV(l), f = u.next(); !f.done; f = u.next()) {
        var d = f.value
        d !== null && c.push(d)
      }
    } catch (p) {
      n = { error: p }
    } finally {
      try {
        f && !f.done && (r = u.return) && r.call(u)
      } finally {
        if (n) throw n.error
      }
    }
    if (c.length === 0) throw ir('No valid media queries')
    return c
  },
  TV = function (t) {
    var n = t[0]
    if (n.type === '<(-token>')
      try {
        return { mediaPrefix: null, mediaType: 'all', mediaCondition: Dm(t, !0) }
      } catch (f) {
        throw ir("Expected media condition after '('", f)
      }
    else if (n.type === '<ident-token>') {
      var r = null,
        i = void 0,
        s = n.value
      ;(s === 'only' || s === 'not') && (r = s)
      var o = r === null ? 0 : 1
      if (t.length <= o) throw ir('Expected extra token in media query')
      var a = t[o]
      if (a.type === '<ident-token>') {
        var l = a.value
        if (l === 'all') i = 'all'
        else if (l === 'print' || l === 'screen') i = l
        else if (
          l === 'tty' ||
          l === 'tv' ||
          l === 'projection' ||
          l === 'handheld' ||
          l === 'braille' ||
          l === 'embossed' ||
          l === 'aural' ||
          l === 'speech'
        )
          (r = r === 'not' ? null : 'not'), (i = 'all')
        else throw ir("Unknown ident '".concat(l, "' in media query"))
      } else if (r === 'not' && a.type === '<(-token>') {
        var c = [{ type: '<(-token>', wsBefore: !1, wsAfter: !1 }]
        c.push.apply(c, t), c.push({ type: '<)-token>', wsBefore: !1, wsAfter: !1 })
        try {
          return { mediaPrefix: null, mediaType: 'all', mediaCondition: Dm(c, !0) }
        } catch (f) {
          throw ir("Expected media condition after '('", f)
        }
      } else throw ir('Invalid media query')
      if (o + 1 === t.length) return { mediaPrefix: r, mediaType: i, mediaCondition: null }
      if (o + 4 < t.length) {
        var u = t[o + 1]
        if (u.type === '<ident-token>' && u.value === 'and')
          try {
            return { mediaPrefix: r, mediaType: i, mediaCondition: Dm(t.slice(o + 2), !1) }
          } catch (f) {
            throw ir("Expected media condition after 'and'", f)
          }
        else throw ir("Expected 'and' after media prefix")
      } else throw ir('Expected media condition after media prefix')
    } else throw ir('Expected media condition or media prefix')
  },
  Dm = function e(t, n, r) {
    if (
      (r === void 0 && (r = null),
      t.length < 3 || t[0].type !== '<(-token>' || t[t.length - 1].type !== '<)-token>')
    )
      throw new Error('Invalid media condition')
    for (var i = t.length - 1, s = 0, o = 0, a = 0; a < t.length; a++) {
      var l = t[a]
      if (
        (l.type === '<(-token>'
          ? ((o += 1), (s = Math.max(s, o)))
          : l.type === '<)-token>' && (o -= 1),
        o === 0)
      ) {
        i = a
        break
      }
    }
    if (o !== 0)
      throw new Error(`Mismatched parens
Invalid media condition`)
    var c,
      u = t.slice(0, i + 1)
    if (
      (s === 1
        ? (c = AV(u))
        : u[1].type === '<ident-token>' && u[1].value === 'not'
        ? (c = e(u.slice(2, -1), !0, 'not'))
        : (c = e(u.slice(1, -1), !0)),
      i === t.length - 1)
    )
      return { operator: r, children: [c] }
    var f = t[i + 1]
    if (f.type !== '<ident-token>')
      throw new Error(`Invalid operator
Invalid media condition`)
    if (r !== null && r !== f.value)
      throw new Error(
        "'".concat(f.value, "' and '").concat(
          r,
          `' must not be at same level
Invalid media condition`
        )
      )
    if (f.value === 'or' && !n)
      throw new Error(`Cannot use 'or' at top level of a media query
Invalid media condition`)
    if (f.value !== 'and' && f.value !== 'or')
      throw new Error(
        "Invalid operator: '".concat(
          f.value,
          `'
Invalid media condition`
        )
      )
    var d = e(t.slice(i + 2), n, f.value)
    return { operator: f.value, children: [c].concat(d.children) }
  },
  AV = function (t) {
    if (t.length < 3 || t[0].type !== '<(-token>' || t[t.length - 1].type !== '<)-token>')
      throw new Error('Invalid media feature')
    for (var n = [t[0]], r = 1; r < t.length; r++) {
      if (r < t.length - 2) {
        var i = t[r],
          s = t[r + 1],
          o = t[r + 2]
        if (
          i.type === '<number-token>' &&
          i.value > 0 &&
          s.type === '<delim-token>' &&
          s.value === 47 &&
          o.type === '<number-token>' &&
          o.value > 0
        ) {
          n.push({
            type: '<ratio-token>',
            numerator: i.value,
            denominator: o.value,
            wsBefore: i.wsBefore,
            wsAfter: o.wsAfter,
          }),
            (r += 2)
          continue
        }
      }
      n.push(t[r])
    }
    var a = n[1]
    if (a.type === '<ident-token>' && n.length === 3)
      return { context: 'boolean', feature: a.value }
    if (n.length === 5 && n[1].type === '<ident-token>' && n[2].type === '<colon-token>') {
      var l = n[3]
      if (
        l.type === '<number-token>' ||
        l.type === '<dimension-token>' ||
        l.type === '<ratio-token>' ||
        l.type === '<ident-token>'
      ) {
        var c = n[1].value,
          u = null,
          f = c.slice(0, 4)
        f === 'min-'
          ? ((u = 'min'), (c = c.slice(4)))
          : f === 'max-' && ((u = 'max'), (c = c.slice(4))),
          l.wsBefore,
          l.wsAfter
        var d = Yv(l, ['wsBefore', 'wsAfter'])
        return { context: 'value', prefix: u, feature: c, value: d }
      }
    } else if (n.length >= 5)
      try {
        var p = RV(n)
        return { context: 'range', feature: p.featureName, range: p }
      } catch (h) {
        throw ir('Invalid media feature', h)
      }
    throw new Error('Invalid media feature')
  },
  RV = function (t) {
    var n, r, i, s
    if (t.length < 5 || t[0].type !== '<(-token>' || t[t.length - 1].type !== '<)-token>')
      throw new Error('Invalid range')
    var o = { leftToken: null, leftOp: null, featureName: '', rightOp: null, rightToken: null },
      a =
        t[1].type === '<number-token>' ||
        t[1].type === '<dimension-token>' ||
        t[1].type === '<ratio-token>' ||
        (t[1].type === '<ident-token>' && t[1].value === 'infinite')
    if (t[2].type === '<delim-token>') {
      if (t[2].value === 60)
        t[3].type === '<delim-token>' && t[3].value === 61 && !t[3].wsBefore
          ? (o[a ? 'leftOp' : 'rightOp'] = '<=')
          : (o[a ? 'leftOp' : 'rightOp'] = '<')
      else if (t[2].value === 62)
        t[3].type === '<delim-token>' && t[3].value === 61 && !t[3].wsBefore
          ? (o[a ? 'leftOp' : 'rightOp'] = '>=')
          : (o[a ? 'leftOp' : 'rightOp'] = '>')
      else if (t[2].value === 61) o[a ? 'leftOp' : 'rightOp'] = '='
      else throw new Error('Invalid range')
      if (a) o.leftToken = t[1]
      else if (t[1].type === '<ident-token>') o.featureName = t[1].value
      else throw new Error('Invalid range')
      var l =
          2 +
          ((r = (n = o[a ? 'leftOp' : 'rightOp']) === null || n === void 0 ? void 0 : n.length) !==
            null && r !== void 0
            ? r
            : 0),
        c = t[l]
      if (a)
        if (c.type === '<ident-token>') {
          if (((o.featureName = c.value), t.length >= 7)) {
            var u = t[l + 1],
              f = t[l + 2]
            if (u.type === '<delim-token>') {
              var d = u.value
              if (d === 60)
                f.type === '<delim-token>' && f.value === 61 && !f.wsBefore
                  ? (o.rightOp = '<=')
                  : (o.rightOp = '<')
              else if (d === 62)
                f.type === '<delim-token>' && f.value === 61 && !f.wsBefore
                  ? (o.rightOp = '>=')
                  : (o.rightOp = '>')
              else throw new Error('Invalid range')
              var p =
                t[
                  l +
                    1 +
                    ((s = (i = o.rightOp) === null || i === void 0 ? void 0 : i.length) !== null &&
                    s !== void 0
                      ? s
                      : 0)
                ]
              o.rightToken = p
            } else throw new Error('Invalid range')
          } else if (l + 2 !== t.length) throw new Error('Invalid range')
        } else throw new Error('Invalid range')
      else o.rightToken = c
      var h = null,
        m = o.leftToken,
        b = o.leftOp,
        y = o.featureName,
        v = o.rightOp,
        S = o.rightToken,
        T = null
      if (m !== null) {
        if (m.type === '<ident-token>') {
          var A = m.type,
            I = m.value
          I === 'infinite' && (T = { type: A, value: I })
        } else if (
          m.type === '<number-token>' ||
          m.type === '<dimension-token>' ||
          m.type === '<ratio-token>'
        ) {
          m.wsBefore, m.wsAfter
          var k = Yv(m, ['wsBefore', 'wsAfter'])
          T = k
        }
      }
      var D = null
      if (S !== null) {
        if (S.type === '<ident-token>') {
          var A = S.type,
            I = S.value
          I === 'infinite' && (D = { type: A, value: I })
        } else if (
          S.type === '<number-token>' ||
          S.type === '<dimension-token>' ||
          S.type === '<ratio-token>'
        ) {
          S.wsBefore, S.wsAfter
          var F = Yv(S, ['wsBefore', 'wsAfter'])
          D = F
        }
      }
      if (T !== null && D !== null)
        if ((b === '<' || b === '<=') && (v === '<' || v === '<='))
          h = { leftToken: T, leftOp: b, featureName: y, rightOp: v, rightToken: D }
        else if ((b === '>' || b === '>=') && (v === '>' || v === '>='))
          h = { leftToken: T, leftOp: b, featureName: y, rightOp: v, rightToken: D }
        else throw new Error('Invalid range')
      else
        T === null && b === null && v !== null && D !== null
          ? (h = { leftToken: T, leftOp: b, featureName: y, rightOp: v, rightToken: D })
          : T !== null &&
            b !== null &&
            v === null &&
            D === null &&
            (h = { leftToken: T, leftOp: b, featureName: y, rightOp: v, rightToken: D })
      return h
    } else throw new Error('Invalid range')
  }
function PV(e, t) {
  if (typeof e != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || 'default')
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function IV(e) {
  var t = PV(e, 'string')
  return typeof t == 'symbol' ? t : String(t)
}
function DV(e, t, n) {
  return (
    (t = IV(t)),
    t in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function gE(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Nm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? gE(Object(n), !0).forEach(function (r) {
          DV(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : gE(Object(n)).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
  }
  return e
}
function NV(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    s
  for (s = 0; s < r.length; s++) (i = r[s]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function mE(e, t) {
  if (e == null) return {}
  var n = NV(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r])
  }
  return n
}
function hu(e, t) {
  for (var n in e) t(e[n], n)
}
function al(e, t) {
  var n = {}
  for (var r in e) t.indexOf(r) === -1 && (n[r] = e[r])
  return n
}
function MV(e, t) {
  var n = {}
  for (var r in e) n[t(e[r], r)] = e[r]
  return n
}
var yE
function jV(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
}
var LV = (e, t) => {
  var n = () => {
      var i = new RegExp('.'.concat(jV(vb(t, { isIdentifier: !0 }))), 'g')
      return e.replace(i, '&')
    },
    r
  try {
    r = cV(e)
  } catch {
    throw new Error('Invalid selector: '.concat(n()))
  }
  r.forEach((i) => {
    try {
      for (var s = i.length - 1; s >= -1; s--) {
        if (!i[s]) throw new Error()
        var o = i[s]
        if (
          o.type === 'child' ||
          o.type === 'parent' ||
          o.type === 'sibling' ||
          o.type === 'adjacent' ||
          o.type === 'descendant'
        )
          throw new Error()
        if (o.type === 'attribute' && o.name === 'class' && o.value === t) return
      }
    } catch {
      throw new Error(
        Lk(
          yE ||
            (yE = Mk([
              `
        Invalid selector: `,
              `
    
        Style selectors must target the '&' character (along with any modifiers), e.g. `,
              ' or ',
              `.
        
        This is to ensure that each style block only affects the styling of a single class.
        
        If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of `,
              ") to 'parent', you should add ",
              ` to 'child').
        
        If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write `,
              ", you should instead write 'globalStyle(",
              `, { ... })'
      `,
            ])),
          n(),
          '`${parent} &`',
          '`${parent} &:hover`',
          '`& ${child}`',
          '`${parent} &`',
          '`& h1`',
          '`${parent} h1`'
        )
      )
    }
  })
}
class a0 {
  constructor() {
    ;(this.ruleset = new Map()), (this.precedenceLookup = new Map())
  }
  findOrCreateCondition(t) {
    var n = this.ruleset.get(t)
    return n || ((n = { query: t, rules: [], children: new a0() }), this.ruleset.set(t, n)), n
  }
  getConditionalRulesetByPath(t) {
    var n = this
    for (var r of t) {
      var i = n.findOrCreateCondition(r)
      n = i.children
    }
    return n
  }
  addRule(t, n, r) {
    var i = this.getConditionalRulesetByPath(r),
      s = i.findOrCreateCondition(n)
    if (!s) throw new Error('Failed to add conditional rule')
    s.rules.push(t)
  }
  addConditionPrecedence(t, n) {
    for (var r = this.getConditionalRulesetByPath(t), i = 0; i < n.length; i++) {
      var s,
        o = n[i],
        a = (s = r.precedenceLookup.get(o)) !== null && s !== void 0 ? s : new Set()
      for (var l of n.slice(i + 1)) a.add(l)
      r.precedenceLookup.set(o, a)
    }
  }
  isCompatible(t) {
    for (var [n, r] of this.precedenceLookup.entries())
      for (var i of r) {
        var s
        if ((s = t.precedenceLookup.get(i)) !== null && s !== void 0 && s.has(n)) return !1
      }
    for (var { query: o, children: a } of t.ruleset.values()) {
      var l = this.ruleset.get(o)
      if (l && !l.children.isCompatible(a)) return !1
    }
    return !0
  }
  merge(t) {
    for (var { query: n, rules: r, children: i } of t.ruleset.values()) {
      var s = this.ruleset.get(n)
      s
        ? (s.rules.push(...r), s.children.merge(i))
        : this.ruleset.set(n, { query: n, rules: r, children: i })
    }
    for (var [o, a] of t.precedenceLookup.entries()) {
      var l,
        c = (l = this.precedenceLookup.get(o)) !== null && l !== void 0 ? l : new Set()
      this.precedenceLookup.set(o, new Set([...c, ...a]))
    }
  }
  mergeIfCompatible(t) {
    return this.isCompatible(t) ? (this.merge(t), !0) : !1
  }
  getSortedRuleset() {
    var t = this,
      n = [],
      r = function (a) {
        var l = t.ruleset.get(i)
        if (!l) throw new Error("Can't find condition for ".concat(i))
        var c = n.findIndex((u) => a.has(u.query))
        c > -1 ? n.splice(c, 0, l) : n.push(l)
      }
    for (var [i, s] of this.precedenceLookup.entries()) r(s)
    return n
  }
  renderToArray() {
    var t = []
    for (var { query: n, rules: r, children: i } of this.getSortedRuleset()) {
      var s = {}
      for (var o of r) s[o.selector] = o.rule
      Object.assign(s, ...i.renderToArray()), t.push({ [n]: s })
    }
    return t
  }
}
var Bk = {
    ':-moz-any-link': !0,
    ':-moz-full-screen': !0,
    ':-moz-placeholder': !0,
    ':-moz-read-only': !0,
    ':-moz-read-write': !0,
    ':-ms-fullscreen': !0,
    ':-ms-input-placeholder': !0,
    ':-webkit-any-link': !0,
    ':-webkit-full-screen': !0,
    '::-moz-color-swatch': !0,
    '::-moz-list-bullet': !0,
    '::-moz-list-number': !0,
    '::-moz-page-sequence': !0,
    '::-moz-page': !0,
    '::-moz-placeholder': !0,
    '::-moz-progress-bar': !0,
    '::-moz-range-progress': !0,
    '::-moz-range-thumb': !0,
    '::-moz-range-track': !0,
    '::-moz-scrolled-page-sequence': !0,
    '::-moz-selection': !0,
    '::-ms-backdrop': !0,
    '::-ms-browse': !0,
    '::-ms-check': !0,
    '::-ms-clear': !0,
    '::-ms-fill-lower': !0,
    '::-ms-fill-upper': !0,
    '::-ms-fill': !0,
    '::-ms-reveal': !0,
    '::-ms-thumb': !0,
    '::-ms-ticks-after': !0,
    '::-ms-ticks-before': !0,
    '::-ms-tooltip': !0,
    '::-ms-track': !0,
    '::-ms-value': !0,
    '::-webkit-backdrop': !0,
    '::-webkit-inner-spin-button': !0,
    '::-webkit-input-placeholder': !0,
    '::-webkit-meter-bar': !0,
    '::-webkit-meter-even-less-good-value': !0,
    '::-webkit-meter-inner-element': !0,
    '::-webkit-meter-optimum-value': !0,
    '::-webkit-meter-suboptimum-value': !0,
    '::-webkit-outer-spin-button': !0,
    '::-webkit-progress-bar': !0,
    '::-webkit-progress-inner-element': !0,
    '::-webkit-progress-inner-value': !0,
    '::-webkit-progress-value': !0,
    '::-webkit-resizer': !0,
    '::-webkit-scrollbar-button': !0,
    '::-webkit-scrollbar-corner': !0,
    '::-webkit-scrollbar-thumb': !0,
    '::-webkit-scrollbar-track-piece': !0,
    '::-webkit-scrollbar-track': !0,
    '::-webkit-scrollbar': !0,
    '::-webkit-search-cancel-button': !0,
    '::-webkit-search-results-button': !0,
    '::-webkit-slider-runnable-track': !0,
    '::-webkit-slider-thumb': !0,
    '::after': !0,
    '::backdrop': !0,
    '::before': !0,
    '::cue': !0,
    '::file-selector-button': !0,
    '::first-letter': !0,
    '::first-line': !0,
    '::grammar-error': !0,
    '::marker': !0,
    '::placeholder': !0,
    '::selection': !0,
    '::spelling-error': !0,
    '::target-text': !0,
    '::view-transition-group': !0,
    '::view-transition-image-pair': !0,
    '::view-transition-new': !0,
    '::view-transition-old': !0,
    '::view-transition': !0,
    ':active': !0,
    ':after': !0,
    ':any-link': !0,
    ':before': !0,
    ':blank': !0,
    ':checked': !0,
    ':default': !0,
    ':defined': !0,
    ':disabled': !0,
    ':empty': !0,
    ':enabled': !0,
    ':first-child': !0,
    ':first-letter': !0,
    ':first-line': !0,
    ':first-of-type': !0,
    ':first': !0,
    ':focus-visible': !0,
    ':focus-within': !0,
    ':focus': !0,
    ':fullscreen': !0,
    ':hover': !0,
    ':in-range': !0,
    ':indeterminate': !0,
    ':invalid': !0,
    ':last-child': !0,
    ':last-of-type': !0,
    ':left': !0,
    ':link': !0,
    ':only-child': !0,
    ':only-of-type': !0,
    ':optional': !0,
    ':out-of-range': !0,
    ':placeholder-shown': !0,
    ':read-only': !0,
    ':read-write': !0,
    ':required': !0,
    ':right': !0,
    ':root': !0,
    ':scope': !0,
    ':target': !0,
    ':valid': !0,
    ':visited': !0,
  },
  $V = Object.keys(Bk),
  FV = Bk,
  vE,
  wE = (e, t) =>
    new Error(
      Lk(
        vE ||
          (vE = Mk([
            `
    Invalid media query: "`,
            `"

    `,
            `

    Read more on MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries
  `,
          ])),
        e,
        t
      )
    ),
  BV = (e) => {
    if (e === '@media ') throw wE(e, 'Query is empty')
    try {
      CV(e)
    } catch (t) {
      throw wE(e, t.message)
    }
  },
  UV = ['vars'],
  zV = ['content'],
  Uk = '__DECLARATION',
  WV = {
    animationIterationCount: !0,
    borderImage: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexShrink: !0,
    fontWeight: !0,
    gridArea: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnStart: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowStart: !0,
    initialLetter: !0,
    lineClamp: !0,
    lineHeight: !0,
    maxLines: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    scale: !0,
    tabSize: !0,
    WebkitLineClamp: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    maskBorder: !0,
    maskBorderOutset: !0,
    maskBorderSlice: !0,
    maskBorderWidth: !0,
    shapeImageThreshold: !0,
    stopOpacity: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  }
function VV(e) {
  return e
    .replace(/([A-Z])/g, '-$1')
    .replace(/^ms-/, '-ms-')
    .toLowerCase()
}
function HV(e, t, n, r) {
  var i = e.slice(0, t),
    s = e.slice(n)
  return ''.concat(i).concat(r).concat(s)
}
var qV = '  ',
  ll = [...$V, '@layer', '@media', '@supports', '@container', 'selectors']
class KV {
  constructor(t, n) {
    ;(this.rules = []),
      (this.conditionalRulesets = [new a0()]),
      (this.fontFaceRules = []),
      (this.keyframesRules = []),
      (this.localClassNamesMap = new Map(t.map((r) => [r, r]))),
      (this.localClassNamesSearch = new XW(t)),
      (this.layers = new Map()),
      (this.composedClassLists = n
        .map((r) => {
          var { identifier: i, classList: s } = r
          return { identifier: i, regex: RegExp('('.concat(s, ')'), 'g') }
        })
        .reverse())
  }
  processCssObj(t) {
    if (t.type === 'fontFace') {
      this.fontFaceRules.push(t.rule)
      return
    }
    if (t.type === 'keyframes') {
      ;(t.rule = Object.fromEntries(
        Object.entries(t.rule).map((s) => {
          var [o, a] = s
          return [o, this.transformProperties(a)]
        })
      )),
        this.keyframesRules.push(t)
      return
    }
    if (((this.currConditionalRuleset = new a0()), t.type === 'layer')) {
      var n = '@layer '.concat(t.name)
      this.addLayer([n])
    } else {
      var r = al(t.rule, ll)
      this.addRule({ selector: t.selector, rule: r }),
        this.transformLayer(t, t.rule['@layer']),
        this.transformMedia(t, t.rule['@media']),
        this.transformSupports(t, t.rule['@supports']),
        this.transformContainer(t, t.rule['@container']),
        this.transformSimplePseudos(t, t.rule),
        this.transformSelectors(t, t.rule)
    }
    var i = this.conditionalRulesets[this.conditionalRulesets.length - 1]
    i.mergeIfCompatible(this.currConditionalRuleset) ||
      this.conditionalRulesets.push(this.currConditionalRuleset)
  }
  addConditionalRule(t, n) {
    var r = this.transformVars(this.transformProperties(t.rule)),
      i = this.transformSelector(t.selector)
    if (!this.currConditionalRuleset) throw new Error("Couldn't add conditional rule")
    var s = n[n.length - 1],
      o = n.slice(0, n.length - 1)
    this.currConditionalRuleset.addRule({ selector: i, rule: r }, s, o)
  }
  addRule(t) {
    var n = this.transformVars(this.transformProperties(t.rule)),
      r = this.transformSelector(t.selector)
    this.rules.push({ selector: r, rule: n })
  }
  addLayer(t) {
    var n = t.join(' - ')
    this.layers.set(n, t)
  }
  transformProperties(t) {
    return this.transformContent(this.pixelifyProperties(t))
  }
  pixelifyProperties(t) {
    return (
      hu(t, (n, r) => {
        typeof n == 'number' && n !== 0 && !WV[r] && (t[r] = ''.concat(n, 'px'))
      }),
      t
    )
  }
  transformVars(t) {
    var { vars: n } = t,
      r = mE(t, UV)
    return n
      ? Nm(
          Nm(
            {},
            MV(n, (i, s) => Gv(s))
          ),
          r
        )
      : r
  }
  transformContent(t) {
    var { content: n } = t,
      r = mE(t, zV)
    if (typeof n > 'u') return r
    var i = Array.isArray(n) ? n : [n]
    return Nm(
      {
        content: i.map((s) =>
          s &&
          (s.includes('"') ||
            s.includes("'") ||
            /^([A-Za-z\-]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)(\s|$)/.test(
              s
            ))
            ? s
            : '"'.concat(s, '"')
        ),
      },
      r
    )
  }
  transformClassname(t) {
    return '.'.concat(vb(t, { isIdentifier: !0 }))
  }
  transformSelector(t) {
    var n = t,
      r = function (p) {
        n = n.replace(s, () => (nV(p), p))
      }
    for (var { identifier: i, regex: s } of this.composedClassLists) r(i)
    if (this.localClassNamesMap.has(n)) return this.transformClassname(n)
    for (
      var o = this.localClassNamesSearch.search(n), a = n.length, l = o.length - 1;
      l >= 0;
      l--
    ) {
      var [c, [u]] = o[l],
        f = c - u.length + 1
      f >= a || ((a = f), n[f - 1] !== '.' && (n = HV(n, f, c + 1, this.transformClassname(u))))
    }
    return n
  }
  transformSelectors(t, n, r) {
    hu(n.selectors, (i, s) => {
      if (t.type !== 'local')
        throw new Error(
          'Selectors are not allowed within '.concat(
            t.type === 'global' ? '"globalStyle"' : '"selectors"'
          )
        )
      var o = this.transformSelector(s.replace(RegExp('&', 'g'), t.selector))
      LV(o, t.selector)
      var a = { selector: o, rule: al(i, ll) }
      r ? this.addConditionalRule(a, r) : this.addRule(a)
      var l = { type: 'selector', selector: o, rule: i }
      this.transformLayer(l, i['@layer'], r),
        this.transformSupports(l, i['@supports'], r),
        this.transformMedia(l, i['@media'], r)
    })
  }
  transformMedia(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []
    if (n) {
      var i
      ;(i = this.currConditionalRuleset) === null ||
        i === void 0 ||
        i.addConditionPrecedence(
          r,
          Object.keys(n).map((c) => '@media '.concat(c))
        )
      for (var [s, o] of Object.entries(n)) {
        var a = '@media '.concat(s)
        BV(a)
        var l = [...r, a]
        this.addConditionalRule({ selector: t.selector, rule: al(o, ll) }, l),
          t.type === 'local' &&
            (this.transformSimplePseudos(t, o, l), this.transformSelectors(t, o, l)),
          this.transformLayer(t, o['@layer'], l),
          this.transformSupports(t, o['@supports'], l),
          this.transformContainer(t, o['@container'], l)
      }
    }
  }
  transformContainer(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []
    if (n) {
      var i
      ;(i = this.currConditionalRuleset) === null ||
        i === void 0 ||
        i.addConditionPrecedence(
          r,
          Object.keys(n).map((s) => '@container '.concat(s))
        ),
        hu(n, (s, o) => {
          var a = '@container '.concat(o),
            l = [...r, a]
          this.addConditionalRule({ selector: t.selector, rule: al(s, ll) }, l),
            t.type === 'local' &&
              (this.transformSimplePseudos(t, s, l), this.transformSelectors(t, s, l)),
            this.transformLayer(t, s['@layer'], l),
            this.transformSupports(t, s['@supports'], l),
            this.transformMedia(t, s['@media'], l)
        })
    }
  }
  transformLayer(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []
    if (n) {
      var i
      ;(i = this.currConditionalRuleset) === null ||
        i === void 0 ||
        i.addConditionPrecedence(
          r,
          Object.keys(n).map((s) => '@layer '.concat(s))
        ),
        hu(n, (s, o) => {
          var a = [...r, '@layer '.concat(o)]
          this.addLayer(a),
            this.addConditionalRule({ selector: t.selector, rule: al(s, ll) }, a),
            t.type === 'local' &&
              (this.transformSimplePseudos(t, s, a), this.transformSelectors(t, s, a)),
            this.transformMedia(t, s['@media'], a),
            this.transformSupports(t, s['@supports'], a),
            this.transformContainer(t, s['@container'], a)
        })
    }
  }
  transformSupports(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []
    if (n) {
      var i
      ;(i = this.currConditionalRuleset) === null ||
        i === void 0 ||
        i.addConditionPrecedence(
          r,
          Object.keys(n).map((s) => '@supports '.concat(s))
        ),
        hu(n, (s, o) => {
          var a = [...r, '@supports '.concat(o)]
          this.addConditionalRule({ selector: t.selector, rule: al(s, ll) }, a),
            t.type === 'local' &&
              (this.transformSimplePseudos(t, s, a), this.transformSelectors(t, s, a)),
            this.transformLayer(t, s['@layer'], a),
            this.transformMedia(t, s['@media'], a),
            this.transformContainer(t, s['@container'], a)
        })
    }
  }
  transformSimplePseudos(t, n, r) {
    for (var i of Object.keys(n))
      if (FV[i]) {
        if (t.type !== 'local')
          throw new Error(
            'Simple pseudos are not valid in '.concat(
              t.type === 'global' ? '"globalStyle"' : '"selectors"'
            )
          )
        r
          ? this.addConditionalRule({ selector: ''.concat(t.selector).concat(i), rule: n[i] }, r)
          : this.addRule({ conditions: r, selector: ''.concat(t.selector).concat(i), rule: n[i] })
      }
  }
  toCss() {
    var t = []
    for (var n of this.fontFaceRules) t.push(fa({ '@font-face': n }))
    for (var r of this.keyframesRules) t.push(fa({ ['@keyframes '.concat(r.name)]: r.rule }))
    for (var i of this.layers.values()) {
      var [s, ...o] = i.reverse(),
        a = { [s]: Uk }
      for (var l of o) a = { [l]: a }
      t.push(fa(a))
    }
    for (var c of this.rules) t.push(fa({ [c.selector]: c.rule }))
    for (var u of this.conditionalRulesets) for (var f of u.renderToArray()) t.push(fa(f))
    return t.filter(Boolean)
  }
}
function fa(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '',
    n = [],
    r = function (o) {
      var a = e[o]
      if (a && Array.isArray(a)) n.push(...a.map((c) => fa({ [o]: c }, t)))
      else if (a && typeof a == 'object') {
        var l = Object.keys(a).length === 0
        l ||
          n.push(
            ''
              .concat(t)
              .concat(
                o,
                ` {
`
              )
              .concat(
                fa(a, t + qV),
                `
`
              )
              .concat(t, '}')
          )
      } else
        a === Uk
          ? n.push(''.concat(t).concat(o, ';'))
          : n.push(
              ''
                .concat(t)
                .concat(o.startsWith('--') ? o : VV(o), ': ')
                .concat(a, ';')
            )
    }
  for (var i of Object.keys(e)) r(i)
  return n.join(`
`)
}
function GV(e) {
  var { localClassNames: t, cssObjs: n, composedClassLists: r } = e,
    i = new KV(t, r)
  for (var s of n) i.processCssObj(s)
  return i.toCss()
}
var YV = function (t) {
  return QV(t) && !XV(t)
}
function QV(e) {
  return !!e && typeof e == 'object'
}
function XV(e) {
  var t = Object.prototype.toString.call(e)
  return t === '[object RegExp]' || t === '[object Date]' || eH(e)
}
var ZV = typeof Symbol == 'function' && Symbol.for,
  JV = ZV ? Symbol.for('react.element') : 60103
function eH(e) {
  return e.$$typeof === JV
}
function tH(e) {
  return Array.isArray(e) ? [] : {}
}
function Of(e, t) {
  return t.clone !== !1 && t.isMergeableObject(e) ? kf(tH(e), e, t) : e
}
function nH(e, t, n) {
  return e.concat(t).map(function (r) {
    return Of(r, n)
  })
}
function rH(e, t) {
  if (!t.customMerge) return kf
  var n = t.customMerge(e)
  return typeof n == 'function' ? n : kf
}
function iH(e) {
  return Object.getOwnPropertySymbols
    ? Object.getOwnPropertySymbols(e).filter(function (t) {
        return Object.propertyIsEnumerable.call(e, t)
      })
    : []
}
function bE(e) {
  return Object.keys(e).concat(iH(e))
}
function zk(e, t) {
  try {
    return t in e
  } catch {
    return !1
  }
}
function sH(e, t) {
  return zk(e, t) && !(Object.hasOwnProperty.call(e, t) && Object.propertyIsEnumerable.call(e, t))
}
function oH(e, t, n) {
  var r = {}
  return (
    n.isMergeableObject(e) &&
      bE(e).forEach(function (i) {
        r[i] = Of(e[i], n)
      }),
    bE(t).forEach(function (i) {
      sH(e, i) ||
        (zk(e, i) && n.isMergeableObject(t[i])
          ? (r[i] = rH(i, n)(e[i], t[i], n))
          : (r[i] = Of(t[i], n)))
    }),
    r
  )
}
function kf(e, t, n) {
  ;(n = n || {}),
    (n.arrayMerge = n.arrayMerge || nH),
    (n.isMergeableObject = n.isMergeableObject || YV),
    (n.cloneUnlessOtherwiseSpecified = Of)
  var r = Array.isArray(t),
    i = Array.isArray(e),
    s = r === i
  return s ? (r ? n.arrayMerge(e, t, n) : oH(e, t, n)) : Of(t, n)
}
kf.all = function (t, n) {
  if (!Array.isArray(t)) throw new Error('first argument should be an array')
  return t.reduce(function (r, i) {
    return kf(r, i, n)
  }, {})
}
var xE = new Set(),
  SE = [],
  Mm = [],
  aH = {
    appendCss: (e) => {
      Mm.push(e)
    },
    registerClassName: (e) => {
      xE.add(e)
    },
    registerComposition: (e) => {
      SE.push(e)
    },
    markCompositionUsed: () => {},
    onEndFileScope: (e) => {
      var t = GV({ localClassNames: Array.from(xE), composedClassLists: SE, cssObjs: Mm }).join(`
`)
      WW({ fileScope: e, css: t }), (Mm = [])
    },
    getIdentOption: () => 'short',
  }
eV(aH)
function lH(e, t) {
  return mb(e, (n, r) => {
    var i = typeof t == 'function' ? t(n, r) : n,
      s = typeof i == 'string' ? i.replace(/^\-\-/, '') : null
    if (typeof s != 'string' || s !== vb(s, { isIdentifier: !0 }))
      throw new Error('Invalid variable name for "'.concat(r.join('.'), '": ').concat(s))
    return 'var(--'.concat(s, ')')
  })
}
var cH = Object.create,
  Wk = Object.defineProperty,
  uH = Object.getOwnPropertyDescriptor,
  bb = Object.getOwnPropertyNames,
  fH = Object.getPrototypeOf,
  dH = Object.prototype.hasOwnProperty,
  hH = (e, t) =>
    function () {
      return e && (t = (0, e[bb(e)[0]])((e = 0))), t
    },
  pH = (e, t) =>
    function () {
      return t || (0, e[bb(e)[0]])((t = { exports: {} }).exports, t), t.exports
    },
  gH = (e, t, n, r) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let i of bb(t))
        !dH.call(e, i) &&
          i !== n &&
          Wk(e, i, { get: () => t[i], enumerable: !(r = uH(t, i)) || r.enumerable })
    return e
  },
  mH = (e, t, n) => (
    (n = e != null ? cH(fH(e)) : {}),
    gH(t || !e || !e.__esModule ? Wk(n, 'default', { value: e, enumerable: !0 }) : n, e)
  ),
  yH = (e, t, n) => {
    if (!t.has(e)) throw TypeError('Cannot ' + n)
  },
  Jo = (e, t, n) => (yH(e, t, 'read from private field'), n ? n.call(e) : t.get(e)),
  ea = (e, t, n) => {
    if (t.has(e)) throw TypeError('Cannot add the same private member more than once')
    t instanceof WeakSet ? t.add(e) : t.set(e, n)
  },
  vH = hH({
    'vanilla-extract-css-ns:src/components/styling/StyleMarker.css.ts.vanilla.css?source=OndoZXJlKCopIHsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIGNvbG9yOiB2YXIoLS1kYXBwLWtpdC1jb2xvcnMtYm9keSk7CiAgZm9udC1mYW1pbHk6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udEZhbWlseSk7CiAgZm9udC1zaXplOiB2YXIoLS1kYXBwLWtpdC1mb250V2VpZ2h0cy1ub3JtYWwpOwogIGZvbnQtc3R5bGU6IHZhcigtLWRhcHAta2l0LXR5cG9ncmFwaHktZm9udFN0eWxlKTsKICBmb250LXdlaWdodDogdmFyKC0tZGFwcC1raXQtZm9udFdlaWdodHMtbm9ybWFsKTsKICBsaW5lLWhlaWdodDogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1saW5lSGVpZ2h0KTsKICBsZXR0ZXItc3BhY2luZzogdmFyKC0tZGFwcC1raXQtdHlwb2dyYXBoeS1sZXR0ZXJTcGFjaW5nKTsKfQo6d2hlcmUoYnV0dG9uKSB7CiAgYXBwZWFyYW5jZTogbm9uZTsKICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7CiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7CiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7CiAgY29sb3I6IGluaGVyaXQ7CiAgYm9yZGVyOiAwOwogIHBhZGRpbmc6IDA7CiAgbWFyZ2luOiAwOwp9Cjp3aGVyZShhKSB7CiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogIGNvbG9yOiBpbmhlcml0OwogIG91dGxpbmU6IG5vbmU7Cn0KOndoZXJlKG9sLCB1bCkgewogIGxpc3Qtc3R5bGU6IG5vbmU7CiAgbWFyZ2luOiAwOwogIHBhZGRpbmc6IDA7Cn0KOndoZXJlKGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYpIHsKICBmb250LXNpemU6IGluaGVyaXQ7CiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7CiAgbWFyZ2luOiAwOwp9'() {},
  }),
  wH = pH({
    'src/components/styling/StyleMarker.css.ts'() {
      vH()
    },
  }),
  ad = {
    all: { baseScope: 'wallet' },
    connectWallet: no('connect-wallet'),
    autoconnectWallet: no('autoconnect-wallet'),
    disconnectWallet: no('disconnect-wallet'),
    signPersonalMessage: no('sign-personal-message'),
    signTransaction: no('sign-transaction'),
    signAndExecuteTransaction: no('sign-and-execute-transaction'),
    switchAccount: no('switch-account'),
    reportTransactionEffects: no('report-transaction-effects'),
  }
function no(e) {
  return function (n = []) {
    return [{ ...ad.all, baseEntity: e }, ...n]
  }
}
var Vk = w.createContext(null)
function $n(e) {
  const t = w.useContext(Vk)
  if (!t)
    throw new Error('Could not find WalletContext. Ensure that you have set up the WalletProvider.')
  return V7(t, e)
}
function xb({ mutationKey: e, ...t } = {}) {
  const n = $n((i) => i.setWalletConnected),
    r = $n((i) => i.setConnectionStatus)
  return X0({
    mutationKey: ad.connectWallet(e),
    mutationFn: async ({ wallet: i, accountAddress: s, ...o }) => {
      try {
        r('connecting')
        const a = await i.features['standard:connect'].connect(o),
          l = a.accounts.filter((u) => u.chains.some((f) => f.split(':')[0] === 'sui')),
          c = bH(l, s)
        return n(i, l, c, a.supportedIntents), { accounts: l }
      } catch (a) {
        throw (r('disconnected'), a)
      }
    },
    ...t,
  })
}
function bH(e, t) {
  return e.length === 0 ? null : t ? e.find((r) => r.address === t) ?? e[0] : e[0]
}
function Jh(e, t) {
  const i = J0()
    .get()
    .filter((s) => vF(s) && (!t || t(s)))
  return [
    ...e.map((s) => i.find((o) => o.name === s)).filter(Boolean),
    ...i.filter((s) => !e.includes(s.name)),
  ]
}
function Ra(e) {
  return (e == null ? void 0 : e.id) ?? (e == null ? void 0 : e.name)
}
function xH(e) {
  return E.jsx('svg', {
    width: 24,
    height: 24,
    fill: 'none',
    xmlns: 'http://www.w3.org/2000/svg',
    ...e,
    children: E.jsx('path', {
      d: 'M7.57 12.262c0 .341.13.629.403.895l5.175 5.059c.204.205.45.307.751.307.609 0 1.101-.485 1.101-1.087 0-.293-.123-.574-.349-.8L10.14 12.27l4.511-4.375A1.13 1.13 0 0 0 15 7.087C15 6.485 14.508 6 13.9 6c-.295 0-.54.103-.752.308l-5.175 5.058c-.28.28-.404.56-.404.896Z',
      fill: 'currentColor',
    }),
  })
}
function SH(e) {
  return E.jsx('svg', {
    width: 10,
    height: 10,
    fill: 'none',
    xmlns: 'http://www.w3.org/2000/svg',
    ...e,
    children: E.jsx('path', {
      d: 'M9.708.292a.999.999 0 0 0-1.413 0l-3.289 3.29L1.717.291A.999.999 0 0 0 .305 1.705l3.289 3.289-3.29 3.289a.999.999 0 1 0 1.413 1.412l3.29-3.289 3.288 3.29a.999.999 0 0 0 1.413-1.413l-3.29-3.29 3.29-3.288a.999.999 0 0 0 0-1.413Z',
      fill: 'currentColor',
    }),
  })
}
var Hk = 'data-dapp-kit',
  EH = `[${Hk}]`,
  CH = { [Hk]: '' }
mH(wH())
var Tf = w.forwardRef(({ children: e, ...t }, n) => E.jsx(Ii, { ref: n, ...t, ...CH, children: e }))
Tf.displayName = 'StyleMarker'
var _H = Zw({
    defaultClassName: 'Heading__1aa835k0',
    variantClassNames: {
      size: {
        sm: 'Heading_headingVariants_size_sm__1aa835k1',
        md: 'Heading_headingVariants_size_md__1aa835k2',
        lg: 'Heading_headingVariants_size_lg__1aa835k3',
        xl: 'Heading_headingVariants_size_xl__1aa835k4',
      },
      weight: {
        normal: 'Heading_headingVariants_weight_normal__1aa835k5',
        bold: 'Heading_headingVariants_weight_bold__1aa835k6',
      },
      truncate: { true: 'Heading_headingVariants_truncate_true__1aa835k7' },
    },
    defaultVariants: { size: 'lg', weight: 'bold' },
    compoundVariants: [],
  }),
  Xa = w.forwardRef(
    (
      {
        children: e,
        className: t,
        asChild: n = !1,
        as: r = 'h1',
        size: i,
        weight: s,
        truncate: o,
        ...a
      },
      l
    ) =>
      E.jsx(Ii, {
        ...a,
        ref: l,
        className: Ms(_H({ size: i, weight: s, truncate: o }), t),
        children: n ? e : E.jsx(r, { children: e }),
      })
  )
Xa.displayName = 'Heading'
var OH = 'IconButton_container__s6n7bq0',
  Qv = w.forwardRef(({ className: e, asChild: t = !1, ...n }, r) => {
    const i = t ? Ii : 'button'
    return E.jsx(i, { ...n, className: Ms(OH, e), ref: r })
  })
Qv.displayName = 'Button'
var kH = 'ConnectModal_backButtonContainer__gz8z96',
  TH = 'ConnectModal_closeButtonContainer__gz8z97',
  AH = 'ConnectModal_content__gz8z92',
  RH = 'ConnectModal_overlay__gz8z90',
  PH = 'ConnectModal_selectedViewContainer__gz8z95',
  IH = 'ConnectModal_title__gz8z91',
  DH = 'ConnectModal_viewContainer__gz8z94',
  NH = 'ConnectModal_walletListContainer__gz8z99',
  MH = 'ConnectModal_walletListContainerWithViewSelected__gz8z9a',
  jH = 'ConnectModal_walletListContent__gz8z98',
  LH = 'ConnectModal_whatIsAWalletButton__gz8z93',
  $H = Zw({
    defaultClassName: 'Button_buttonVariants__x1s81q0',
    variantClassNames: {
      variant: {
        primary: 'Button_buttonVariants_variant_primary__x1s81q1',
        outline: 'Button_buttonVariants_variant_outline__x1s81q2',
      },
      size: {
        md: 'Button_buttonVariants_size_md__x1s81q3',
        lg: 'Button_buttonVariants_size_lg__x1s81q4',
      },
    },
    defaultVariants: { variant: 'primary', size: 'md' },
    compoundVariants: [],
  }),
  ld = w.forwardRef(({ className: e, variant: t, size: n, asChild: r = !1, ...i }, s) => {
    const o = r ? Ii : 'button'
    return E.jsx(o, { ...i, className: Ms($H({ variant: t, size: n }), e), ref: s })
  })
ld.displayName = 'Button'
var FH = Zw({
    defaultClassName: 'Text__2bv1ur0',
    variantClassNames: {
      size: { sm: 'Text_textVariants_size_sm__2bv1ur1' },
      weight: {
        normal: 'Text_textVariants_weight_normal__2bv1ur2',
        medium: 'Text_textVariants_weight_medium__2bv1ur3',
        bold: 'Text_textVariants_weight_bold__2bv1ur4',
      },
      color: {
        muted: 'Text_textVariants_color_muted__2bv1ur5',
        danger: 'Text_textVariants_color_danger__2bv1ur6',
      },
      mono: { true: 'Text_textVariants_mono_true__2bv1ur7' },
    },
    defaultVariants: { size: 'sm', weight: 'normal' },
    compoundVariants: [],
  }),
  _c = w.forwardRef(
    (
      {
        children: e,
        className: t,
        asChild: n = !1,
        as: r = 'div',
        size: i,
        weight: s,
        color: o,
        mono: a,
        ...l
      },
      c
    ) =>
      E.jsx(Ii, {
        ...l,
        ref: c,
        className: Ms(FH({ size: i, weight: s, color: o, mono: a }), t),
        children: n ? e : E.jsx(r, { children: e }),
      })
  )
_c.displayName = 'Text'
var BH = 'ConnectionStatus_connectionStatus__nckm2d3',
  UH = 'ConnectionStatus_container__nckm2d0',
  zH = 'ConnectionStatus_retryButtonContainer__nckm2d4',
  WH = 'ConnectionStatus_title__nckm2d2',
  VH = 'ConnectionStatus_walletIcon__nckm2d1'
function HH({ selectedWallet: e, hadConnectionError: t, onRetryConnection: n }) {
  return E.jsxs('div', {
    className: UH,
    children: [
      E.jsx('img', { className: VH, src: e.icon, alt: `${e.name} logo` }),
      E.jsx('div', {
        className: WH,
        children: E.jsxs(Xa, { as: 'h2', size: 'xl', children: ['Opening ', e.name] }),
      }),
      E.jsx('div', {
        className: BH,
        children: t
          ? E.jsx(_c, { color: 'danger', children: 'Connection failed' })
          : E.jsx(_c, { color: 'muted', children: 'Confirm connection in the wallet...' }),
      }),
      t
        ? E.jsx('div', {
            className: zH,
            children: E.jsx(ld, {
              type: 'button',
              variant: 'outline',
              onClick: () => n(e),
              children: 'Retry Connection',
            }),
          })
        : null,
    ],
  })
}
var qH = 'InfoSection_container__1wtioi70'
function Ku({ title: e, children: t }) {
  return E.jsxs('section', {
    className: qH,
    children: [
      E.jsx(Xa, { as: 'h3', size: 'sm', weight: 'normal', children: e }),
      E.jsx(_c, { weight: 'medium', color: 'muted', children: t }),
    ],
  })
}
var KH = 'GettingStarted_container__1fp07e10',
  GH = 'GettingStarted_content__1fp07e11',
  YH = 'GettingStarted_installButtonContainer__1fp07e12'
function QH() {
  return E.jsxs('div', {
    className: KH,
    children: [
      E.jsx(Xa, { as: 'h2', children: 'Get Started with Sui' }),
      E.jsxs('div', {
        className: GH,
        children: [
          E.jsx(Ku, {
            title: 'Install the Sui Wallet Extension',
            children: 'We recommend pinning Sui Wallet to your taskbar for quicker access.',
          }),
          E.jsx(Ku, {
            title: 'Create or Import a Wallet',
            children:
              'Be sure to back up your wallet using a secure method. Never share your secret phrase with anyone.',
          }),
          E.jsx(Ku, {
            title: 'Refresh Your Browser',
            children:
              'Once you set up your wallet, refresh this window browser to load up the extension.',
          }),
          E.jsx('div', {
            className: YH,
            children: E.jsx(ld, {
              variant: 'outline',
              asChild: !0,
              children: E.jsx('a', {
                href: 'https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil',
                target: '_blank',
                rel: 'noreferrer',
                children: 'Install Wallet Extension',
              }),
            }),
          }),
        ],
      }),
    ],
  })
}
var XH = 'WhatIsAWallet_container__1ktpkq90',
  ZH = 'WhatIsAWallet_content__1ktpkq91'
function EE() {
  return E.jsxs('div', {
    className: XH,
    children: [
      E.jsx(Xa, { as: 'h2', children: 'What is a Wallet' }),
      E.jsxs('div', {
        className: ZH,
        children: [
          E.jsx(Ku, {
            title: 'Easy Login',
            children:
              'No need to create new accounts and passwords for every website. Just connect your wallet and get going.',
          }),
          E.jsx(Ku, {
            title: 'Store your Digital Assets',
            children: 'Send, receive, store, and display your digital assets like NFTs & coins.',
          }),
        ],
      }),
    ],
  })
}
function Sb() {
  return $n((e) => e.wallets)
}
function JH(e) {
  return E.jsxs('svg', {
    width: 28,
    height: 28,
    fill: 'none',
    xmlns: 'http://www.w3.org/2000/svg',
    ...e,
    children: [
      E.jsx('rect', { width: 28, height: 28, rx: 6, fill: '#6FBCF0' }),
      E.jsx('path', {
        fillRule: 'evenodd',
        clipRule: 'evenodd',
        d: 'M7.942 20.527A6.875 6.875 0 0 0 13.957 24c2.51 0 4.759-1.298 6.015-3.473a6.875 6.875 0 0 0 0-6.945l-5.29-9.164a.837.837 0 0 0-1.45 0l-5.29 9.164a6.875 6.875 0 0 0 0 6.945Zm4.524-11.75 1.128-1.953a.418.418 0 0 1 .725 0l4.34 7.516a5.365 5.365 0 0 1 .449 4.442 4.675 4.675 0 0 0-.223-.73c-.599-1.512-1.954-2.68-4.029-3.47-1.426-.54-2.336-1.336-2.706-2.364-.476-1.326.021-2.77.316-3.44Zm-1.923 3.332L9.255 14.34a5.373 5.373 0 0 0 0 5.43 5.373 5.373 0 0 0 4.702 2.714 5.38 5.38 0 0 0 3.472-1.247c.125-.314.51-1.462.034-2.646-.44-1.093-1.5-1.965-3.15-2.594-1.864-.707-3.076-1.811-3.6-3.28a4.601 4.601 0 0 1-.17-.608Z',
        fill: '#fff',
      }),
    ],
  })
}
var eq = 'WalletList_container__1v2s6cz0',
  tq = 'WalletListItem_container__1dqqtqs0',
  nq = 'WalletListItem_selectedWalletItem__1dqqtqs2',
  rq = 'WalletListItem_walletIcon__1dqqtqs3',
  iq = 'WalletListItem_walletItem__1dqqtqs1'
function CE({ name: e, icon: t, onClick: n, isSelected: r = !1 }) {
  return E.jsx('li', {
    className: tq,
    children: E.jsxs('button', {
      className: Ms(iq, { [nq]: r }),
      type: 'button',
      onClick: n,
      children: [
        typeof t == 'string' ? E.jsx('img', { className: rq, src: t, alt: `${e} logo` }) : t,
        E.jsx(Xa, {
          size: 'md',
          truncate: !0,
          asChild: !0,
          children: E.jsx('div', { children: e }),
        }),
      ],
    }),
  })
}
function sq({ selectedWalletName: e, onPlaceholderClick: t, onSelect: n }) {
  const r = Sb()
  return E.jsx('ul', {
    className: eq,
    children:
      r.length > 0
        ? r.map((i) =>
            E.jsx(
              CE,
              { name: i.name, icon: i.icon, isSelected: Ra(i) === e, onClick: () => n(i) },
              Ra(i)
            )
          )
        : E.jsx(CE, { name: 'Sui Wallet', icon: E.jsx(JH, {}), onClick: t, isSelected: !0 }),
  })
}
function oq({ trigger: e, open: t, defaultOpen: n, onOpenChange: r }) {
  const [i, s] = w.useState(t ?? n),
    [o, a] = w.useState(),
    [l, c] = w.useState(),
    { mutate: u, isError: f } = xb(),
    d = () => {
      c(void 0), a(void 0)
    },
    p = (b) => {
      b || d(), s(b), r == null || r(b)
    },
    h = (b) => {
      a('connection-status'), u({ wallet: b }, { onSuccess: () => p(!1) })
    }
  let m
  switch (o) {
    case 'what-is-a-wallet':
      m = E.jsx(EE, {})
      break
    case 'getting-started':
      m = E.jsx(QH, {})
      break
    case 'connection-status':
      m = E.jsx(HH, { selectedWallet: l, hadConnectionError: f, onRetryConnection: h })
      break
    default:
      m = E.jsx(EE, {})
  }
  return E.jsxs(NL, {
    open: t ?? i,
    onOpenChange: p,
    children: [
      E.jsx(ML, { asChild: !0, children: e }),
      E.jsx(jL, {
        children: E.jsx(Tf, {
          children: E.jsx(LL, {
            className: RH,
            children: E.jsxs($L, {
              className: AH,
              'aria-describedby': void 0,
              children: [
                E.jsxs('div', {
                  className: Ms(NH, { [MH]: !!o }),
                  children: [
                    E.jsxs('div', {
                      className: jH,
                      children: [
                        E.jsx(FL, {
                          className: IH,
                          asChild: !0,
                          children: E.jsx(Xa, { as: 'h2', children: 'Connect a Wallet' }),
                        }),
                        E.jsx(sq, {
                          selectedWalletName: Ra(l),
                          onPlaceholderClick: () => a('getting-started'),
                          onSelect: (b) => {
                            Ra(l) !== Ra(b) && (c(b), h(b))
                          },
                        }),
                      ],
                    }),
                    E.jsx('button', {
                      className: LH,
                      onClick: () => a('what-is-a-wallet'),
                      type: 'button',
                      children: 'What is a Wallet?',
                    }),
                  ],
                }),
                E.jsxs('div', {
                  className: Ms(DH, { [PH]: !!o }),
                  children: [
                    E.jsx('div', {
                      className: kH,
                      children: E.jsx(Qv, {
                        type: 'button',
                        'aria-label': 'Back',
                        onClick: () => d(),
                        children: E.jsx(xH, {}),
                      }),
                    }),
                    m,
                  ],
                }),
                E.jsx(BL, {
                  className: TH,
                  asChild: !0,
                  children: E.jsx(Qv, {
                    type: 'button',
                    'aria-label': 'Close',
                    children: E.jsx(SH, {}),
                  }),
                }),
              ],
            }),
          }),
        }),
      }),
    ],
  })
}
function cg() {
  return $n((e) => e.currentAccount)
}
var qk = w.createContext(null),
  aq = { localnet: { url: sz('localnet') } },
  lq = function (t, n) {
    return oz(n) ? n : new pk(n)
  }
function cq(e) {
  const { onNetworkChange: t, network: n, children: r } = e,
    i = e.networks ?? aq,
    s = e.createClient ?? lq,
    [o, a] = w.useState(e.network ?? e.defaultNetwork ?? Object.keys(i)[0]),
    l = e.network ?? o,
    c = w.useMemo(() => s(l, i[l]), [s, l, i]),
    u = w.useMemo(
      () => ({
        client: c,
        networks: i,
        network: l,
        config: i[l] instanceof pk ? null : i[l],
        selectNetwork: (f) => {
          l !== f && (!n && f !== o && a(f), t == null || t(f))
        },
      }),
      [c, i, o, l, n, t]
    )
  return E.jsx(qk.Provider, { value: u, children: r })
}
function Kk() {
  const e = w.useContext(qk)
  if (!e)
    throw new Error(
      'Could not find SuiClientContext. Ensure that you have set up the SuiClientProvider'
    )
  return e
}
function uq() {
  return Kk().client
}
function fq(...e) {
  const [t, n, { queryKey: r = [], ...i } = {}] = e,
    s = Kk()
  return jO({ ...i, queryKey: [s.network, t, n, ...r], queryFn: async () => await s.client[t](n) })
}
function Gk(e, t) {
  return fq(
    'resolveNameServiceNames',
    { address: e, limit: 1 },
    {
      ...t,
      refetchOnWindowFocus: !1,
      retry: !1,
      select: (n) => (n.data.length > 0 ? n.data[0] : null),
      enabled: !!e && (t == null ? void 0 : t.enabled) !== !1,
    }
  )
}
function dq() {
  return $n((e) => e.accounts)
}
var Eb = class extends Error {},
  hq = class extends Error {},
  pq = class extends Error {},
  gq = class extends Error {}
function Kc() {
  const e = $n((r) => r.currentWallet),
    t = $n((r) => r.connectionStatus),
    n = $n((r) => r.supportedIntents)
  switch (t) {
    case 'connecting':
      return {
        connectionStatus: t,
        currentWallet: null,
        isDisconnected: !1,
        isConnecting: !0,
        isConnected: !1,
        supportedIntents: [],
      }
    case 'disconnected':
      return {
        connectionStatus: t,
        currentWallet: null,
        isDisconnected: !0,
        isConnecting: !1,
        isConnected: !1,
        supportedIntents: [],
      }
    case 'connected':
      return {
        connectionStatus: t,
        currentWallet: e,
        isDisconnected: !1,
        isConnecting: !1,
        isConnected: !0,
        supportedIntents: n,
      }
  }
}
function mq({ mutationKey: e, ...t } = {}) {
  const { currentWallet: n } = Kc(),
    r = $n((i) => i.setWalletDisconnected)
  return X0({
    mutationKey: ad.disconnectWallet(e),
    mutationFn: async () => {
      var i
      if (!n) throw new Eb('No wallet is connected.')
      try {
        await ((i = n.features['standard:disconnect']) == null ? void 0 : i.disconnect())
      } catch (s) {
        console.error('Failed to disconnect the application from the current wallet.', s)
      }
      r()
    },
    ...t,
  })
}
function yq({ mutationKey: e, ...t } = {}) {
  const { currentWallet: n } = Kc(),
    r = $n((i) => i.setAccountSwitched)
  return X0({
    mutationKey: ad.switchAccount(e),
    mutationFn: async ({ account: i }) => {
      if (!n) throw new Eb('No wallet is connected.')
      const s = n.accounts.find((o) => o.address === i.address)
      if (!s) throw new gq(`No account with address ${i.address} is connected to ${n.name}.`)
      r(s)
    },
    ...t,
  })
}
var vq = 'AccountDropdownMenu_connectedAccount__div2ql0',
  wq = 'AccountDropdownMenu_menuContainer__div2ql1',
  bq = 'AccountDropdownMenu_menuContent__div2ql2',
  Yk = 'AccountDropdownMenu_menuItem__div2ql3',
  xq = 'AccountDropdownMenu_separator__div2ql5',
  Sq = 'AccountDropdownMenu_switchAccountMenuItem__div2ql4'
function Eq(e) {
  return E.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    width: 16,
    height: 16,
    fill: 'none',
    ...e,
    children: E.jsx('path', {
      fill: 'currentColor',
      d: 'm11.726 5.048-4.73 5.156-1.722-1.879a.72.72 0 0 0-.529-.23.722.722 0 0 0-.525.24.858.858 0 0 0-.22.573.86.86 0 0 0 .211.576l2.255 2.458c.14.153.332.24.53.24.2 0 .391-.087.532-.24l5.261-5.735A.86.86 0 0 0 13 5.63a.858.858 0 0 0-.22-.572.722.722 0 0 0-.525-.24.72.72 0 0 0-.529.23Z',
    }),
  })
}
function Cq(e) {
  return E.jsx('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    width: 16,
    height: 16,
    fill: 'none',
    ...e,
    children: E.jsx('path', {
      stroke: '#A0B6C3',
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeWidth: 1.5,
      d: 'm4 6 4 4 4-4',
    }),
  })
}
function _q({ currentAccount: e }) {
  const { mutate: t } = mq(),
    { data: n } = Gk(e.label ? null : e.address),
    r = dq()
  return E.jsxs(WU, {
    modal: !1,
    children: [
      E.jsx(Tf, {
        children: E.jsx(VU, {
          asChild: !0,
          children: E.jsxs(ld, {
            size: 'lg',
            className: vq,
            children: [
              E.jsx(_c, { mono: !0, weight: 'bold', children: e.label ?? n ?? m6(e.address) }),
              E.jsx(Cq, {}),
            ],
          }),
        }),
      }),
      E.jsx(HU, {
        children: E.jsx(Tf, {
          className: wq,
          children: E.jsxs(qU, {
            className: bq,
            children: [
              r.map((i) => E.jsx(Oq, { account: i, active: e.address === i.address }, i.address)),
              E.jsx(KU, { className: xq }),
              E.jsx(ok, { className: Ms(Yk), onSelect: () => t(), children: 'Disconnect' }),
            ],
          }),
        }),
      }),
    ],
  })
}
function Oq({ account: e, active: t }) {
  const { mutate: n } = yq(),
    { data: r } = Gk(e.label ? null : e.address)
  return E.jsxs(ok, {
    className: Ms(Yk, Sq),
    onSelect: () => n({ account: e }),
    children: [
      E.jsx(_c, { mono: !0, children: e.label ?? r ?? m6(e.address) }),
      t ? E.jsx(Eq, {}) : null,
    ],
  })
}
function kq({ connectText: e = 'Connect Wallet', ...t }) {
  const n = cg()
  return n
    ? E.jsx(_q, { currentAccount: n })
    : E.jsx(oq, { trigger: E.jsx(Tf, { children: E.jsx(ld, { ...t, children: e }) }) })
}
function Qk() {
  const e = new Map()
  return {
    getItem(t) {
      return e.get(t)
    },
    setItem(t, n) {
      e.set(t, n)
    },
    removeItem(t) {
      e.delete(t)
    },
  }
}
var Tq = 'Sui Wallet',
  Aq = typeof window < 'u' && window.localStorage ? localStorage : Qk(),
  Rq = 'sui-dapp-kit:wallet-connection-info',
  Pq = ['sui:signTransaction', 'sui:signTransactionBlock'],
  Xk = (e) => Pq.some((t) => e.features[t]),
  Zk = [Tq, Ik]
function Jk() {
  const { mutateAsync: e } = xb(),
    t = $n((u) => u.autoConnectEnabled),
    n = $n((u) => u.lastConnectedWalletName),
    r = $n((u) => u.lastConnectedAccountAddress),
    i = Sb(),
    { isConnected: s } = Kc(),
    [o, a] = w.useState(!1)
  w.useLayoutEffect(() => {
    a(!0)
  }, [])
  const { data: l, isError: c } = jO({
    queryKey: [
      '@mysten/dapp-kit',
      'autoconnect',
      {
        isConnected: s,
        autoConnectEnabled: t,
        lastConnectedWalletName: n,
        lastConnectedAccountAddress: r,
        walletCount: i.length,
      },
    ],
    queryFn: async () => {
      if (!t) return 'disabled'
      if (!n || !r || s) return 'attempted'
      const u = i.find((f) => Ra(f) === n)
      return u && (await e({ wallet: u, accountAddress: r, silent: !0 })), 'attempted'
    },
    enabled: t,
    persister: void 0,
    gcTime: 0,
    staleTime: 0,
    networkMode: 'always',
    retry: !1,
    retryOnMount: !1,
    refetchInterval: !1,
    refetchIntervalInBackground: !1,
    refetchOnMount: !1,
    refetchOnReconnect: !1,
    refetchOnWindowFocus: !1,
  })
  return t ? (o ? (s || !n || c ? 'attempted' : l ?? 'idle') : 'idle') : 'disabled'
}
function Iq(e) {
  const t = Jk(),
    [n, r] = w.useState(null),
    [i, s] = w.useState(null),
    { mutate: o } = xb()
  w.useEffect(() => {
    !n || !i || t !== 'attempted' || (o({ wallet: i, silent: !0 }), r(null))
  }, [n, t, o, i]),
    w.useLayoutEffect(() => {
      if (!(e != null && e.name)) return
      const { wallet: a, unregister: l, addressFromRedirect: c } = jW(e.name, { origin: e.origin })
      return c && (s(a), r(c)), l
    }, [e == null ? void 0 : e.name, e == null ? void 0 : e.origin])
}
var _E = 'Unsafe Burner Wallet'
function Dq(e) {
  const t = uq()
  w.useEffect(() => (e ? Nq(t) : void 0), [e, t])
}
function Nq(e) {
  var t, n, r, i, s, o, a
  const l = J0()
  if (l.get().find((p) => p.name === _E)) {
    console.warn(
      'registerUnsafeBurnerWallet: Unsafe Burner Wallet already registered, skipping duplicate registration.'
    )
    return
  }
  console.warn(
    'Your application is currently using the unsafe burner wallet. Make sure that this wallet is disabled in production.'
  )
  const u = new Rl(),
    f = new eg({
      address: u.getPublicKey().toSuiAddress(),
      publicKey: u.getPublicKey().toSuiBytes(),
      chains: ['sui:unknown'],
      features: [
        'sui:signAndExecuteTransactionBlock',
        'sui:signTransactionBlock',
        'sui:signTransaction',
        'sui:signAndExecuteTransaction',
      ],
    })
  class d {
    constructor() {
      ea(this, t, () => () => {}),
        ea(this, n, async () => ({ accounts: this.accounts })),
        ea(this, r, async (h) => {
          const { bytes: m, signature: b } = await u.signPersonalMessage(h.message)
          return { bytes: m, signature: b }
        }),
        ea(this, i, async (h) => {
          const { bytes: m, signature: b } = await h.transactionBlock.sign({ client: e, signer: u })
          return { transactionBlockBytes: m, signature: b }
        }),
        ea(this, s, async (h) => {
          var y
          const { bytes: m, signature: b } = await Ov.from(await h.transaction.toJSON()).sign({
            client: e,
            signer: u,
          })
          return (y = h.signal) == null || y.throwIfAborted(), { bytes: m, signature: b }
        }),
        ea(this, o, async (h) => {
          const { bytes: m, signature: b } = await h.transactionBlock.sign({ client: e, signer: u })
          return e.executeTransactionBlock({
            signature: b,
            transactionBlock: m,
            options: h.options,
          })
        }),
        ea(this, a, async (h) => {
          var S
          const { bytes: m, signature: b } = await Ov.from(await h.transaction.toJSON()).sign({
            client: e,
            signer: u,
          })
          ;(S = h.signal) == null || S.throwIfAborted()
          const { rawEffects: y, digest: v } = await e.executeTransactionBlock({
            signature: b,
            transactionBlock: m,
            options: { showRawEffects: !0 },
          })
          return { bytes: m, signature: b, digest: v, effects: Pt(new Uint8Array(y)) }
        })
    }
    get version() {
      return '1.0.0'
    }
    get name() {
      return _E
    }
    get icon() {
      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAJrElEQVR42tWbe2xT1x3H7UxAyD3XrdrSbGXlUbKWsq5rWdVuVOMRSEqSOmnVRZMmJqZNYv1nf3R/jWmVmVrtRRM/YwPd1nVTNcrE3pQCoikrIRAC4VVNY0hlD9ZOo1uCfe3ra9979v0dcy3s5Pper76Oh/STE+495/4+5/c85zqe2f7HAx5vKsS+monJj/CdHi/f4/HWW4f6AwdblmXjTM0NyS+movKtw9v+j6C5gKhyTMTTpA2x15Qwy+Pz75motOGdgKep8WF5ATgVZIt5NeO2wMqD0hfVGNPh3oYaYflsjG0l63PeyLCDnqbsLpZIhaRNFI+Ox+Le5KB0RybK8gDmJOkI07U4i/FhT1NDQl8Me5rUIfaDfELOJ0NsFa/SJQHm1WLsHcDqRWiy9BCL8s0N5t6UWWFVvxplejYm60hC91cNjPtzCTZsAptCVoeLP8PDDQJNCSodap6H+LtE8ZcdkvVkkD38vwDn4/Jvy4EhBhZSvRaUHiTXn31gJJxkUPoClBKKFizM+inhVA2cYIdM4HJouPvoe9s9H+KzDhyGK6KkmIqitBhww2C11rjQL2L4kgUwFxk8yPyzauUA3Pk/353XnA6zKbKCaQ2UlMvJF6W5uF5F8yHfZWZpC9HRmBziaEpm1bpY9XvhxuWJRldC7Mt03WlZwpjnkZUNa2DMG2EaPj9MGd2l2mofd0hQ7ZSopsXckHxVCUp32fXGdD0ZktrgFUmMqwhcWFjp87RArsD+9bn585IRaSHAKgBL3SZwOTRc8BKg7yYoskp5OJDiiPmF2Sj7ox0siYJ7lJA04EqvzZ9B1xSVt6PlW0IxZgUMJdZYAJuWngLQt9IRuZXmoTEkmci8ZtTXTViUKyasA9FRun5d8z6bfw0gYWm9mmCXxZatQgxfC7I2NVpRYQOxKWppLs4mcgn5NcibgL1K40xYp8CYY5TXEpjcb3LAJ0OZyyg3+2nySm6fjEtzkEz+7VBx3RTb+60z9dma7pkvwO2QQL5HzTtAdpKF7euw/HuzfrosBHy+ZsBimzbQshjWTVMDgez53B5MbjcGbr1ZjdUJOM5O0SLXzJ2R+uOA1dMAVoLsm5zb73JSId8t8Aa1LsAJdoTCrCaw6e3NC2DdFMUXWRg173mysJNOSUNskUJ1cOlXa2LhcbgmSszXYSn9hl3KSxTDjrZ2cbbfbWDyumsh9m3e7zCG7a3ETt+gtI7fx6lEOanZKDVvuA2cjYmt5xNOd2Louz3IQ12UZ2Zo3lkb9cDlvSs6m4Vk5Yqlabs0B97wT7PUuCXQz0Bnt9QxMPTW4iwBtmUlY8hFsHJPlzcQ1xuG75CVK1kXofCUGnU9fg1aVD7kfE9MoabtYkcAvIUYS2op3Hc3TTrDQzIAeojugTVLFolWDR6wFPtY0R66n6HltwjCIawnE2ymresk9NtN+pfUUi0mX6RJLfrh9zMRaRPOqubSA8W2MNzC0mHpK7j2ruuw5mYkxl5+2+HGQeg4yNYg7vNg+xMxFsuRMuiTsRJZG3cysAl4D9n4aC4un8L9qUyVvbCyYwFXX1nGUxFf1cCiEQqy75O+TpMwYKNKSPQUqhLyyWLsRbESLctx0YnixgfphRWA8pOPc+N4F9d+eV9V4OlCX/As5w5g+wtGhJGukp5go2R3D7EW9rSDcnGL56YgJHj+8GcFND/Vy41jj/H0jxc6HU/AA2QlR01UlH3D7CmITQnJq4lVWBi1yl8XYEh278c5H++F+Iui7r7bYR8tH/gbqoJN7fVODUhLYVVxzmYCEyOxFg7RUVa0egCHZZ55eRHnp/tKgMna6s/bbMdTxZgMzl9CCcmq7k690OzDfaeSN4QcsREjsQpgXHwyWyfg9K5WE7hc6JqTWjyihObfygOFOkv6i5K5TZx8LsL1sVS4NL8ItiB7sgAcEKcWHfUCVhK3kUVnBNbfXIs4l5xAv5sJs234eTUy93L0Au2otQOw5ORMyfQ6WwexFupVSHowG6uThXfebmlhWojMS3fazmMeGxEI6S2SUti6RAo2vKohVuH3qUG5FWm/PjH8kzutgSH5g58xrVwzIbZkxHf7OFjFC+wrMDXcpOqOKX/g01U/XPvVJyxdWsiJblqYmnZoWbDxAcR56X5WPuh4ewcL5PY9JBRUYjc7fzjG6Uc3mHBWbg23X1BLaFHOSnrw4bWiNAXSEWcWRntIignXTP/oDsfKZX66mMbZAPfhviU1AyYmJLYAMZa/QXjUSeIiixpj3UUFtd884KytjN7EjdGNNMbWwtlf3FvbQ4OQtIoYSzbxqVDLXMTxP8jnnbiyKcaJLvueGLD6kXW2sKZov1tpn7hwXf3ZUvq0K2FXOM7Op/Xgb6PhxsWIErYGVuK3WGXWkkwMMZVCVl5kWtax5A6usgemvnx4DelUcYcFC0eIbcbXKzggeyBjeXIhkftaKknJKLtnuSg7KmKQsrH+1nqbmLWY6w/tBGy/8xrruR5SM99LLIjfT/4ZbNZnQEPssIVb21rKTGRIPDagNoLdFMKgcuLc/TF6Bulk6c7ovg4TU+XvS6FNw1tDfVqH9MOPmBDui0hcK6wz744FlDjNe0m3aVldJYagtI6YbF+3ZGPsQHlN1vbeh8lJofqJ+uo9Zi4wXZxKFiXKGxbHT7pNq71oNg4Qi6MviE0FpRVqjGXILYoJ4tCjdYU1rWeMdPLc/ochj3B9pGNGL4NupGPRlUl35KMVxFLNO6ZnxYlBsUPqoMkbUqAb6VhMVKQ7MVT1dYdrL8hzEAcjpmvjHKphgaFb0ZVJZw7dwVD9q5fkgPTRbBxnzmGfgRLQsMCkG+moQdcp6GzzZsL2MGyllvBNGWM9RqMCk26kI7aBK526csVShZTfzid6FEzeiNAGP92jpCPQEbrW7EW5MbZxAz/fN9lg0IbQaaxrQ83/VoKPb/HqJx67Hw+43CDQBPsX0gm6ufXNvH4vP9rZapzx7+Nn+oxZAjfo2caZ3n350c5W6FSEdQ86sNarj3c/jRV+H42AXsdGRBfPPIlnb/mUtxzWXfALn/PmRze2Gud6E/xsXwYtnlsWN8Tc5/oyxjn/jvyJrlY82xLUfWuPr/TqxzuXQZkIP9M7CXiyuP4B4WmsTnNhzinjrD+WO9bRhmdZWLXe4EKRtV5tpN3Hx3s2G+d79/MJf4qff0LnE72kfFEs4ITQvWLMab8C131dP9n9Je1Yx000Nz2jAf+UJwCBchc3NvGR1Qx71XXY2Ww1Jvx7YalzAPkX9rp5E5Z+pv+ja8bE43uN491b9dHO9Xx4lUxziLn21Nai/wXWM6t9vkvtrwAAAABJRU5ErkJggg=='
    }
    get chains() {
      return SF
    }
    get accounts() {
      return [f]
    }
    get features() {
      return {
        'standard:connect': { version: '1.0.0', connect: Jo(this, n) },
        'standard:events': { version: '1.0.0', on: Jo(this, t) },
        'sui:signPersonalMessage': { version: '1.0.0', signPersonalMessage: Jo(this, r) },
        'sui:signTransactionBlock': { version: '1.0.0', signTransactionBlock: Jo(this, i) },
        'sui:signAndExecuteTransactionBlock': {
          version: '1.0.0',
          signAndExecuteTransactionBlock: Jo(this, o),
        },
        'sui:signTransaction': { version: '2.0.0', signTransaction: Jo(this, s) },
        'sui:signAndExecuteTransaction': {
          version: '2.0.0',
          signAndExecuteTransaction: Jo(this, a),
        },
      }
    }
  }
  return (
    (t = new WeakMap()),
    (n = new WeakMap()),
    (r = new WeakMap()),
    (i = new WeakMap()),
    (s = new WeakMap()),
    (o = new WeakMap()),
    (a = new WeakMap()),
    l.register(new d())
  )
}
function Mq() {
  const { currentWallet: e } = Kc(),
    t = $n((n) => n.updateWalletAccounts)
  w.useEffect(
    () =>
      e == null
        ? void 0
        : e.features['standard:events'].on('change', ({ accounts: r }) => {
            r && t(r)
          }),
    [e == null ? void 0 : e.features, t]
  )
}
function jq(e, t) {
  const n = $n((i) => i.setWalletRegistered),
    r = $n((i) => i.setWalletUnregistered)
  w.useEffect(() => {
    const i = J0()
    n(Jh(e, t))
    const s = i.on('register', () => {
        n(Jh(e, t))
      }),
      o = i.on('unregister', (a) => {
        r(Jh(e, t), a)
      })
    return () => {
      s(), o()
    }
  }, [e, t, n, r])
}
var Lq = {
  blurs: { modalOverlay: 'blur(0)' },
  backgroundColors: {
    primaryButton: '#F6F7F9',
    primaryButtonHover: '#F0F2F5',
    outlineButtonHover: '#F4F4F5',
    modalOverlay: 'rgba(24 36 53 / 20%)',
    modalPrimary: 'white',
    modalSecondary: '#F7F8F8',
    iconButton: 'transparent',
    iconButtonHover: '#F0F1F2',
    dropdownMenu: '#FFFFFF',
    dropdownMenuSeparator: '#F3F6F8',
    walletItemSelected: 'white',
    walletItemHover: '#3C424226',
  },
  borderColors: { outlineButton: '#E4E4E7' },
  colors: {
    primaryButton: '#373737',
    outlineButton: '#373737',
    iconButton: '#000000',
    body: '#182435',
    bodyMuted: '#767A81',
    bodyDanger: '#FF794B',
  },
  radii: { small: '6px', medium: '8px', large: '12px', xlarge: '16px' },
  shadows: {
    primaryButton: '0px 4px 12px rgba(0, 0, 0, 0.1)',
    walletItemSelected: '0px 2px 6px rgba(0, 0, 0, 0.05)',
  },
  fontWeights: { normal: '400', medium: '500', bold: '600' },
  fontSizes: { small: '14px', medium: '16px', large: '18px', xlarge: '20px' },
  typography: {
    fontFamily:
      'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
    fontStyle: 'normal',
    lineHeight: '1.3',
    letterSpacing: '1',
  },
}
function $q({ wallets: e, storage: t, storageKey: n, autoConnectEnabled: r }) {
  return b7()(
    BW(
      (i, s) => ({
        autoConnectEnabled: r,
        wallets: e,
        accounts: [],
        currentWallet: null,
        currentAccount: null,
        lastConnectedAccountAddress: null,
        lastConnectedWalletName: null,
        connectionStatus: 'disconnected',
        supportedIntents: [],
        setConnectionStatus(o) {
          i(() => ({ connectionStatus: o }))
        },
        setWalletConnected(o, a, l, c = []) {
          i(() => ({
            accounts: a,
            currentWallet: o,
            currentAccount: l,
            lastConnectedWalletName: Ra(o),
            lastConnectedAccountAddress: l == null ? void 0 : l.address,
            connectionStatus: 'connected',
            supportedIntents: c,
          }))
        },
        setWalletDisconnected() {
          i(() => ({
            accounts: [],
            currentWallet: null,
            currentAccount: null,
            lastConnectedWalletName: null,
            lastConnectedAccountAddress: null,
            connectionStatus: 'disconnected',
            supportedIntents: [],
          }))
        },
        setAccountSwitched(o) {
          i(() => ({ currentAccount: o, lastConnectedAccountAddress: o.address }))
        },
        setWalletRegistered(o) {
          i(() => ({ wallets: o }))
        },
        setWalletUnregistered(o, a) {
          a === s().currentWallet
            ? i(() => ({
                wallets: o,
                accounts: [],
                currentWallet: null,
                currentAccount: null,
                lastConnectedWalletName: null,
                lastConnectedAccountAddress: null,
                connectionStatus: 'disconnected',
                supportedIntents: [],
              }))
            : i(() => ({ wallets: o }))
        },
        updateWalletAccounts(o) {
          const a = s().currentAccount
          i(() => ({
            accounts: o,
            currentAccount: (a && o.find(({ address: l }) => l === a.address)) || o[0],
          }))
        },
      }),
      {
        name: n,
        storage: Dk(() => t),
        partialize: ({ lastConnectedWalletName: i, lastConnectedAccountAddress: s }) => ({
          lastConnectedWalletName: i,
          lastConnectedAccountAddress: s,
        }),
      }
    )
  )
}
var Fq = {
    blurs: { modalOverlay: '' },
    backgroundColors: {
      primaryButton: '',
      primaryButtonHover: '',
      outlineButtonHover: '',
      walletItemHover: '',
      walletItemSelected: '',
      modalOverlay: '',
      modalPrimary: '',
      modalSecondary: '',
      iconButton: '',
      iconButtonHover: '',
      dropdownMenu: '',
      dropdownMenuSeparator: '',
    },
    borderColors: { outlineButton: '' },
    colors: {
      primaryButton: '',
      outlineButton: '',
      body: '',
      bodyMuted: '',
      bodyDanger: '',
      iconButton: '',
    },
    radii: { small: '', medium: '', large: '', xlarge: '' },
    shadows: { primaryButton: '', walletItemSelected: '' },
    fontWeights: { normal: '', medium: '', bold: '' },
    fontSizes: { small: '', medium: '', large: '', xlarge: '' },
    typography: { fontFamily: '', fontStyle: '', lineHeight: '', letterSpacing: '' },
  },
  Bq = lH(Fq, (e, t) => `dapp-kit-${t.join('-')}`)
function Uq({ theme: e }) {
  const t = Array.isArray(e) ? zq(e) : eT(e)
  return E.jsx('style', {
    precedence: 'default',
    href: 'mysten-dapp-kit-theme',
    dangerouslySetInnerHTML: { __html: t },
  })
}
function zq(e) {
  return e
    .map(({ mediaQuery: t, selector: n, variables: r }) => {
      const i = eT(r),
        s = n ? `${n} ${i}` : i
      return t ? `@media ${t}{${s}}` : s
    })
    .join(' ')
}
function eT(e) {
  return `${EH} {${Wq(e)}}`
}
function Wq(e) {
  return Object.entries(zW(Bq, e))
    .map(([t, n]) => `${t}:${n};`)
    .join('')
}
function Vq({
  preferredWallets: e = Zk,
  walletFilter: t = Xk,
  storage: n = Aq,
  storageKey: r = Rq,
  enableUnsafeBurner: i = !1,
  autoConnect: s = !1,
  stashedWallet: o,
  theme: a = Lq,
  children: l,
}) {
  const c = w.useRef(
    $q({ autoConnectEnabled: s, wallets: Jh(e, t), storage: n || Qk(), storageKey: r })
  )
  return E.jsx(Vk.Provider, {
    value: c.current,
    children: E.jsxs(Hq, {
      preferredWallets: e,
      walletFilter: t,
      enableUnsafeBurner: i,
      stashedWallet: o,
      children: [a ? E.jsx(Uq, { theme: a }) : null, l],
    }),
  })
}
function Hq({
  preferredWallets: e = Zk,
  walletFilter: t = Xk,
  enableUnsafeBurner: n = !1,
  stashedWallet: r,
  children: i,
}) {
  return jq(e, t), Mq(), Iq(r), Dq(n), Jk(), i
}
function qq({ mutationKey: e, ...t } = {}) {
  const { currentWallet: n } = Kc(),
    r = cg()
  return X0({
    mutationKey: ad.signPersonalMessage(e),
    mutationFn: async (i) => {
      if (!n) throw new Eb('No wallet is connected.')
      const s = i.account ?? r
      if (!s) throw new hq('No wallet account is selected to sign the personal message with.')
      const o = n.features['sui:signPersonalMessage']
      if (o) return await o.signPersonalMessage({ ...i, account: s })
      const a = n.features['sui:signMessage']
      if (a) {
        console.warn(
          "This wallet doesn't support the `signPersonalMessage` feature... falling back to `signMessage`."
        )
        const { messageBytes: l, signature: c } = await a.signMessage({ ...i, account: s })
        return { bytes: l, signature: c }
      }
      throw new pq("This wallet doesn't support the `signPersonalMessage` feature.")
    },
    ...t,
  })
}
function Cn(e) {
  return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
}
var Kq = (() => (typeof Symbol == 'function' && Symbol.observable) || '@@observable')(),
  OE = Kq,
  jm = () => Math.random().toString(36).substring(7).split('').join('.'),
  Gq = {
    INIT: `@@redux/INIT${jm()}`,
    REPLACE: `@@redux/REPLACE${jm()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${jm()}`,
  },
  l0 = Gq
function Cb(e) {
  if (typeof e != 'object' || e === null) return !1
  let t = e
  for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t)
  return Object.getPrototypeOf(e) === t || Object.getPrototypeOf(e) === null
}
function tT(e, t, n) {
  if (typeof e != 'function') throw new Error(Cn(2))
  if (
    (typeof t == 'function' && typeof n == 'function') ||
    (typeof n == 'function' && typeof arguments[3] == 'function')
  )
    throw new Error(Cn(0))
  if ((typeof t == 'function' && typeof n > 'u' && ((n = t), (t = void 0)), typeof n < 'u')) {
    if (typeof n != 'function') throw new Error(Cn(1))
    return n(tT)(e, t)
  }
  let r = e,
    i = t,
    s = new Map(),
    o = s,
    a = 0,
    l = !1
  function c() {
    o === s &&
      ((o = new Map()),
      s.forEach((b, y) => {
        o.set(y, b)
      }))
  }
  function u() {
    if (l) throw new Error(Cn(3))
    return i
  }
  function f(b) {
    if (typeof b != 'function') throw new Error(Cn(4))
    if (l) throw new Error(Cn(5))
    let y = !0
    c()
    const v = a++
    return (
      o.set(v, b),
      function () {
        if (y) {
          if (l) throw new Error(Cn(6))
          ;(y = !1), c(), o.delete(v), (s = null)
        }
      }
    )
  }
  function d(b) {
    if (!Cb(b)) throw new Error(Cn(7))
    if (typeof b.type > 'u') throw new Error(Cn(8))
    if (typeof b.type != 'string') throw new Error(Cn(17))
    if (l) throw new Error(Cn(9))
    try {
      ;(l = !0), (i = r(i, b))
    } finally {
      l = !1
    }
    return (
      (s = o).forEach((v) => {
        v()
      }),
      b
    )
  }
  function p(b) {
    if (typeof b != 'function') throw new Error(Cn(10))
    ;(r = b), d({ type: l0.REPLACE })
  }
  function h() {
    const b = f
    return {
      subscribe(y) {
        if (typeof y != 'object' || y === null) throw new Error(Cn(11))
        function v() {
          const T = y
          T.next && T.next(u())
        }
        return v(), { unsubscribe: b(v) }
      },
      [OE]() {
        return this
      },
    }
  }
  return (
    d({ type: l0.INIT }), { dispatch: d, subscribe: f, getState: u, replaceReducer: p, [OE]: h }
  )
}
function Yq(e) {
  Object.keys(e).forEach((t) => {
    const n = e[t]
    if (typeof n(void 0, { type: l0.INIT }) > 'u') throw new Error(Cn(12))
    if (typeof n(void 0, { type: l0.PROBE_UNKNOWN_ACTION() }) > 'u') throw new Error(Cn(13))
  })
}
function Qq(e) {
  const t = Object.keys(e),
    n = {}
  for (let s = 0; s < t.length; s++) {
    const o = t[s]
    typeof e[o] == 'function' && (n[o] = e[o])
  }
  const r = Object.keys(n)
  let i
  try {
    Yq(n)
  } catch (s) {
    i = s
  }
  return function (o = {}, a) {
    if (i) throw i
    let l = !1
    const c = {}
    for (let u = 0; u < r.length; u++) {
      const f = r[u],
        d = n[f],
        p = o[f],
        h = d(p, a)
      if (typeof h > 'u') throw (a && a.type, new Error(Cn(14)))
      ;(c[f] = h), (l = l || h !== p)
    }
    return (l = l || r.length !== Object.keys(o).length), l ? c : o
  }
}
function c0(...e) {
  return e.length === 0
    ? (t) => t
    : e.length === 1
    ? e[0]
    : e.reduce(
        (t, n) =>
          (...r) =>
            t(n(...r))
      )
}
function Xq(...e) {
  return (t) => (n, r) => {
    const i = t(n, r)
    let s = () => {
      throw new Error(Cn(15))
    }
    const o = { getState: i.getState, dispatch: (l, ...c) => s(l, ...c) },
      a = e.map((l) => l(o))
    return (s = c0(...a)(i.dispatch)), { ...i, dispatch: s }
  }
}
function Zq(e) {
  return Cb(e) && 'type' in e && typeof e.type == 'string'
}
var nT = Symbol.for('immer-nothing'),
  kE = Symbol.for('immer-draftable'),
  Tr = Symbol.for('immer-state')
function Ci(e, ...t) {
  throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)
}
var Oc = Object.getPrototypeOf
function zo(e) {
  return !!e && !!e[Tr]
}
function $s(e) {
  var t
  return e
    ? rT(e) ||
        Array.isArray(e) ||
        !!e[kE] ||
        !!((t = e.constructor) != null && t[kE]) ||
        fg(e) ||
        dg(e)
    : !1
}
var Jq = Object.prototype.constructor.toString()
function rT(e) {
  if (!e || typeof e != 'object') return !1
  const t = Oc(e)
  if (t === null) return !0
  const n = Object.hasOwnProperty.call(t, 'constructor') && t.constructor
  return n === Object ? !0 : typeof n == 'function' && Function.toString.call(n) === Jq
}
function u0(e, t) {
  ug(e) === 0
    ? Reflect.ownKeys(e).forEach((n) => {
        t(n, e[n], e)
      })
    : e.forEach((n, r) => t(r, n, e))
}
function ug(e) {
  const t = e[Tr]
  return t ? t.type_ : Array.isArray(e) ? 1 : fg(e) ? 2 : dg(e) ? 3 : 0
}
function Xv(e, t) {
  return ug(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
}
function iT(e, t, n) {
  const r = ug(e)
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : (e[t] = n)
}
function eK(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t
}
function fg(e) {
  return e instanceof Map
}
function dg(e) {
  return e instanceof Set
}
function ca(e) {
  return e.copy_ || e.base_
}
function Zv(e, t) {
  if (fg(e)) return new Map(e)
  if (dg(e)) return new Set(e)
  if (Array.isArray(e)) return Array.prototype.slice.call(e)
  const n = rT(e)
  if (t === !0 || (t === 'class_only' && !n)) {
    const r = Object.getOwnPropertyDescriptors(e)
    delete r[Tr]
    let i = Reflect.ownKeys(r)
    for (let s = 0; s < i.length; s++) {
      const o = i[s],
        a = r[o]
      a.writable === !1 && ((a.writable = !0), (a.configurable = !0)),
        (a.get || a.set) &&
          (r[o] = { configurable: !0, writable: !0, enumerable: a.enumerable, value: e[o] })
    }
    return Object.create(Oc(e), r)
  } else {
    const r = Oc(e)
    if (r !== null && n) return { ...e }
    const i = Object.create(r)
    return Object.assign(i, e)
  }
}
function _b(e, t = !1) {
  return (
    hg(e) ||
      zo(e) ||
      !$s(e) ||
      (ug(e) > 1 && (e.set = e.add = e.clear = e.delete = tK),
      Object.freeze(e),
      t && Object.entries(e).forEach(([n, r]) => _b(r, !0))),
    e
  )
}
function tK() {
  Ci(2)
}
function hg(e) {
  return Object.isFrozen(e)
}
var nK = {}
function Va(e) {
  const t = nK[e]
  return t || Ci(0, e), t
}
var Af
function sT() {
  return Af
}
function rK(e, t) {
  return { drafts_: [], parent_: e, immer_: t, canAutoFreeze_: !0, unfinalizedDrafts_: 0 }
}
function TE(e, t) {
  t && (Va('Patches'), (e.patches_ = []), (e.inversePatches_ = []), (e.patchListener_ = t))
}
function Jv(e) {
  e1(e), e.drafts_.forEach(iK), (e.drafts_ = null)
}
function e1(e) {
  e === Af && (Af = e.parent_)
}
function AE(e) {
  return (Af = rK(Af, e))
}
function iK(e) {
  const t = e[Tr]
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : (t.revoked_ = !0)
}
function RE(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length
  const n = t.drafts_[0]
  return (
    e !== void 0 && e !== n
      ? (n[Tr].modified_ && (Jv(t), Ci(4)),
        $s(e) && ((e = f0(t, e)), t.parent_ || d0(t, e)),
        t.patches_ &&
          Va('Patches').generateReplacementPatches_(n[Tr].base_, e, t.patches_, t.inversePatches_))
      : (e = f0(t, n, [])),
    Jv(t),
    t.patches_ && t.patchListener_(t.patches_, t.inversePatches_),
    e !== nT ? e : void 0
  )
}
function f0(e, t, n) {
  if (hg(t)) return t
  const r = t[Tr]
  if (!r) return u0(t, (i, s) => PE(e, r, t, i, s, n)), t
  if (r.scope_ !== e) return t
  if (!r.modified_) return d0(e, r.base_, !0), r.base_
  if (!r.finalized_) {
    ;(r.finalized_ = !0), r.scope_.unfinalizedDrafts_--
    const i = r.copy_
    let s = i,
      o = !1
    r.type_ === 3 && ((s = new Set(i)), i.clear(), (o = !0)),
      u0(s, (a, l) => PE(e, r, i, a, l, n, o)),
      d0(e, i, !1),
      n && e.patches_ && Va('Patches').generatePatches_(r, n, e.patches_, e.inversePatches_)
  }
  return r.copy_
}
function PE(e, t, n, r, i, s, o) {
  if (zo(i)) {
    const a = s && t && t.type_ !== 3 && !Xv(t.assigned_, r) ? s.concat(r) : void 0,
      l = f0(e, i, a)
    if ((iT(n, r, l), zo(l))) e.canAutoFreeze_ = !1
    else return
  } else o && n.add(i)
  if ($s(i) && !hg(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1) return
    f0(e, i),
      (!t || !t.scope_.parent_) &&
        typeof r != 'symbol' &&
        Object.prototype.propertyIsEnumerable.call(n, r) &&
        d0(e, i)
  }
}
function d0(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && _b(t, n)
}
function sK(e, t) {
  const n = Array.isArray(e),
    r = {
      type_: n ? 1 : 0,
      scope_: t ? t.scope_ : sT(),
      modified_: !1,
      finalized_: !1,
      assigned_: {},
      parent_: t,
      base_: e,
      draft_: null,
      copy_: null,
      revoke_: null,
      isManual_: !1,
    }
  let i = r,
    s = Ob
  n && ((i = [r]), (s = Rf))
  const { revoke: o, proxy: a } = Proxy.revocable(i, s)
  return (r.draft_ = a), (r.revoke_ = o), a
}
var Ob = {
    get(e, t) {
      if (t === Tr) return e
      const n = ca(e)
      if (!Xv(n, t)) return oK(e, n, t)
      const r = n[t]
      return e.finalized_ || !$s(r)
        ? r
        : r === Lm(e.base_, t)
        ? ($m(e), (e.copy_[t] = n1(r, e)))
        : r
    },
    has(e, t) {
      return t in ca(e)
    },
    ownKeys(e) {
      return Reflect.ownKeys(ca(e))
    },
    set(e, t, n) {
      const r = oT(ca(e), t)
      if (r != null && r.set) return r.set.call(e.draft_, n), !0
      if (!e.modified_) {
        const i = Lm(ca(e), t),
          s = i == null ? void 0 : i[Tr]
        if (s && s.base_ === n) return (e.copy_[t] = n), (e.assigned_[t] = !1), !0
        if (eK(n, i) && (n !== void 0 || Xv(e.base_, t))) return !0
        $m(e), t1(e)
      }
      return (
        (e.copy_[t] === n && (n !== void 0 || t in e.copy_)) ||
          (Number.isNaN(n) && Number.isNaN(e.copy_[t])) ||
          ((e.copy_[t] = n), (e.assigned_[t] = !0)),
        !0
      )
    },
    deleteProperty(e, t) {
      return (
        Lm(e.base_, t) !== void 0 || t in e.base_
          ? ((e.assigned_[t] = !1), $m(e), t1(e))
          : delete e.assigned_[t],
        e.copy_ && delete e.copy_[t],
        !0
      )
    },
    getOwnPropertyDescriptor(e, t) {
      const n = ca(e),
        r = Reflect.getOwnPropertyDescriptor(n, t)
      return (
        r && {
          writable: !0,
          configurable: e.type_ !== 1 || t !== 'length',
          enumerable: r.enumerable,
          value: n[t],
        }
      )
    },
    defineProperty() {
      Ci(11)
    },
    getPrototypeOf(e) {
      return Oc(e.base_)
    },
    setPrototypeOf() {
      Ci(12)
    },
  },
  Rf = {}
u0(Ob, (e, t) => {
  Rf[e] = function () {
    return (arguments[0] = arguments[0][0]), t.apply(this, arguments)
  }
})
Rf.deleteProperty = function (e, t) {
  return Rf.set.call(this, e, t, void 0)
}
Rf.set = function (e, t, n) {
  return Ob.set.call(this, e[0], t, n, e[0])
}
function Lm(e, t) {
  const n = e[Tr]
  return (n ? ca(n) : e)[t]
}
function oK(e, t, n) {
  var i
  const r = oT(t, n)
  return r ? ('value' in r ? r.value : (i = r.get) == null ? void 0 : i.call(e.draft_)) : void 0
}
function oT(e, t) {
  if (!(t in e)) return
  let n = Oc(e)
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t)
    if (r) return r
    n = Oc(n)
  }
}
function t1(e) {
  e.modified_ || ((e.modified_ = !0), e.parent_ && t1(e.parent_))
}
function $m(e) {
  e.copy_ || (e.copy_ = Zv(e.base_, e.scope_.immer_.useStrictShallowCopy_))
}
var aK = class {
  constructor(e) {
    ;(this.autoFreeze_ = !0),
      (this.useStrictShallowCopy_ = !1),
      (this.produce = (t, n, r) => {
        if (typeof t == 'function' && typeof n != 'function') {
          const s = n
          n = t
          const o = this
          return function (l = s, ...c) {
            return o.produce(l, (u) => n.call(this, u, ...c))
          }
        }
        typeof n != 'function' && Ci(6), r !== void 0 && typeof r != 'function' && Ci(7)
        let i
        if ($s(t)) {
          const s = AE(this),
            o = n1(t, void 0)
          let a = !0
          try {
            ;(i = n(o)), (a = !1)
          } finally {
            a ? Jv(s) : e1(s)
          }
          return TE(s, r), RE(i, s)
        } else if (!t || typeof t != 'object') {
          if (
            ((i = n(t)),
            i === void 0 && (i = t),
            i === nT && (i = void 0),
            this.autoFreeze_ && _b(i, !0),
            r)
          ) {
            const s = [],
              o = []
            Va('Patches').generateReplacementPatches_(t, i, s, o), r(s, o)
          }
          return i
        } else Ci(1, t)
      }),
      (this.produceWithPatches = (t, n) => {
        if (typeof t == 'function')
          return (o, ...a) => this.produceWithPatches(o, (l) => t(l, ...a))
        let r, i
        return [
          this.produce(t, n, (o, a) => {
            ;(r = o), (i = a)
          }),
          r,
          i,
        ]
      }),
      typeof (e == null ? void 0 : e.autoFreeze) == 'boolean' && this.setAutoFreeze(e.autoFreeze),
      typeof (e == null ? void 0 : e.useStrictShallowCopy) == 'boolean' &&
        this.setUseStrictShallowCopy(e.useStrictShallowCopy)
  }
  createDraft(e) {
    $s(e) || Ci(8), zo(e) && (e = aT(e))
    const t = AE(this),
      n = n1(e, void 0)
    return (n[Tr].isManual_ = !0), e1(t), n
  }
  finishDraft(e, t) {
    const n = e && e[Tr]
    ;(!n || !n.isManual_) && Ci(9)
    const { scope_: r } = n
    return TE(r, t), RE(void 0, r)
  }
  setAutoFreeze(e) {
    this.autoFreeze_ = e
  }
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e
  }
  applyPatches(e, t) {
    let n
    for (n = t.length - 1; n >= 0; n--) {
      const i = t[n]
      if (i.path.length === 0 && i.op === 'replace') {
        e = i.value
        break
      }
    }
    n > -1 && (t = t.slice(n + 1))
    const r = Va('Patches').applyPatches_
    return zo(e) ? r(e, t) : this.produce(e, (i) => r(i, t))
  }
}
function n1(e, t) {
  const n = fg(e) ? Va('MapSet').proxyMap_(e, t) : dg(e) ? Va('MapSet').proxySet_(e, t) : sK(e, t)
  return (t ? t.scope_ : sT()).drafts_.push(n), n
}
function aT(e) {
  return zo(e) || Ci(10, e), lT(e)
}
function lT(e) {
  if (!$s(e) || hg(e)) return e
  const t = e[Tr]
  let n
  if (t) {
    if (!t.modified_) return t.base_
    ;(t.finalized_ = !0), (n = Zv(e, t.scope_.immer_.useStrictShallowCopy_))
  } else n = Zv(e, !0)
  return (
    u0(n, (r, i) => {
      iT(n, r, lT(i))
    }),
    t && (t.finalized_ = !1),
    n
  )
}
var Ar = new aK(),
  cT = Ar.produce
Ar.produceWithPatches.bind(Ar)
Ar.setAutoFreeze.bind(Ar)
Ar.setUseStrictShallowCopy.bind(Ar)
Ar.applyPatches.bind(Ar)
Ar.createDraft.bind(Ar)
Ar.finishDraft.bind(Ar)
function lK(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != 'function') throw new TypeError(t)
}
function cK(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != 'object') throw new TypeError(t)
}
function uK(e, t = 'expected all items to be functions, instead received the following types: ') {
  if (!e.every((n) => typeof n == 'function')) {
    const n = e
      .map((r) => (typeof r == 'function' ? `function ${r.name || 'unnamed'}()` : typeof r))
      .join(', ')
    throw new TypeError(`${t}[${n}]`)
  }
}
var IE = (e) => (Array.isArray(e) ? e : [e])
function fK(e) {
  const t = Array.isArray(e[0]) ? e[0] : e
  return (
    uK(
      t,
      'createSelector expects all input-selectors to be functions, but received the following types: '
    ),
    t
  )
}
function dK(e, t) {
  const n = [],
    { length: r } = e
  for (let i = 0; i < r; i++) n.push(e[i].apply(null, t))
  return n
}
var hK = class {
    constructor(e) {
      this.value = e
    }
    deref() {
      return this.value
    }
  },
  pK = typeof WeakRef < 'u' ? WeakRef : hK,
  gK = 0,
  DE = 1
function Zd() {
  return { s: gK, v: void 0, o: null, p: null }
}
function kb(e, t = {}) {
  let n = Zd()
  const { resultEqualityCheck: r } = t
  let i,
    s = 0
  function o() {
    var f
    let a = n
    const { length: l } = arguments
    for (let d = 0, p = l; d < p; d++) {
      const h = arguments[d]
      if (typeof h == 'function' || (typeof h == 'object' && h !== null)) {
        let m = a.o
        m === null && (a.o = m = new WeakMap())
        const b = m.get(h)
        b === void 0 ? ((a = Zd()), m.set(h, a)) : (a = b)
      } else {
        let m = a.p
        m === null && (a.p = m = new Map())
        const b = m.get(h)
        b === void 0 ? ((a = Zd()), m.set(h, a)) : (a = b)
      }
    }
    const c = a
    let u
    if (a.s === DE) u = a.v
    else if (((u = e.apply(null, arguments)), s++, r)) {
      const d = ((f = i == null ? void 0 : i.deref) == null ? void 0 : f.call(i)) ?? i
      d != null && r(d, u) && ((u = d), s !== 0 && s--),
        (i = (typeof u == 'object' && u !== null) || typeof u == 'function' ? new pK(u) : u)
    }
    return (c.s = DE), (c.v = u), u
  }
  return (
    (o.clearCache = () => {
      ;(n = Zd()), o.resetResultsCount()
    }),
    (o.resultsCount = () => s),
    (o.resetResultsCount = () => {
      s = 0
    }),
    o
  )
}
function uT(e, ...t) {
  const n = typeof e == 'function' ? { memoize: e, memoizeOptions: t } : e,
    r = (...i) => {
      let s = 0,
        o = 0,
        a,
        l = {},
        c = i.pop()
      typeof c == 'object' && ((l = c), (c = i.pop())),
        lK(
          c,
          `createSelector expects an output function after the inputs, but received: [${typeof c}]`
        )
      const u = { ...n, ...l },
        {
          memoize: f,
          memoizeOptions: d = [],
          argsMemoize: p = kb,
          argsMemoizeOptions: h = [],
          devModeChecks: m = {},
        } = u,
        b = IE(d),
        y = IE(h),
        v = fK(i),
        S = f(function () {
          return s++, c.apply(null, arguments)
        }, ...b),
        T = p(function () {
          o++
          const I = dK(v, arguments)
          return (a = S.apply(null, I)), a
        }, ...y)
      return Object.assign(T, {
        resultFunc: c,
        memoizedResultFunc: S,
        dependencies: v,
        dependencyRecomputations: () => o,
        resetDependencyRecomputations: () => {
          o = 0
        },
        lastResult: () => a,
        recomputations: () => s,
        resetRecomputations: () => {
          s = 0
        },
        memoize: f,
        argsMemoize: p,
      })
    }
  return Object.assign(r, { withTypes: () => r }), r
}
var mK = uT(kb),
  yK = Object.assign(
    (e, t = mK) => {
      cK(
        e,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`
      )
      const n = Object.keys(e),
        r = n.map((s) => e[s])
      return t(r, (...s) => s.reduce((o, a, l) => ((o[n[l]] = a), o), {}))
    },
    { withTypes: () => yK }
  )
function fT(e) {
  return ({ dispatch: n, getState: r }) =>
    (i) =>
    (s) =>
      typeof s == 'function' ? s(n, r, e) : i(s)
}
var vK = fT(),
  wK = fT,
  bK = (...e) => {
    const t = uT(...e),
      n = Object.assign(
        (...r) => {
          const i = t(...r),
            s = (o, ...a) => i(zo(o) ? aT(o) : o, ...a)
          return Object.assign(s, i), s
        },
        { withTypes: () => n }
      )
    return n
  }
bK(kb)
var xK =
    typeof window < 'u' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == 'object' ? c0 : c0.apply(null, arguments)
        },
  SK = (e) => e && typeof e.match == 'function'
function Pa(e, t) {
  function n(...r) {
    if (t) {
      let i = t(...r)
      if (!i) throw new Error(Wo(0))
      return {
        type: e,
        payload: i.payload,
        ...('meta' in i && { meta: i.meta }),
        ...('error' in i && { error: i.error }),
      }
    }
    return { type: e, payload: r[0] }
  }
  return (n.toString = () => `${e}`), (n.type = e), (n.match = (r) => Zq(r) && r.type === e), n
}
var dT = class Au extends Array {
  constructor(...t) {
    super(...t), Object.setPrototypeOf(this, Au.prototype)
  }
  static get [Symbol.species]() {
    return Au
  }
  concat(...t) {
    return super.concat.apply(this, t)
  }
  prepend(...t) {
    return t.length === 1 && Array.isArray(t[0])
      ? new Au(...t[0].concat(this))
      : new Au(...t.concat(this))
  }
}
function NE(e) {
  return $s(e) ? cT(e, () => {}) : e
}
function EK(e) {
  return typeof e == 'boolean'
}
var CK = () =>
    function (t) {
      const {
        thunk: n = !0,
        immutableCheck: r = !0,
        serializableCheck: i = !0,
        actionCreatorCheck: s = !0,
      } = t ?? {}
      let o = new dT()
      return n && (EK(n) ? o.push(vK) : o.push(wK(n.extraArgument))), o
    },
  _K = 'RTK_autoBatch',
  hT = (e) => (t) => {
    setTimeout(t, e)
  },
  OK = typeof window < 'u' && window.requestAnimationFrame ? window.requestAnimationFrame : hT(10),
  kK =
    (e = { type: 'raf' }) =>
    (t) =>
    (...n) => {
      const r = t(...n)
      let i = !0,
        s = !1,
        o = !1
      const a = new Set(),
        l =
          e.type === 'tick'
            ? queueMicrotask
            : e.type === 'raf'
            ? OK
            : e.type === 'callback'
            ? e.queueNotification
            : hT(e.timeout),
        c = () => {
          ;(o = !1), s && ((s = !1), a.forEach((u) => u()))
        }
      return Object.assign({}, r, {
        subscribe(u) {
          const f = () => i && u(),
            d = r.subscribe(f)
          return (
            a.add(u),
            () => {
              d(), a.delete(u)
            }
          )
        },
        dispatch(u) {
          var f
          try {
            return (
              (i = !((f = u == null ? void 0 : u.meta) != null && f[_K])),
              (s = !i),
              s && (o || ((o = !0), l(c))),
              r.dispatch(u)
            )
          } finally {
            i = !0
          }
        },
      })
    },
  TK = (e) =>
    function (n) {
      const { autoBatch: r = !0 } = n ?? {}
      let i = new dT(e)
      return r && i.push(kK(typeof r == 'object' ? r : void 0)), i
    },
  AK = !0
function RK(e) {
  const t = CK(),
    {
      reducer: n = void 0,
      middleware: r,
      devTools: i = !0,
      preloadedState: s = void 0,
      enhancers: o = void 0,
    } = e || {}
  let a
  if (typeof n == 'function') a = n
  else if (Cb(n)) a = Qq(n)
  else throw new Error(Wo(1))
  let l
  typeof r == 'function' ? (l = r(t)) : (l = t())
  let c = c0
  i && (c = xK({ trace: !AK, ...(typeof i == 'object' && i) }))
  const u = Xq(...l),
    f = TK(u)
  let d = typeof o == 'function' ? o(f) : f()
  const p = c(...d)
  return tT(a, s, p)
}
function PK(e) {
  const t = {},
    n = []
  let r
  const i = {
    addCase(s, o) {
      const a = typeof s == 'string' ? s : s.type
      if (!a) throw new Error(Wo(28))
      if (a in t) throw new Error(Wo(29))
      return (t[a] = o), i
    },
    addMatcher(s, o) {
      return n.push({ matcher: s, reducer: o }), i
    },
    addDefaultCase(s) {
      return (r = s), i
    },
  }
  return e(i), [t, n, r]
}
function IK(e) {
  return typeof e == 'function'
}
function Tb(e, t) {
  let [n, r, i] = PK(t),
    s
  if (IK(e)) s = () => NE(e())
  else {
    const a = NE(e)
    s = () => a
  }
  function o(a = s(), l) {
    let c = [n[l.type], ...r.filter(({ matcher: u }) => u(l)).map(({ reducer: u }) => u)]
    return (
      c.filter((u) => !!u).length === 0 && (c = [i]),
      c.reduce((u, f) => {
        if (f)
          if (zo(u)) {
            const p = f(u, l)
            return p === void 0 ? u : p
          } else {
            if ($s(u)) return cT(u, (d) => f(d, l))
            {
              const d = f(u, l)
              if (d === void 0) {
                if (u === null) return u
                throw new Error(Wo(9))
              }
              return d
            }
          }
        return u
      }, a)
    )
  }
  return (o.getInitialState = s), o
}
var DK = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW',
  pT = (e = 21) => {
    let t = '',
      n = e
    for (; n--; ) t += DK[(Math.random() * 64) | 0]
    return t
  },
  NK = (e, t) => (SK(e) ? e.match(t) : e(t))
function MK(...e) {
  return (t) => e.some((n) => NK(n, t))
}
var jK = ['name', 'message', 'stack', 'code'],
  Fm = class {
    constructor(e, t) {
      zn(this, '_type')
      ;(this.payload = e), (this.meta = t)
    }
  },
  ME = class {
    constructor(e, t) {
      zn(this, '_type')
      ;(this.payload = e), (this.meta = t)
    }
  },
  LK = (e) => {
    if (typeof e == 'object' && e !== null) {
      const t = {}
      for (const n of jK) typeof e[n] == 'string' && (t[n] = e[n])
      return t
    }
    return { message: String(e) }
  },
  Ko = (() => {
    function e(t, n, r) {
      const i = Pa(t + '/fulfilled', (l, c, u, f) => ({
          payload: l,
          meta: { ...(f || {}), arg: u, requestId: c, requestStatus: 'fulfilled' },
        })),
        s = Pa(t + '/pending', (l, c, u) => ({
          payload: void 0,
          meta: { ...(u || {}), arg: c, requestId: l, requestStatus: 'pending' },
        })),
        o = Pa(t + '/rejected', (l, c, u, f, d) => ({
          payload: f,
          error: ((r && r.serializeError) || LK)(l || 'Rejected'),
          meta: {
            ...(d || {}),
            arg: u,
            requestId: c,
            rejectedWithValue: !!f,
            requestStatus: 'rejected',
            aborted: (l == null ? void 0 : l.name) === 'AbortError',
            condition: (l == null ? void 0 : l.name) === 'ConditionError',
          },
        }))
      function a(l) {
        return (c, u, f) => {
          const d = r != null && r.idGenerator ? r.idGenerator(l) : pT(),
            p = new AbortController()
          let h, m
          function b(v) {
            ;(m = v), p.abort()
          }
          const y = (async function () {
            var T, A
            let v
            try {
              let I =
                (T = r == null ? void 0 : r.condition) == null
                  ? void 0
                  : T.call(r, l, { getState: u, extra: f })
              if ((FK(I) && (I = await I), I === !1 || p.signal.aborted))
                throw {
                  name: 'ConditionError',
                  message: 'Aborted due to condition callback returning false.',
                }
              const k = new Promise((D, F) => {
                ;(h = () => {
                  F({ name: 'AbortError', message: m || 'Aborted' })
                }),
                  p.signal.addEventListener('abort', h)
              })
              c(
                s(
                  d,
                  l,
                  (A = r == null ? void 0 : r.getPendingMeta) == null
                    ? void 0
                    : A.call(r, { requestId: d, arg: l }, { getState: u, extra: f })
                )
              ),
                (v = await Promise.race([
                  k,
                  Promise.resolve(
                    n(l, {
                      dispatch: c,
                      getState: u,
                      extra: f,
                      requestId: d,
                      signal: p.signal,
                      abort: b,
                      rejectWithValue: (D, F) => new Fm(D, F),
                      fulfillWithValue: (D, F) => new ME(D, F),
                    })
                  ).then((D) => {
                    if (D instanceof Fm) throw D
                    return D instanceof ME ? i(D.payload, d, l, D.meta) : i(D, d, l)
                  }),
                ]))
            } catch (I) {
              v = I instanceof Fm ? o(null, d, l, I.payload, I.meta) : o(I, d, l)
            } finally {
              h && p.signal.removeEventListener('abort', h)
            }
            return (r && !r.dispatchConditionRejection && o.match(v) && v.meta.condition) || c(v), v
          })()
          return Object.assign(y, {
            abort: b,
            requestId: d,
            arg: l,
            unwrap() {
              return y.then($K)
            },
          })
        }
      }
      return Object.assign(a, {
        pending: s,
        rejected: o,
        fulfilled: i,
        settled: MK(o, i),
        typePrefix: t,
      })
    }
    return (e.withTypes = () => e), e
  })()
function $K(e) {
  if (e.meta && e.meta.rejectedWithValue) throw e.payload
  if (e.error) throw e.error
  return e.payload
}
function FK(e) {
  return e !== null && typeof e == 'object' && typeof e.then == 'function'
}
var BK = (e, t) => {
    if (typeof e != 'function') throw new Error(Wo(32))
  },
  Ab = 'listenerMiddleware',
  UK = (e) => {
    let { type: t, actionCreator: n, matcher: r, predicate: i, effect: s } = e
    if (t) i = Pa(t).match
    else if (n) (t = n.type), (i = n.match)
    else if (r) i = r
    else if (!i) throw new Error(Wo(21))
    return BK(s), { predicate: i, type: t, effect: s }
  },
  zK = Object.assign(
    (e) => {
      const { type: t, predicate: n, effect: r } = UK(e)
      return {
        id: pT(),
        effect: r,
        type: t,
        predicate: n,
        pending: new Set(),
        unsubscribe: () => {
          throw new Error(Wo(22))
        },
      }
    },
    { withTypes: () => zK }
  ),
  WK = Object.assign(Pa(`${Ab}/add`), { withTypes: () => WK })
Pa(`${Ab}/removeAll`)
var VK = Object.assign(Pa(`${Ab}/remove`), { withTypes: () => VK })
function Wo(e) {
  return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `
}
const HK = Ko('account/get', () => {}),
  qK = Ko('account/get-message', async () => {
    try {
      await ed
        .get('/login-message')
        .then((e) => (console.log('7s200:res', e.data.message), null))
        .catch((e) => {})
    } catch {
      return null
    }
  }),
  KK = { loading: !1 },
  GK = Tb(KK, (e) => {
    e.addCase(qK.fulfilled, (t, n) => {}).addCase(HK.fulfilled, (t, n) => {})
  }),
  jE = Ko(
    'game/get',
    async ({ index: e, activeAccount: t, activeSigner: n }, { getState: r, dispatch: i }) => {
      try {
        return ''
      } catch {
        return null
      }
    }
  ),
  YK = { loading: !1, game: null },
  QK = Tb(YK, (e) => {
    e.addCase(jE.pending, (t) => {
      t.loading = !0
    }).addCase(jE.fulfilled, (t, n) => {
      ;(t.game = n.payload.ok), (t.loading = !1)
    })
  }),
  LE = Ko('tournament/get', async ({}, { getState: e, dispatch: t }) => {
    try {
      return ''
    } catch (n) {
      return console.log('7s200:err', n), null
    }
  })
Ko(
  'tournament/create',
  async ({ activeSigner: e, activeAccount: t, reward: n, totalPlayer: r }, {}) => {
    try {
      return ''
    } catch (i) {
      console.log('7s200:createTournament:err', i)
      return
    }
  }
)
Ko(
  'tournament/update',
  async ({ activeSigner: e, activeAccount: t, tournamentIndex: n, isStart: r, isEnd: i }, {}) => {
    try {
      return ''
    } catch (s) {
      console.log('7s200:updateTournamentStatus:err', s)
      return
    }
  }
)
Ko(
  'tournament/register',
  async ({ activeSigner: e, activeAccount: t, tournamentIndex: n, cb: r }, {}) => {
    try {
      return ''
    } catch (i) {
      console.log('7s200:registerTournament:err', i), r(!1)
      return
    }
  }
)
Ko('tournament/claim', async ({ activeSigner: e, activeAccount: t, tournamentIndex: n }, {}) => {
  try {
    return ''
  } catch (r) {
    console.log('7s200:claimReward:err', r)
    return
  }
})
const XK = { loading: !1, tournament: null },
  ZK = Tb(XK, (e) => {
    e.addCase(LE.pending, (t) => {
      t.loading = !0
    }).addCase(LE.fulfilled, (t, n) => {
      ;(t.tournament = n.payload), (t.loading = !1)
    })
  }),
  JK = () => RK({ reducer: { account: GK, game: QK, tournament: ZK } })
let eG = JK()
const tG = () => JR()
function nG() {
  const e = Sb(),
    { currentWallet: t, connectionStatus: n } = Kc(),
    r = cg(),
    { mutate: i } = qq()
  w.useState(!1),
    Rw(),
    tG(),
    w.useEffect(() => {
      if (!localStorage.getItem('token') || localStorage.getItem('token').length <= 0 || !r) {
        const o = `login::${r == null ? void 0 : r.address}::${new Date().getTime()}`
        i(
          { message: new TextEncoder().encode(o) },
          {
            onSuccess: async (a) => {
              const l = {
                address: r == null ? void 0 : r.address,
                message: o,
                signature: a.signature,
              }
              await ed
                .post('/login-verify-account', l)
                .then((c) => {
                  if (c.data.status === 200) {
                    const u = c.data.token
                    localStorage.setItem('token', u), sj(u), (window.location.href = '/')
                  }
                })
                .catch((c) => {
                  console.log(c)
                })
            },
          }
        )
      }
    }, [e, r, n])
  function s() {
    let o = !1
    return localStorage.getItem('token') ? (o = !0) : (o = !1), o
  }
  return n === 'disconnected' && !r
    ? E.jsx(kq, {
        className:
          '!text-white bg-gradient-to-r from-green-500 via-blue-500 to-green-500 !rounded-lg font-bold  text-center text-white min-w-[150px] leading-[21px] py-1 cursor-pointer',
        connectText: 'connect wallet',
      })
    : s() && r && r.publicKey
    ? E.jsx('div', {
        className:
          '!text-white bg-gradient-to-r from-green-500 via-blue-500 to-green-500 !rounded-lg font-bold  text-center text-white min-w-[150px] leading-[21px] py-1 cursor-pointer',
        children: E.jsx('div', { children: hs(r.address) }),
      })
    : E.jsx(E.Fragment, {})
}
const gT = () => {
  const [e, t] = w.useState(!1)
  w.useRef(null)
  const n = $0()
  L0()
  const r = () => {
    t(!e)
  }
  return (
    w.useEffect(() => {
      function i() {
        window.innerWidth >= 768 && t(!1)
      }
      return (
        window.addEventListener('resize', i),
        () => {
          window.removeEventListener('resize', i)
        }
      )
    }, []),
    E.jsx(E.Fragment, {
      children: E.jsx('nav', {
        className: 'fixed top-0 z-50 w-full bg-black',
        children: E.jsx('div', {
          className: 'px-3 py-3 lg:px-5 lg:pl-3',
          children: E.jsxs('div', {
            className: 'flex items-center justify-between',
            children: [
              E.jsxs('div', {
                className: 'flex items-center justify-start',
                children: [
                  E.jsxs('button', {
                    onClick: () => r(),
                    'data-drawer-target': 'logo-sidebar',
                    'data-drawer-toggle': 'logo-sidebar',
                    'aria-controls': 'logo-sidebar',
                    type: 'button',
                    className:
                      'inline-flex items-center p-2 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200',
                    children: [
                      E.jsx('span', { className: 'sr-only', children: 'Open sidebar' }),
                      E.jsx('svg', {
                        className: 'w-6 h-6',
                        'aria-hidden': 'true',
                        fill: 'currentColor',
                        viewBox: '0 0 20 20',
                        xmlns: 'http://www.w3.org/2000/svg',
                        children: E.jsx('path', {
                          clipRule: 'evenodd',
                          fillRule: 'evenodd',
                          d: 'M2 4.75A.75.75 0 012.75 4h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 4.75zm0 10.5a.75.75 0 01.75-.75h7.5a.75.75 0 010 1.5h-7.5a.75.75 0 01-.75-.75zM2 10a.75.75 0 01.75-.75h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 10z',
                        }),
                      }),
                    ],
                  }),
                  E.jsx('div', {
                    className: 'flex items-center',
                    children: E.jsx('div', {
                      onClick: () => {
                        n('/')
                      },
                      className: 'cursor-pointer flex ml-2 md:mr-7',
                      children: E.jsx('img', {
                        src: '/DeChess.png',
                        className: 'h-[32px] w-[32px]',
                        alt: 'Transca vault Logo',
                      }),
                    }),
                  }),
                ],
              }),
              E.jsx('div', {
                className: 'hidden md:flex md:justify-end lg:flex lg:flex-1 lg:justify-end',
                children: E.jsx(nG, {}),
              }),
            ],
          }),
        }),
      }),
    })
  )
}
function Pf(e) {
  '@babel/helpers - typeof'
  return (
    (Pf =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t
          }),
    Pf(e)
  )
}
function rG(e, t) {
  if (Pf(e) != 'object' || !e) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || 'default')
    if (Pf(r) != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (t === 'string' ? String : Number)(e)
}
function iG(e) {
  var t = rG(e, 'string')
  return Pf(t) == 'symbol' ? t : t + ''
}
function sG(e, t, n) {
  return (
    (t = iG(t)) in e
      ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 })
      : (e[t] = n),
    e
  )
}
function oG(e, t) {
  if (e == null) return {}
  var n = {}
  for (var r in e)
    if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue
      n[r] = e[r]
    }
  return n
}
function aG(e, t) {
  if (e == null) return {}
  var n,
    r,
    i = oG(e, t)
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e)
    for (r = 0; r < s.length; r++)
      (n = s[r]), t.indexOf(n) >= 0 || ({}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]))
  }
  return i
}
var ar = function () {
  return (
    (ar =
      Object.assign ||
      function (t) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r]
          for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s])
        }
        return t
      }),
    ar.apply(this, arguments)
  )
}
function h0(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, s; r < i; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), (s[r] = t[r]))
  return e.concat(s || Array.prototype.slice.call(t))
}
var Dt = '-ms-',
  Gu = '-moz-',
  Et = '-webkit-',
  mT = 'comm',
  pg = 'rule',
  Rb = 'decl',
  lG = '@import',
  yT = '@keyframes',
  cG = '@layer',
  vT = Math.abs,
  Pb = String.fromCharCode,
  r1 = Object.assign
function uG(e, t) {
  return bn(e, 0) ^ 45
    ? (((((((t << 2) ^ bn(e, 0)) << 2) ^ bn(e, 1)) << 2) ^ bn(e, 2)) << 2) ^ bn(e, 3)
    : 0
}
function wT(e) {
  return e.trim()
}
function ws(e, t) {
  return (e = t.exec(e)) ? e[0] : e
}
function rt(e, t, n) {
  return e.replace(t, n)
}
function ep(e, t, n) {
  return e.indexOf(t, n)
}
function bn(e, t) {
  return e.charCodeAt(t) | 0
}
function kc(e, t, n) {
  return e.slice(t, n)
}
function Ki(e) {
  return e.length
}
function bT(e) {
  return e.length
}
function Ru(e, t) {
  return t.push(e), e
}
function fG(e, t) {
  return e.map(t).join('')
}
function $E(e, t) {
  return e.filter(function (n) {
    return !ws(n, t)
  })
}
var gg = 1,
  Tc = 1,
  xT = 0,
  ri = 0,
  nn = 0,
  Gc = ''
function mg(e, t, n, r, i, s, o, a) {
  return {
    value: e,
    root: t,
    parent: n,
    type: r,
    props: i,
    children: s,
    line: gg,
    column: Tc,
    length: o,
    return: '',
    siblings: a,
  }
}
function lo(e, t) {
  return r1(mg('', null, null, '', null, null, 0, e.siblings), e, { length: -e.length }, t)
}
function cl(e) {
  for (; e.root; ) e = lo(e.root, { children: [e] })
  Ru(e, e.siblings)
}
function dG() {
  return nn
}
function hG() {
  return (nn = ri > 0 ? bn(Gc, --ri) : 0), Tc--, nn === 10 && ((Tc = 1), gg--), nn
}
function Ri() {
  return (nn = ri < xT ? bn(Gc, ri++) : 0), Tc++, nn === 10 && ((Tc = 1), gg++), nn
}
function Ia() {
  return bn(Gc, ri)
}
function tp() {
  return ri
}
function yg(e, t) {
  return kc(Gc, e, t)
}
function i1(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4
    case 58:
      return 3
    case 34:
    case 39:
    case 40:
    case 91:
      return 2
    case 41:
    case 93:
      return 1
  }
  return 0
}
function pG(e) {
  return (gg = Tc = 1), (xT = Ki((Gc = e))), (ri = 0), []
}
function gG(e) {
  return (Gc = ''), e
}
function Bm(e) {
  return wT(yg(ri - 1, s1(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}
function mG(e) {
  for (; (nn = Ia()) && nn < 33; ) Ri()
  return i1(e) > 2 || i1(nn) > 3 ? '' : ' '
}
function yG(e, t) {
  for (; --t && Ri() && !(nn < 48 || nn > 102 || (nn > 57 && nn < 65) || (nn > 70 && nn < 97)); );
  return yg(e, tp() + (t < 6 && Ia() == 32 && Ri() == 32))
}
function s1(e) {
  for (; Ri(); )
    switch (nn) {
      case e:
        return ri
      case 34:
      case 39:
        e !== 34 && e !== 39 && s1(nn)
        break
      case 40:
        e === 41 && s1(e)
        break
      case 92:
        Ri()
        break
    }
  return ri
}
function vG(e, t) {
  for (; Ri() && e + nn !== 47 + 10; ) if (e + nn === 42 + 42 && Ia() === 47) break
  return '/*' + yg(t, ri - 1) + '*' + Pb(e === 47 ? e : Ri())
}
function wG(e) {
  for (; !i1(Ia()); ) Ri()
  return yg(e, ri)
}
function bG(e) {
  return gG(np('', null, null, null, [''], (e = pG(e)), 0, [0], e))
}
function np(e, t, n, r, i, s, o, a, l) {
  for (
    var c = 0,
      u = 0,
      f = o,
      d = 0,
      p = 0,
      h = 0,
      m = 1,
      b = 1,
      y = 1,
      v = 0,
      S = '',
      T = i,
      A = s,
      I = r,
      k = S;
    b;

  )
    switch (((h = v), (v = Ri()))) {
      case 40:
        if (h != 108 && bn(k, f - 1) == 58) {
          ep((k += rt(Bm(v), '&', '&\f')), '&\f', vT(c ? a[c - 1] : 0)) != -1 && (y = -1)
          break
        }
      case 34:
      case 39:
      case 91:
        k += Bm(v)
        break
      case 9:
      case 10:
      case 13:
      case 32:
        k += mG(h)
        break
      case 92:
        k += yG(tp() - 1, 7)
        continue
      case 47:
        switch (Ia()) {
          case 42:
          case 47:
            Ru(xG(vG(Ri(), tp()), t, n, l), l)
            break
          default:
            k += '/'
        }
        break
      case 123 * m:
        a[c++] = Ki(k) * y
      case 125 * m:
      case 59:
      case 0:
        switch (v) {
          case 0:
          case 125:
            b = 0
          case 59 + u:
            y == -1 && (k = rt(k, /\f/g, '')),
              p > 0 &&
                Ki(k) - f &&
                Ru(
                  p > 32 ? BE(k + ';', r, n, f - 1, l) : BE(rt(k, ' ', '') + ';', r, n, f - 2, l),
                  l
                )
            break
          case 59:
            k += ';'
          default:
            if ((Ru((I = FE(k, t, n, c, u, i, a, S, (T = []), (A = []), f, s)), s), v === 123))
              if (u === 0) np(k, t, I, I, T, s, f, a, A)
              else
                switch (d === 99 && bn(k, 3) === 110 ? 100 : d) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    np(
                      e,
                      I,
                      I,
                      r && Ru(FE(e, I, I, 0, 0, i, a, S, i, (T = []), f, A), A),
                      i,
                      A,
                      f,
                      a,
                      r ? T : A
                    )
                    break
                  default:
                    np(k, I, I, I, [''], A, 0, a, A)
                }
        }
        ;(c = u = p = 0), (m = y = 1), (S = k = ''), (f = o)
        break
      case 58:
        ;(f = 1 + Ki(k)), (p = h)
      default:
        if (m < 1) {
          if (v == 123) --m
          else if (v == 125 && m++ == 0 && hG() == 125) continue
        }
        switch (((k += Pb(v)), v * m)) {
          case 38:
            y = u > 0 ? 1 : ((k += '\f'), -1)
            break
          case 44:
            ;(a[c++] = (Ki(k) - 1) * y), (y = 1)
            break
          case 64:
            Ia() === 45 && (k += Bm(Ri())), (d = Ia()), (u = f = Ki((S = k += wG(tp())))), v++
            break
          case 45:
            h === 45 && Ki(k) == 2 && (m = 0)
        }
    }
  return s
}
function FE(e, t, n, r, i, s, o, a, l, c, u, f) {
  for (var d = i - 1, p = i === 0 ? s : [''], h = bT(p), m = 0, b = 0, y = 0; m < r; ++m)
    for (var v = 0, S = kc(e, d + 1, (d = vT((b = o[m])))), T = e; v < h; ++v)
      (T = wT(b > 0 ? p[v] + ' ' + S : rt(S, /&\f/g, p[v]))) && (l[y++] = T)
  return mg(e, t, n, i === 0 ? pg : a, l, c, u, f)
}
function xG(e, t, n, r) {
  return mg(e, t, n, mT, Pb(dG()), kc(e, 2, -2), 0, r)
}
function BE(e, t, n, r, i) {
  return mg(e, t, n, Rb, kc(e, 0, r), kc(e, r + 1, -1), r, i)
}
function ST(e, t, n) {
  switch (uG(e, t)) {
    case 5103:
      return Et + 'print-' + e + e
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Et + e + e
    case 4789:
      return Gu + e + e
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Et + e + Gu + e + Dt + e + e
    case 5936:
      switch (bn(e, t + 11)) {
        case 114:
          return Et + e + Dt + rt(e, /[svh]\w+-[tblr]{2}/, 'tb') + e
        case 108:
          return Et + e + Dt + rt(e, /[svh]\w+-[tblr]{2}/, 'tb-rl') + e
        case 45:
          return Et + e + Dt + rt(e, /[svh]\w+-[tblr]{2}/, 'lr') + e
      }
    case 6828:
    case 4268:
    case 2903:
      return Et + e + Dt + e + e
    case 6165:
      return Et + e + Dt + 'flex-' + e + e
    case 5187:
      return Et + e + rt(e, /(\w+).+(:[^]+)/, Et + 'box-$1$2' + Dt + 'flex-$1$2') + e
    case 5443:
      return (
        Et +
        e +
        Dt +
        'flex-item-' +
        rt(e, /flex-|-self/g, '') +
        (ws(e, /flex-|baseline/) ? '' : Dt + 'grid-row-' + rt(e, /flex-|-self/g, '')) +
        e
      )
    case 4675:
      return Et + e + Dt + 'flex-line-pack' + rt(e, /align-content|flex-|-self/g, '') + e
    case 5548:
      return Et + e + Dt + rt(e, 'shrink', 'negative') + e
    case 5292:
      return Et + e + Dt + rt(e, 'basis', 'preferred-size') + e
    case 6060:
      return Et + 'box-' + rt(e, '-grow', '') + Et + e + Dt + rt(e, 'grow', 'positive') + e
    case 4554:
      return Et + rt(e, /([^-])(transform)/g, '$1' + Et + '$2') + e
    case 6187:
      return rt(rt(rt(e, /(zoom-|grab)/, Et + '$1'), /(image-set)/, Et + '$1'), e, '') + e
    case 5495:
    case 3959:
      return rt(e, /(image-set\([^]*)/, Et + '$1$`$1')
    case 4968:
      return (
        rt(
          rt(e, /(.+:)(flex-)?(.*)/, Et + 'box-pack:$3' + Dt + 'flex-pack:$3'),
          /s.+-b[^;]+/,
          'justify'
        ) +
        Et +
        e +
        e
      )
    case 4200:
      if (!ws(e, /flex-|baseline/)) return Dt + 'grid-column-align' + kc(e, t) + e
      break
    case 2592:
    case 3360:
      return Dt + rt(e, 'template-', '') + e
    case 4384:
    case 3616:
      return n &&
        n.some(function (r, i) {
          return (t = i), ws(r.props, /grid-\w+-end/)
        })
        ? ~ep(e + (n = n[t].value), 'span', 0)
          ? e
          : Dt +
            rt(e, '-start', '') +
            e +
            Dt +
            'grid-row-span:' +
            (~ep(n, 'span', 0) ? ws(n, /\d+/) : +ws(n, /\d+/) - +ws(e, /\d+/)) +
            ';'
        : Dt + rt(e, '-start', '') + e
    case 4896:
    case 4128:
      return n &&
        n.some(function (r) {
          return ws(r.props, /grid-\w+-start/)
        })
        ? e
        : Dt + rt(rt(e, '-end', '-span'), 'span ', '') + e
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return rt(e, /(.+)-inline(.+)/, Et + '$1$2') + e
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Ki(e) - 1 - t > 6)
        switch (bn(e, t + 1)) {
          case 109:
            if (bn(e, t + 4) !== 45) break
          case 102:
            return (
              rt(
                e,
                /(.+:)(.+)-([^]+)/,
                '$1' + Et + '$2-$3$1' + Gu + (bn(e, t + 3) == 108 ? '$3' : '$2-$3')
              ) + e
            )
          case 115:
            return ~ep(e, 'stretch', 0) ? ST(rt(e, 'stretch', 'fill-available'), t, n) + e : e
        }
      break
    case 5152:
    case 5920:
      return rt(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function (r, i, s, o, a, l, c) {
        return Dt + i + ':' + s + c + (o ? Dt + i + '-span:' + (a ? l : +l - +s) + c : '') + e
      })
    case 4949:
      if (bn(e, t + 6) === 121) return rt(e, ':', ':' + Et) + e
      break
    case 6444:
      switch (bn(e, bn(e, 14) === 45 ? 18 : 11)) {
        case 120:
          return (
            rt(
              e,
              /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/,
              '$1' +
                Et +
                (bn(e, 14) === 45 ? 'inline-' : '') +
                'box$3$1' +
                Et +
                '$2$3$1' +
                Dt +
                '$2box$3'
            ) + e
          )
        case 100:
          return rt(e, ':', ':' + Dt) + e
      }
      break
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return rt(e, 'scroll-', 'scroll-snap-') + e
  }
  return e
}
function p0(e, t) {
  for (var n = '', r = 0; r < e.length; r++) n += t(e[r], r, e, t) || ''
  return n
}
function SG(e, t, n, r) {
  switch (e.type) {
    case cG:
      if (e.children.length) break
    case lG:
    case Rb:
      return (e.return = e.return || e.value)
    case mT:
      return ''
    case yT:
      return (e.return = e.value + '{' + p0(e.children, r) + '}')
    case pg:
      if (!Ki((e.value = e.props.join(',')))) return ''
  }
  return Ki((n = p0(e.children, r))) ? (e.return = e.value + '{' + n + '}') : ''
}
function EG(e) {
  var t = bT(e)
  return function (n, r, i, s) {
    for (var o = '', a = 0; a < t; a++) o += e[a](n, r, i, s) || ''
    return o
  }
}
function CG(e) {
  return function (t) {
    t.root || ((t = t.return) && e(t))
  }
}
function _G(e, t, n, r) {
  if (e.length > -1 && !e.return)
    switch (e.type) {
      case Rb:
        e.return = ST(e.value, e.length, n)
        return
      case yT:
        return p0([lo(e, { value: rt(e.value, '@', '@' + Et) })], r)
      case pg:
        if (e.length)
          return fG((n = e.props), function (i) {
            switch (ws(i, (r = /(::plac\w+|:read-\w+)/))) {
              case ':read-only':
              case ':read-write':
                cl(lo(e, { props: [rt(i, /:(read-\w+)/, ':' + Gu + '$1')] })),
                  cl(lo(e, { props: [i] })),
                  r1(e, { props: $E(n, r) })
                break
              case '::placeholder':
                cl(lo(e, { props: [rt(i, /:(plac\w+)/, ':' + Et + 'input-$1')] })),
                  cl(lo(e, { props: [rt(i, /:(plac\w+)/, ':' + Gu + '$1')] })),
                  cl(lo(e, { props: [rt(i, /:(plac\w+)/, Dt + 'input-$1')] })),
                  cl(lo(e, { props: [i] })),
                  r1(e, { props: $E(n, r) })
                break
            }
            return ''
          })
    }
}
var OG = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  Ac =
    (typeof process < 'u' && process.env !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR)) ||
    'data-styled',
  ET = 'active',
  CT = 'data-styled-version',
  vg = '6.1.11',
  Ib = `/*!sc*/
`,
  Db = typeof window < 'u' && 'HTMLElement' in window,
  kG = !!(typeof SC_DISABLE_SPEEDY == 'boolean'
    ? SC_DISABLE_SPEEDY
    : typeof process < 'u' &&
      process.env !== void 0 &&
      {}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 &&
      {}.REACT_APP_SC_DISABLE_SPEEDY !== ''
    ? {}.REACT_APP_SC_DISABLE_SPEEDY !== 'false' && {}.REACT_APP_SC_DISABLE_SPEEDY
    : typeof process < 'u' &&
      process.env !== void 0 &&
      {}.SC_DISABLE_SPEEDY !== void 0 &&
      {}.SC_DISABLE_SPEEDY !== '' &&
      {}.SC_DISABLE_SPEEDY !== 'false' &&
      {}.SC_DISABLE_SPEEDY),
  wg = Object.freeze([]),
  Rc = Object.freeze({})
function TG(e, t, n) {
  return n === void 0 && (n = Rc), (e.theme !== n.theme && e.theme) || t || n.theme
}
var _T = new Set([
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'big',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'track',
    'u',
    'ul',
    'use',
    'var',
    'video',
    'wbr',
    'circle',
    'clipPath',
    'defs',
    'ellipse',
    'foreignObject',
    'g',
    'image',
    'line',
    'linearGradient',
    'marker',
    'mask',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'stop',
    'svg',
    'text',
    'tspan',
  ]),
  AG = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
  RG = /(^-|-$)/g
function UE(e) {
  return e.replace(AG, '-').replace(RG, '')
}
var PG = /(a)(d)/gi,
  Jd = 52,
  zE = function (e) {
    return String.fromCharCode(e + (e > 25 ? 39 : 97))
  }
function o1(e) {
  var t,
    n = ''
  for (t = Math.abs(e); t > Jd; t = (t / Jd) | 0) n = zE(t % Jd) + n
  return (zE(t % Jd) + n).replace(PG, '$1-$2')
}
var Um,
  OT = 5381,
  Dl = function (e, t) {
    for (var n = t.length; n; ) e = (33 * e) ^ t.charCodeAt(--n)
    return e
  },
  kT = function (e) {
    return Dl(OT, e)
  }
function IG(e) {
  return o1(kT(e) >>> 0)
}
function DG(e) {
  return e.displayName || e.name || 'Component'
}
function zm(e) {
  return typeof e == 'string' && !0
}
var TT = typeof Symbol == 'function' && Symbol.for,
  AT = TT ? Symbol.for('react.memo') : 60115,
  NG = TT ? Symbol.for('react.forward_ref') : 60112,
  MG = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0,
  },
  jG = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 },
  RT = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 },
  LG =
    (((Um = {})[NG] = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
    }),
    (Um[AT] = RT),
    Um)
function WE(e) {
  return ('type' in (t = e) && t.type.$$typeof) === AT ? RT : '$$typeof' in e ? LG[e.$$typeof] : MG
  var t
}
var $G = Object.defineProperty,
  FG = Object.getOwnPropertyNames,
  VE = Object.getOwnPropertySymbols,
  BG = Object.getOwnPropertyDescriptor,
  UG = Object.getPrototypeOf,
  HE = Object.prototype
function PT(e, t, n) {
  if (typeof t != 'string') {
    if (HE) {
      var r = UG(t)
      r && r !== HE && PT(e, r, n)
    }
    var i = FG(t)
    VE && (i = i.concat(VE(t)))
    for (var s = WE(e), o = WE(t), a = 0; a < i.length; ++a) {
      var l = i[a]
      if (!(l in jG || (n && n[l]) || (o && l in o) || (s && l in s))) {
        var c = BG(t, l)
        try {
          $G(e, l, c)
        } catch {}
      }
    }
  }
  return e
}
function Pc(e) {
  return typeof e == 'function'
}
function Nb(e) {
  return typeof e == 'object' && 'styledComponentId' in e
}
function va(e, t) {
  return e && t ? ''.concat(e, ' ').concat(t) : e || t || ''
}
function qE(e, t) {
  if (e.length === 0) return ''
  for (var n = e[0], r = 1; r < e.length; r++) n += t ? t + e[r] : e[r]
  return n
}
function If(e) {
  return (
    e !== null &&
    typeof e == 'object' &&
    e.constructor.name === Object.name &&
    !('props' in e && e.$$typeof)
  )
}
function a1(e, t, n) {
  if ((n === void 0 && (n = !1), !n && !If(e) && !Array.isArray(e))) return t
  if (Array.isArray(t)) for (var r = 0; r < t.length; r++) e[r] = a1(e[r], t[r])
  else if (If(t)) for (var r in t) e[r] = a1(e[r], t[r])
  return e
}
function Mb(e, t) {
  Object.defineProperty(e, 'toString', { value: t })
}
function cd(e) {
  for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
  return new Error(
    'An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#'
      .concat(e, ' for more information.')
      .concat(t.length > 0 ? ' Args: '.concat(t.join(', ')) : '')
  )
}
var zG = (function () {
    function e(t) {
      ;(this.groupSizes = new Uint32Array(512)), (this.length = 512), (this.tag = t)
    }
    return (
      (e.prototype.indexOfGroup = function (t) {
        for (var n = 0, r = 0; r < t; r++) n += this.groupSizes[r]
        return n
      }),
      (e.prototype.insertRules = function (t, n) {
        if (t >= this.groupSizes.length) {
          for (var r = this.groupSizes, i = r.length, s = i; t >= s; )
            if ((s <<= 1) < 0) throw cd(16, ''.concat(t))
          ;(this.groupSizes = new Uint32Array(s)), this.groupSizes.set(r), (this.length = s)
          for (var o = i; o < s; o++) this.groupSizes[o] = 0
        }
        for (var a = this.indexOfGroup(t + 1), l = ((o = 0), n.length); o < l; o++)
          this.tag.insertRule(a, n[o]) && (this.groupSizes[t]++, a++)
      }),
      (e.prototype.clearGroup = function (t) {
        if (t < this.length) {
          var n = this.groupSizes[t],
            r = this.indexOfGroup(t),
            i = r + n
          this.groupSizes[t] = 0
          for (var s = r; s < i; s++) this.tag.deleteRule(r)
        }
      }),
      (e.prototype.getGroup = function (t) {
        var n = ''
        if (t >= this.length || this.groupSizes[t] === 0) return n
        for (var r = this.groupSizes[t], i = this.indexOfGroup(t), s = i + r, o = i; o < s; o++)
          n += ''.concat(this.tag.getRule(o)).concat(Ib)
        return n
      }),
      e
    )
  })(),
  rp = new Map(),
  g0 = new Map(),
  ip = 1,
  eh = function (e) {
    if (rp.has(e)) return rp.get(e)
    for (; g0.has(ip); ) ip++
    var t = ip++
    return rp.set(e, t), g0.set(t, e), t
  },
  WG = function (e, t) {
    ;(ip = t + 1), rp.set(e, t), g0.set(t, e)
  },
  VG = 'style['.concat(Ac, '][').concat(CT, '="').concat(vg, '"]'),
  HG = new RegExp('^'.concat(Ac, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')),
  qG = function (e, t, n) {
    for (var r, i = n.split(','), s = 0, o = i.length; s < o; s++)
      (r = i[s]) && e.registerName(t, r)
  },
  KG = function (e, t) {
    for (
      var n,
        r = ((n = t.textContent) !== null && n !== void 0 ? n : '').split(Ib),
        i = [],
        s = 0,
        o = r.length;
      s < o;
      s++
    ) {
      var a = r[s].trim()
      if (a) {
        var l = a.match(HG)
        if (l) {
          var c = 0 | parseInt(l[1], 10),
            u = l[2]
          c !== 0 && (WG(u, c), qG(e, u, l[3]), e.getTag().insertRules(c, i)), (i.length = 0)
        } else i.push(a)
      }
    }
  }
function GG() {
  return typeof __webpack_nonce__ < 'u' ? __webpack_nonce__ : null
}
var IT = function (e) {
    var t = document.head,
      n = e || t,
      r = document.createElement('style'),
      i = (function (a) {
        var l = Array.from(a.querySelectorAll('style['.concat(Ac, ']')))
        return l[l.length - 1]
      })(n),
      s = i !== void 0 ? i.nextSibling : null
    r.setAttribute(Ac, ET), r.setAttribute(CT, vg)
    var o = GG()
    return o && r.setAttribute('nonce', o), n.insertBefore(r, s), r
  },
  YG = (function () {
    function e(t) {
      ;(this.element = IT(t)),
        this.element.appendChild(document.createTextNode('')),
        (this.sheet = (function (n) {
          if (n.sheet) return n.sheet
          for (var r = document.styleSheets, i = 0, s = r.length; i < s; i++) {
            var o = r[i]
            if (o.ownerNode === n) return o
          }
          throw cd(17)
        })(this.element)),
        (this.length = 0)
    }
    return (
      (e.prototype.insertRule = function (t, n) {
        try {
          return this.sheet.insertRule(n, t), this.length++, !0
        } catch {
          return !1
        }
      }),
      (e.prototype.deleteRule = function (t) {
        this.sheet.deleteRule(t), this.length--
      }),
      (e.prototype.getRule = function (t) {
        var n = this.sheet.cssRules[t]
        return n && n.cssText ? n.cssText : ''
      }),
      e
    )
  })(),
  QG = (function () {
    function e(t) {
      ;(this.element = IT(t)), (this.nodes = this.element.childNodes), (this.length = 0)
    }
    return (
      (e.prototype.insertRule = function (t, n) {
        if (t <= this.length && t >= 0) {
          var r = document.createTextNode(n)
          return this.element.insertBefore(r, this.nodes[t] || null), this.length++, !0
        }
        return !1
      }),
      (e.prototype.deleteRule = function (t) {
        this.element.removeChild(this.nodes[t]), this.length--
      }),
      (e.prototype.getRule = function (t) {
        return t < this.length ? this.nodes[t].textContent : ''
      }),
      e
    )
  })(),
  XG = (function () {
    function e(t) {
      ;(this.rules = []), (this.length = 0)
    }
    return (
      (e.prototype.insertRule = function (t, n) {
        return t <= this.length && (this.rules.splice(t, 0, n), this.length++, !0)
      }),
      (e.prototype.deleteRule = function (t) {
        this.rules.splice(t, 1), this.length--
      }),
      (e.prototype.getRule = function (t) {
        return t < this.length ? this.rules[t] : ''
      }),
      e
    )
  })(),
  KE = Db,
  ZG = { isServer: !Db, useCSSOMInjection: !kG },
  DT = (function () {
    function e(t, n, r) {
      t === void 0 && (t = Rc), n === void 0 && (n = {})
      var i = this
      ;(this.options = ar(ar({}, ZG), t)),
        (this.gs = n),
        (this.names = new Map(r)),
        (this.server = !!t.isServer),
        !this.server &&
          Db &&
          KE &&
          ((KE = !1),
          (function (s) {
            for (var o = document.querySelectorAll(VG), a = 0, l = o.length; a < l; a++) {
              var c = o[a]
              c &&
                c.getAttribute(Ac) !== ET &&
                (KG(s, c), c.parentNode && c.parentNode.removeChild(c))
            }
          })(this)),
        Mb(this, function () {
          return (function (s) {
            for (
              var o = s.getTag(),
                a = o.length,
                l = '',
                c = function (f) {
                  var d = (function (y) {
                    return g0.get(y)
                  })(f)
                  if (d === void 0) return 'continue'
                  var p = s.names.get(d),
                    h = o.getGroup(f)
                  if (p === void 0 || h.length === 0) return 'continue'
                  var m = ''.concat(Ac, '.g').concat(f, '[id="').concat(d, '"]'),
                    b = ''
                  p !== void 0 &&
                    p.forEach(function (y) {
                      y.length > 0 && (b += ''.concat(y, ','))
                    }),
                    (l += ''.concat(h).concat(m, '{content:"').concat(b, '"}').concat(Ib))
                },
                u = 0;
              u < a;
              u++
            )
              c(u)
            return l
          })(i)
        })
    }
    return (
      (e.registerId = function (t) {
        return eh(t)
      }),
      (e.prototype.reconstructWithOptions = function (t, n) {
        return (
          n === void 0 && (n = !0),
          new e(ar(ar({}, this.options), t), this.gs, (n && this.names) || void 0)
        )
      }),
      (e.prototype.allocateGSInstance = function (t) {
        return (this.gs[t] = (this.gs[t] || 0) + 1)
      }),
      (e.prototype.getTag = function () {
        return (
          this.tag ||
          (this.tag =
            ((t = (function (n) {
              var r = n.useCSSOMInjection,
                i = n.target
              return n.isServer ? new XG(i) : r ? new YG(i) : new QG(i)
            })(this.options)),
            new zG(t)))
        )
        var t
      }),
      (e.prototype.hasNameForId = function (t, n) {
        return this.names.has(t) && this.names.get(t).has(n)
      }),
      (e.prototype.registerName = function (t, n) {
        if ((eh(t), this.names.has(t))) this.names.get(t).add(n)
        else {
          var r = new Set()
          r.add(n), this.names.set(t, r)
        }
      }),
      (e.prototype.insertRules = function (t, n, r) {
        this.registerName(t, n), this.getTag().insertRules(eh(t), r)
      }),
      (e.prototype.clearNames = function (t) {
        this.names.has(t) && this.names.get(t).clear()
      }),
      (e.prototype.clearRules = function (t) {
        this.getTag().clearGroup(eh(t)), this.clearNames(t)
      }),
      (e.prototype.clearTag = function () {
        this.tag = void 0
      }),
      e
    )
  })(),
  JG = /&/g,
  eY = /^\s*\/\/.*$/gm
function NT(e, t) {
  return e.map(function (n) {
    return (
      n.type === 'rule' &&
        ((n.value = ''.concat(t, ' ').concat(n.value)),
        (n.value = n.value.replaceAll(',', ','.concat(t, ' '))),
        (n.props = n.props.map(function (r) {
          return ''.concat(t, ' ').concat(r)
        }))),
      Array.isArray(n.children) && n.type !== '@keyframes' && (n.children = NT(n.children, t)),
      n
    )
  })
}
function tY(e) {
  var t,
    n,
    r,
    i = e === void 0 ? Rc : e,
    s = i.options,
    o = s === void 0 ? Rc : s,
    a = i.plugins,
    l = a === void 0 ? wg : a,
    c = function (d, p, h) {
      return h.startsWith(n) && h.endsWith(n) && h.replaceAll(n, '').length > 0 ? '.'.concat(t) : d
    },
    u = l.slice()
  u.push(function (d) {
    d.type === pg && d.value.includes('&') && (d.props[0] = d.props[0].replace(JG, n).replace(r, c))
  }),
    o.prefix && u.push(_G),
    u.push(SG)
  var f = function (d, p, h, m) {
    p === void 0 && (p = ''),
      h === void 0 && (h = ''),
      m === void 0 && (m = '&'),
      (t = m),
      (n = p),
      (r = new RegExp('\\'.concat(n, '\\b'), 'g'))
    var b = d.replace(eY, ''),
      y = bG(h || p ? ''.concat(h, ' ').concat(p, ' { ').concat(b, ' }') : b)
    o.namespace && (y = NT(y, o.namespace))
    var v = []
    return (
      p0(
        y,
        EG(
          u.concat(
            CG(function (S) {
              return v.push(S)
            })
          )
        )
      ),
      v
    )
  }
  return (
    (f.hash = l.length
      ? l
          .reduce(function (d, p) {
            return p.name || cd(15), Dl(d, p.name)
          }, OT)
          .toString()
      : ''),
    f
  )
}
var nY = new DT(),
  l1 = tY(),
  MT = fn.createContext({ shouldForwardProp: void 0, styleSheet: nY, stylis: l1 })
MT.Consumer
fn.createContext(void 0)
function GE() {
  return w.useContext(MT)
}
var rY = (function () {
    function e(t, n) {
      var r = this
      ;(this.inject = function (i, s) {
        s === void 0 && (s = l1)
        var o = r.name + s.hash
        i.hasNameForId(r.id, o) || i.insertRules(r.id, o, s(r.rules, o, '@keyframes'))
      }),
        (this.name = t),
        (this.id = 'sc-keyframes-'.concat(t)),
        (this.rules = n),
        Mb(this, function () {
          throw cd(12, String(r.name))
        })
    }
    return (
      (e.prototype.getName = function (t) {
        return t === void 0 && (t = l1), this.name + t.hash
      }),
      e
    )
  })(),
  iY = function (e) {
    return e >= 'A' && e <= 'Z'
  }
function YE(e) {
  for (var t = '', n = 0; n < e.length; n++) {
    var r = e[n]
    if (n === 1 && r === '-' && e[0] === '-') return e
    iY(r) ? (t += '-' + r.toLowerCase()) : (t += r)
  }
  return t.startsWith('ms-') ? '-' + t : t
}
var jT = function (e) {
    return e == null || e === !1 || e === ''
  },
  LT = function (e) {
    var t,
      n,
      r = []
    for (var i in e) {
      var s = e[i]
      e.hasOwnProperty(i) &&
        !jT(s) &&
        ((Array.isArray(s) && s.isCss) || Pc(s)
          ? r.push(''.concat(YE(i), ':'), s, ';')
          : If(s)
          ? r.push.apply(r, h0(h0([''.concat(i, ' {')], LT(s), !1), ['}'], !1))
          : r.push(
              ''
                .concat(YE(i), ': ')
                .concat(
                  ((t = i),
                  (n = s) == null || typeof n == 'boolean' || n === ''
                    ? ''
                    : typeof n != 'number' || n === 0 || t in OG || t.startsWith('--')
                    ? String(n).trim()
                    : ''.concat(n, 'px')),
                  ';'
                )
            ))
    }
    return r
  }
function Da(e, t, n, r) {
  if (jT(e)) return []
  if (Nb(e)) return ['.'.concat(e.styledComponentId)]
  if (Pc(e)) {
    if (!Pc((s = e)) || (s.prototype && s.prototype.isReactComponent) || !t) return [e]
    var i = e(t)
    return Da(i, t, n, r)
  }
  var s
  return e instanceof rY
    ? n
      ? (e.inject(n, r), [e.getName(r)])
      : [e]
    : If(e)
    ? LT(e)
    : Array.isArray(e)
    ? Array.prototype.concat.apply(
        wg,
        e.map(function (o) {
          return Da(o, t, n, r)
        })
      )
    : [e.toString()]
}
function sY(e) {
  for (var t = 0; t < e.length; t += 1) {
    var n = e[t]
    if (Pc(n) && !Nb(n)) return !1
  }
  return !0
}
var oY = kT(vg),
  aY = (function () {
    function e(t, n, r) {
      ;(this.rules = t),
        (this.staticRulesId = ''),
        (this.isStatic = (r === void 0 || r.isStatic) && sY(t)),
        (this.componentId = n),
        (this.baseHash = Dl(oY, n)),
        (this.baseStyle = r),
        DT.registerId(n)
    }
    return (
      (e.prototype.generateAndInjectStyles = function (t, n, r) {
        var i = this.baseStyle ? this.baseStyle.generateAndInjectStyles(t, n, r) : ''
        if (this.isStatic && !r.hash)
          if (this.staticRulesId && n.hasNameForId(this.componentId, this.staticRulesId))
            i = va(i, this.staticRulesId)
          else {
            var s = qE(Da(this.rules, t, n, r)),
              o = o1(Dl(this.baseHash, s) >>> 0)
            if (!n.hasNameForId(this.componentId, o)) {
              var a = r(s, '.'.concat(o), void 0, this.componentId)
              n.insertRules(this.componentId, o, a)
            }
            ;(i = va(i, o)), (this.staticRulesId = o)
          }
        else {
          for (var l = Dl(this.baseHash, r.hash), c = '', u = 0; u < this.rules.length; u++) {
            var f = this.rules[u]
            if (typeof f == 'string') c += f
            else if (f) {
              var d = qE(Da(f, t, n, r))
              ;(l = Dl(l, d + u)), (c += d)
            }
          }
          if (c) {
            var p = o1(l >>> 0)
            n.hasNameForId(this.componentId, p) ||
              n.insertRules(this.componentId, p, r(c, '.'.concat(p), void 0, this.componentId)),
              (i = va(i, p))
          }
        }
        return i
      }),
      e
    )
  })(),
  $T = fn.createContext(void 0)
$T.Consumer
var Wm = {}
function lY(e, t, n) {
  var r = Nb(e),
    i = e,
    s = !zm(e),
    o = t.attrs,
    a = o === void 0 ? wg : o,
    l = t.componentId,
    c =
      l === void 0
        ? (function (T, A) {
            var I = typeof T != 'string' ? 'sc' : UE(T)
            Wm[I] = (Wm[I] || 0) + 1
            var k = ''.concat(I, '-').concat(IG(vg + I + Wm[I]))
            return A ? ''.concat(A, '-').concat(k) : k
          })(t.displayName, t.parentComponentId)
        : l,
    u = t.displayName,
    f =
      u === void 0
        ? (function (T) {
            return zm(T) ? 'styled.'.concat(T) : 'Styled('.concat(DG(T), ')')
          })(e)
        : u,
    d =
      t.displayName && t.componentId
        ? ''.concat(UE(t.displayName), '-').concat(t.componentId)
        : t.componentId || c,
    p = r && i.attrs ? i.attrs.concat(a).filter(Boolean) : a,
    h = t.shouldForwardProp
  if (r && i.shouldForwardProp) {
    var m = i.shouldForwardProp
    if (t.shouldForwardProp) {
      var b = t.shouldForwardProp
      h = function (T, A) {
        return m(T, A) && b(T, A)
      }
    } else h = m
  }
  var y = new aY(n, d, r ? i.componentStyle : void 0)
  function v(T, A) {
    return (function (I, k, D) {
      var F = I.attrs,
        V = I.componentStyle,
        ie = I.defaultProps,
        de = I.foldedComponentIds,
        xe = I.styledComponentId,
        we = I.target,
        Pe = fn.useContext($T),
        We = GE(),
        Me = I.shouldForwardProp || We.shouldForwardProp,
        K = TG(k, Pe, ie) || Rc,
        H = (function (re, Z, it) {
          for (
            var wt, Ze = ar(ar({}, Z), { className: void 0, theme: it }), _t = 0;
            _t < re.length;
            _t += 1
          ) {
            var gn = Pc((wt = re[_t])) ? wt(Ze) : wt
            for (var bt in gn)
              Ze[bt] =
                bt === 'className'
                  ? va(Ze[bt], gn[bt])
                  : bt === 'style'
                  ? ar(ar({}, Ze[bt]), gn[bt])
                  : gn[bt]
          }
          return Z.className && (Ze.className = va(Ze.className, Z.className)), Ze
        })(F, k, K),
        oe = H.as || we,
        Ae = {}
      for (var Ie in H)
        H[Ie] === void 0 ||
          Ie[0] === '$' ||
          Ie === 'as' ||
          (Ie === 'theme' && H.theme === K) ||
          (Ie === 'forwardedAs' ? (Ae.as = H.forwardedAs) : (Me && !Me(Ie, oe)) || (Ae[Ie] = H[Ie]))
      var fe = (function (re, Z) {
          var it = GE(),
            wt = re.generateAndInjectStyles(Z, it.styleSheet, it.stylis)
          return wt
        })(V, H),
        _e = va(de, xe)
      return (
        fe && (_e += ' ' + fe),
        H.className && (_e += ' ' + H.className),
        (Ae[zm(oe) && !_T.has(oe) ? 'class' : 'className'] = _e),
        (Ae.ref = D),
        w.createElement(oe, Ae)
      )
    })(S, T, A)
  }
  v.displayName = f
  var S = fn.forwardRef(v)
  return (
    (S.attrs = p),
    (S.componentStyle = y),
    (S.displayName = f),
    (S.shouldForwardProp = h),
    (S.foldedComponentIds = r ? va(i.foldedComponentIds, i.styledComponentId) : ''),
    (S.styledComponentId = d),
    (S.target = r ? i.target : e),
    Object.defineProperty(S, 'defaultProps', {
      get: function () {
        return this._foldedDefaultProps
      },
      set: function (T) {
        this._foldedDefaultProps = r
          ? (function (A) {
              for (var I = [], k = 1; k < arguments.length; k++) I[k - 1] = arguments[k]
              for (var D = 0, F = I; D < F.length; D++) a1(A, F[D], !0)
              return A
            })({}, i.defaultProps, T)
          : T
      },
    }),
    Mb(S, function () {
      return '.'.concat(S.styledComponentId)
    }),
    s &&
      PT(S, e, {
        attrs: !0,
        componentStyle: !0,
        displayName: !0,
        foldedComponentIds: !0,
        shouldForwardProp: !0,
        styledComponentId: !0,
        target: !0,
      }),
    S
  )
}
function QE(e, t) {
  for (var n = [e[0]], r = 0, i = t.length; r < i; r += 1) n.push(t[r], e[r + 1])
  return n
}
var XE = function (e) {
  return Object.assign(e, { isCss: !0 })
}
function cY(e) {
  for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n]
  if (Pc(e) || If(e)) return XE(Da(QE(wg, h0([e], t, !0))))
  var r = e
  return t.length === 0 && r.length === 1 && typeof r[0] == 'string' ? Da(r) : XE(Da(QE(r, t)))
}
function c1(e, t, n) {
  if ((n === void 0 && (n = Rc), !t)) throw cd(1, t)
  var r = function (i) {
    for (var s = [], o = 1; o < arguments.length; o++) s[o - 1] = arguments[o]
    return e(t, n, cY.apply(void 0, h0([i], s, !1)))
  }
  return (
    (r.attrs = function (i) {
      return c1(e, t, ar(ar({}, n), { attrs: Array.prototype.concat(n.attrs, i).filter(Boolean) }))
    }),
    (r.withConfig = function (i) {
      return c1(e, t, ar(ar({}, n), i))
    }),
    r
  )
}
var FT = function (e) {
    return c1(lY, e)
  },
  BT = FT
_T.forEach(function (e) {
  BT[e] = FT(e)
})
var uY = ['children', 'iconAttrs', 'iconVerticalAlign', 'iconViewBox', 'size', 'title']
function ZE(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function JE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? ZE(Object(n), !0).forEach(function (r) {
          sG(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : ZE(Object(n)).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
        })
  }
  return e
}
var fY = w.forwardRef(function (e, t) {
    var n = e.children,
      r = e.iconAttrs
    e.iconVerticalAlign
    var i = e.iconViewBox,
      s = e.size,
      o = e.title,
      a = aG(e, uY),
      l = JE(
        JE(
          {
            viewBox: i,
            height: e.height !== void 0 ? e.height : s,
            width: e.width !== void 0 ? e.width : s,
            'aria-hidden': o == null ? 'true' : void 0,
            focusable: 'false',
            role: o != null ? 'img' : void 0,
          },
          r
        ),
        a
      )
    return w.createElement(
      'svg',
      He({}, l, { ref: t }),
      o && w.createElement('title', { key: 'icon-title' }, o),
      n
    )
  }),
  UT = BT(fY).withConfig({ displayName: 'StyledIconBase', componentId: 'sc-ea9ulj-0' })(
    ['display:inline-block;vertical-align:', ';overflow:hidden;'],
    function (e) {
      return e.iconVerticalAlign
    }
  ),
  zT = w.forwardRef(function (e, t) {
    var n = { fill: 'currentColor', xmlns: 'http://www.w3.org/2000/svg' }
    return w.createElement(
      UT,
      He({ iconAttrs: n, iconVerticalAlign: 'middle', iconViewBox: '0 0 20 20' }, e, { ref: t }),
      w.createElement('path', {
        d: 'M10 3a7 7 0 0 0-7 7 .5.5 0 0 1-1 0 8 8 0 1 1 8 8 .5.5 0 0 1 0-1 7 7 0 1 0 0-14Z',
      })
    )
  })
zT.displayName = 'SpinnerIos'
function dY(...e) {
  const t = new Set()
  for (const n of e) {
    const r = typeof n
    if (r === 'string' && n.length > 0) t.add(n)
    else if (r === 'object' && n !== null) for (const [i, s] of Object.entries(n)) s && t.add(i)
  }
  return [...t].join(' ')
}
const WT = dY,
  hY = ({
    children: e,
    onClick: t,
    className: n,
    disabled: r,
    hide: i,
    type: s,
    loading: o,
    kind: a = 'normal',
    size: l = 'normal',
  }) =>
    i
      ? null
      : E.jsxs('button', {
          type: s || 'button',
          className: WT(
            { 'py-2 px-5': l === 'normal', 'py-1 px-2': l === 'small' },
            'cursor-pointer rounded',
            'flex items-center justify-center gap-2',
            n,
            {
              'bg-gray-200 hover:bg-gray-300 active:bg-gray-400': a === 'normal',
              'bg-gray-300': r && a === 'normal',
              'bg-blue-400 hover:bg-blue-300 active:bg-blue-500 text-white': a === 'success',
              'bg-blue-300 active:bg-blue-300': r && a === 'success',
              'bg-red-500 hover:bg-red-300 active:bg-red-600 text-white': a === 'confirm',
              'bg-red-400': r && a === 'confirm',
              'text-gray-400 bg-gray-200 hover:bg-gray-200 active:bg-gray-200': o && a === 'normal',
              'text-white bg-blue-200 hover:bg-blue-200 active:bg-blue-200': o && a === 'success',
              'text-gray-400 bg-red-200 hover:bg-red-200 active:bg-red-200': o && a === 'confirm',
            }
          ),
          onClick: t,
          disabled: o || r,
          children: [o ? E.jsx(zT, { className: 'animate-spin', size: 20 }) : null, ' ', e],
        }),
  VT = ({ children: e, className: t }) =>
    E.jsx('div', {
      className: WT(
        'inline-block align-bottom  overflow-hidden',
        'shadow-xl transform transition-all sm:my-8 sm:align-middle',
        'rounded-2xl',
        'w-[1200px] sm:max-w-lg',
        'px-6 py-4',
        'text-left',
        'z-50',
        t
      ),
      role: 'dialog',
      'aria-modal': 'true',
      'aria-labelledby': 'modal-headline',
      children: e,
    }),
  ss = Object.create(null)
ss.open = '0'
ss.close = '1'
ss.ping = '2'
ss.pong = '3'
ss.message = '4'
ss.upgrade = '5'
ss.noop = '6'
const sp = Object.create(null)
Object.keys(ss).forEach((e) => {
  sp[ss[e]] = e
})
const u1 = { type: 'error', data: 'parser error' },
  HT =
    typeof Blob == 'function' ||
    (typeof Blob < 'u' && Object.prototype.toString.call(Blob) === '[object BlobConstructor]'),
  qT = typeof ArrayBuffer == 'function',
  KT = (e) =>
    typeof ArrayBuffer.isView == 'function'
      ? ArrayBuffer.isView(e)
      : e && e.buffer instanceof ArrayBuffer,
  jb = ({ type: e, data: t }, n, r) =>
    HT && t instanceof Blob
      ? n
        ? r(t)
        : eC(t, r)
      : qT && (t instanceof ArrayBuffer || KT(t))
      ? n
        ? r(t)
        : eC(new Blob([t]), r)
      : r(ss[e] + (t || '')),
  eC = (e, t) => {
    const n = new FileReader()
    return (
      (n.onload = function () {
        const r = n.result.split(',')[1]
        t('b' + (r || ''))
      }),
      n.readAsDataURL(e)
    )
  }
function tC(e) {
  return e instanceof Uint8Array
    ? e
    : e instanceof ArrayBuffer
    ? new Uint8Array(e)
    : new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
}
let Vm
function pY(e, t) {
  if (HT && e.data instanceof Blob) return e.data.arrayBuffer().then(tC).then(t)
  if (qT && (e.data instanceof ArrayBuffer || KT(e.data))) return t(tC(e.data))
  jb(e, !1, (n) => {
    Vm || (Vm = new TextEncoder()), t(Vm.encode(n))
  })
}
const nC = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  Pu = typeof Uint8Array > 'u' ? [] : new Uint8Array(256)
for (let e = 0; e < nC.length; e++) Pu[nC.charCodeAt(e)] = e
const gY = (e) => {
    let t = e.length * 0.75,
      n = e.length,
      r,
      i = 0,
      s,
      o,
      a,
      l
    e[e.length - 1] === '=' && (t--, e[e.length - 2] === '=' && t--)
    const c = new ArrayBuffer(t),
      u = new Uint8Array(c)
    for (r = 0; r < n; r += 4)
      (s = Pu[e.charCodeAt(r)]),
        (o = Pu[e.charCodeAt(r + 1)]),
        (a = Pu[e.charCodeAt(r + 2)]),
        (l = Pu[e.charCodeAt(r + 3)]),
        (u[i++] = (s << 2) | (o >> 4)),
        (u[i++] = ((o & 15) << 4) | (a >> 2)),
        (u[i++] = ((a & 3) << 6) | (l & 63))
    return c
  },
  mY = typeof ArrayBuffer == 'function',
  Lb = (e, t) => {
    if (typeof e != 'string') return { type: 'message', data: GT(e, t) }
    const n = e.charAt(0)
    return n === 'b'
      ? { type: 'message', data: yY(e.substring(1), t) }
      : sp[n]
      ? e.length > 1
        ? { type: sp[n], data: e.substring(1) }
        : { type: sp[n] }
      : u1
  },
  yY = (e, t) => {
    if (mY) {
      const n = gY(e)
      return GT(n, t)
    } else return { base64: !0, data: e }
  },
  GT = (e, t) => {
    switch (t) {
      case 'blob':
        return e instanceof Blob ? e : new Blob([e])
      case 'arraybuffer':
      default:
        return e instanceof ArrayBuffer ? e : e.buffer
    }
  },
  YT = String.fromCharCode(30),
  vY = (e, t) => {
    const n = e.length,
      r = new Array(n)
    let i = 0
    e.forEach((s, o) => {
      jb(s, !1, (a) => {
        ;(r[o] = a), ++i === n && t(r.join(YT))
      })
    })
  },
  wY = (e, t) => {
    const n = e.split(YT),
      r = []
    for (let i = 0; i < n.length; i++) {
      const s = Lb(n[i], t)
      if ((r.push(s), s.type === 'error')) break
    }
    return r
  }
function bY() {
  return new TransformStream({
    transform(e, t) {
      pY(e, (n) => {
        const r = n.length
        let i
        if (r < 126) (i = new Uint8Array(1)), new DataView(i.buffer).setUint8(0, r)
        else if (r < 65536) {
          i = new Uint8Array(3)
          const s = new DataView(i.buffer)
          s.setUint8(0, 126), s.setUint16(1, r)
        } else {
          i = new Uint8Array(9)
          const s = new DataView(i.buffer)
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(r))
        }
        e.data && typeof e.data != 'string' && (i[0] |= 128), t.enqueue(i), t.enqueue(n)
      })
    },
  })
}
let Hm
function th(e) {
  return e.reduce((t, n) => t + n.length, 0)
}
function nh(e, t) {
  if (e[0].length === t) return e.shift()
  const n = new Uint8Array(t)
  let r = 0
  for (let i = 0; i < t; i++) (n[i] = e[0][r++]), r === e[0].length && (e.shift(), (r = 0))
  return e.length && r < e[0].length && (e[0] = e[0].slice(r)), n
}
function xY(e, t) {
  Hm || (Hm = new TextDecoder())
  const n = []
  let r = 0,
    i = -1,
    s = !1
  return new TransformStream({
    transform(o, a) {
      for (n.push(o); ; ) {
        if (r === 0) {
          if (th(n) < 1) break
          const l = nh(n, 1)
          ;(s = (l[0] & 128) === 128),
            (i = l[0] & 127),
            i < 126 ? (r = 3) : i === 126 ? (r = 1) : (r = 2)
        } else if (r === 1) {
          if (th(n) < 2) break
          const l = nh(n, 2)
          ;(i = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0)), (r = 3)
        } else if (r === 2) {
          if (th(n) < 8) break
          const l = nh(n, 8),
            c = new DataView(l.buffer, l.byteOffset, l.length),
            u = c.getUint32(0)
          if (u > Math.pow(2, 53 - 32) - 1) {
            a.enqueue(u1)
            break
          }
          ;(i = u * Math.pow(2, 32) + c.getUint32(4)), (r = 3)
        } else {
          if (th(n) < i) break
          const l = nh(n, i)
          a.enqueue(Lb(s ? l : Hm.decode(l), t)), (r = 0)
        }
        if (i === 0 || i > e) {
          a.enqueue(u1)
          break
        }
      }
    },
  })
}
const QT = 4
function sn(e) {
  if (e) return SY(e)
}
function SY(e) {
  for (var t in sn.prototype) e[t] = sn.prototype[t]
  return e
}
sn.prototype.on = sn.prototype.addEventListener = function (e, t) {
  return (
    (this._callbacks = this._callbacks || {}),
    (this._callbacks['$' + e] = this._callbacks['$' + e] || []).push(t),
    this
  )
}
sn.prototype.once = function (e, t) {
  function n() {
    this.off(e, n), t.apply(this, arguments)
  }
  return (n.fn = t), this.on(e, n), this
}
sn.prototype.off =
  sn.prototype.removeListener =
  sn.prototype.removeAllListeners =
  sn.prototype.removeEventListener =
    function (e, t) {
      if (((this._callbacks = this._callbacks || {}), arguments.length == 0))
        return (this._callbacks = {}), this
      var n = this._callbacks['$' + e]
      if (!n) return this
      if (arguments.length == 1) return delete this._callbacks['$' + e], this
      for (var r, i = 0; i < n.length; i++)
        if (((r = n[i]), r === t || r.fn === t)) {
          n.splice(i, 1)
          break
        }
      return n.length === 0 && delete this._callbacks['$' + e], this
    }
sn.prototype.emit = function (e) {
  this._callbacks = this._callbacks || {}
  for (
    var t = new Array(arguments.length - 1), n = this._callbacks['$' + e], r = 1;
    r < arguments.length;
    r++
  )
    t[r - 1] = arguments[r]
  if (n) {
    n = n.slice(0)
    for (var r = 0, i = n.length; r < i; ++r) n[r].apply(this, t)
  }
  return this
}
sn.prototype.emitReserved = sn.prototype.emit
sn.prototype.listeners = function (e) {
  return (this._callbacks = this._callbacks || {}), this._callbacks['$' + e] || []
}
sn.prototype.hasListeners = function (e) {
  return !!this.listeners(e).length
}
const Qr = (() =>
  typeof self < 'u' ? self : typeof window < 'u' ? window : Function('return this')())()
function XT(e, ...t) {
  return t.reduce((n, r) => (e.hasOwnProperty(r) && (n[r] = e[r]), n), {})
}
const EY = Qr.setTimeout,
  CY = Qr.clearTimeout
function bg(e, t) {
  t.useNativeTimers
    ? ((e.setTimeoutFn = EY.bind(Qr)), (e.clearTimeoutFn = CY.bind(Qr)))
    : ((e.setTimeoutFn = Qr.setTimeout.bind(Qr)), (e.clearTimeoutFn = Qr.clearTimeout.bind(Qr)))
}
const _Y = 1.33
function OY(e) {
  return typeof e == 'string' ? kY(e) : Math.ceil((e.byteLength || e.size) * _Y)
}
function kY(e) {
  let t = 0,
    n = 0
  for (let r = 0, i = e.length; r < i; r++)
    (t = e.charCodeAt(r)),
      t < 128
        ? (n += 1)
        : t < 2048
        ? (n += 2)
        : t < 55296 || t >= 57344
        ? (n += 3)
        : (r++, (n += 4))
  return n
}
function TY(e) {
  let t = ''
  for (let n in e)
    e.hasOwnProperty(n) &&
      (t.length && (t += '&'), (t += encodeURIComponent(n) + '=' + encodeURIComponent(e[n])))
  return t
}
function AY(e) {
  let t = {},
    n = e.split('&')
  for (let r = 0, i = n.length; r < i; r++) {
    let s = n[r].split('=')
    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1])
  }
  return t
}
class RY extends Error {
  constructor(t, n, r) {
    super(t), (this.description = n), (this.context = r), (this.type = 'TransportError')
  }
}
class $b extends sn {
  constructor(t) {
    super(),
      (this.writable = !1),
      bg(this, t),
      (this.opts = t),
      (this.query = t.query),
      (this.socket = t.socket)
  }
  onError(t, n, r) {
    return super.emitReserved('error', new RY(t, n, r)), this
  }
  open() {
    return (this.readyState = 'opening'), this.doOpen(), this
  }
  close() {
    return (
      (this.readyState === 'opening' || this.readyState === 'open') &&
        (this.doClose(), this.onClose()),
      this
    )
  }
  send(t) {
    this.readyState === 'open' && this.write(t)
  }
  onOpen() {
    ;(this.readyState = 'open'), (this.writable = !0), super.emitReserved('open')
  }
  onData(t) {
    const n = Lb(t, this.socket.binaryType)
    this.onPacket(n)
  }
  onPacket(t) {
    super.emitReserved('packet', t)
  }
  onClose(t) {
    ;(this.readyState = 'closed'), super.emitReserved('close', t)
  }
  pause(t) {}
  createUri(t, n = {}) {
    return t + '://' + this._hostname() + this._port() + this.opts.path + this._query(n)
  }
  _hostname() {
    const t = this.opts.hostname
    return t.indexOf(':') === -1 ? t : '[' + t + ']'
  }
  _port() {
    return this.opts.port &&
      ((this.opts.secure && +(this.opts.port !== 443)) ||
        (!this.opts.secure && Number(this.opts.port) !== 80))
      ? ':' + this.opts.port
      : ''
  }
  _query(t) {
    const n = TY(t)
    return n.length ? '?' + n : ''
  }
}
const ZT = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
  f1 = 64,
  PY = {}
let rC = 0,
  rh = 0,
  iC
function sC(e) {
  let t = ''
  do (t = ZT[e % f1] + t), (e = Math.floor(e / f1))
  while (e > 0)
  return t
}
function JT() {
  const e = sC(+new Date())
  return e !== iC ? ((rC = 0), (iC = e)) : e + '.' + sC(rC++)
}
for (; rh < f1; rh++) PY[ZT[rh]] = rh
let e4 = !1
try {
  e4 = typeof XMLHttpRequest < 'u' && 'withCredentials' in new XMLHttpRequest()
} catch {}
const IY = e4
function t4(e) {
  const t = e.xdomain
  try {
    if (typeof XMLHttpRequest < 'u' && (!t || IY)) return new XMLHttpRequest()
  } catch {}
  if (!t)
    try {
      return new Qr[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP')
    } catch {}
}
function DY() {}
const NY = (function () {
  return new t4({ xdomain: !1 }).responseType != null
})()
class MY extends $b {
  constructor(t) {
    if ((super(t), (this.polling = !1), typeof location < 'u')) {
      const r = location.protocol === 'https:'
      let i = location.port
      i || (i = r ? '443' : '80'),
        (this.xd = (typeof location < 'u' && t.hostname !== location.hostname) || i !== t.port)
    }
    const n = t && t.forceBase64
    ;(this.supportsBinary = NY && !n), this.opts.withCredentials && (this.cookieJar = void 0)
  }
  get name() {
    return 'polling'
  }
  doOpen() {
    this.poll()
  }
  pause(t) {
    this.readyState = 'pausing'
    const n = () => {
      ;(this.readyState = 'paused'), t()
    }
    if (this.polling || !this.writable) {
      let r = 0
      this.polling &&
        (r++,
        this.once('pollComplete', function () {
          --r || n()
        })),
        this.writable ||
          (r++,
          this.once('drain', function () {
            --r || n()
          }))
    } else n()
  }
  poll() {
    ;(this.polling = !0), this.doPoll(), this.emitReserved('poll')
  }
  onData(t) {
    const n = (r) => {
      if ((this.readyState === 'opening' && r.type === 'open' && this.onOpen(), r.type === 'close'))
        return this.onClose({ description: 'transport closed by the server' }), !1
      this.onPacket(r)
    }
    wY(t, this.socket.binaryType).forEach(n),
      this.readyState !== 'closed' &&
        ((this.polling = !1),
        this.emitReserved('pollComplete'),
        this.readyState === 'open' && this.poll())
  }
  doClose() {
    const t = () => {
      this.write([{ type: 'close' }])
    }
    this.readyState === 'open' ? t() : this.once('open', t)
  }
  write(t) {
    ;(this.writable = !1),
      vY(t, (n) => {
        this.doWrite(n, () => {
          ;(this.writable = !0), this.emitReserved('drain')
        })
      })
  }
  uri() {
    const t = this.opts.secure ? 'https' : 'http',
      n = this.query || {}
    return (
      this.opts.timestampRequests !== !1 && (n[this.opts.timestampParam] = JT()),
      !this.supportsBinary && !n.sid && (n.b64 = 1),
      this.createUri(t, n)
    )
  }
  request(t = {}) {
    return (
      Object.assign(t, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new Yl(this.uri(), t)
    )
  }
  doWrite(t, n) {
    const r = this.request({ method: 'POST', data: t })
    r.on('success', n),
      r.on('error', (i, s) => {
        this.onError('xhr post error', i, s)
      })
  }
  doPoll() {
    const t = this.request()
    t.on('data', this.onData.bind(this)),
      t.on('error', (n, r) => {
        this.onError('xhr poll error', n, r)
      }),
      (this.pollXhr = t)
  }
}
let Yl = class op extends sn {
  constructor(t, n) {
    super(),
      bg(this, n),
      (this.opts = n),
      (this.method = n.method || 'GET'),
      (this.uri = t),
      (this.data = n.data !== void 0 ? n.data : null),
      this.create()
  }
  create() {
    var t
    const n = XT(
      this.opts,
      'agent',
      'pfx',
      'key',
      'passphrase',
      'cert',
      'ca',
      'ciphers',
      'rejectUnauthorized',
      'autoUnref'
    )
    n.xdomain = !!this.opts.xd
    const r = (this.xhr = new t4(n))
    try {
      r.open(this.method, this.uri, !0)
      try {
        if (this.opts.extraHeaders) {
          r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0)
          for (let i in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(i) &&
              r.setRequestHeader(i, this.opts.extraHeaders[i])
        }
      } catch {}
      if (this.method === 'POST')
        try {
          r.setRequestHeader('Content-type', 'text/plain;charset=UTF-8')
        } catch {}
      try {
        r.setRequestHeader('Accept', '*/*')
      } catch {}
      ;(t = this.opts.cookieJar) === null || t === void 0 || t.addCookies(r),
        'withCredentials' in r && (r.withCredentials = this.opts.withCredentials),
        this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout),
        (r.onreadystatechange = () => {
          var i
          r.readyState === 3 &&
            ((i = this.opts.cookieJar) === null || i === void 0 || i.parseCookies(r)),
            r.readyState === 4 &&
              (r.status === 200 || r.status === 1223
                ? this.onLoad()
                : this.setTimeoutFn(() => {
                    this.onError(typeof r.status == 'number' ? r.status : 0)
                  }, 0))
        }),
        r.send(this.data)
    } catch (i) {
      this.setTimeoutFn(() => {
        this.onError(i)
      }, 0)
      return
    }
    typeof document < 'u' && ((this.index = op.requestsCount++), (op.requests[this.index] = this))
  }
  onError(t) {
    this.emitReserved('error', t, this.xhr), this.cleanup(!0)
  }
  cleanup(t) {
    if (!(typeof this.xhr > 'u' || this.xhr === null)) {
      if (((this.xhr.onreadystatechange = DY), t))
        try {
          this.xhr.abort()
        } catch {}
      typeof document < 'u' && delete op.requests[this.index], (this.xhr = null)
    }
  }
  onLoad() {
    const t = this.xhr.responseText
    t !== null && (this.emitReserved('data', t), this.emitReserved('success'), this.cleanup())
  }
  abort() {
    this.cleanup()
  }
}
Yl.requestsCount = 0
Yl.requests = {}
if (typeof document < 'u') {
  if (typeof attachEvent == 'function') attachEvent('onunload', oC)
  else if (typeof addEventListener == 'function') {
    const e = 'onpagehide' in Qr ? 'pagehide' : 'unload'
    addEventListener(e, oC, !1)
  }
}
function oC() {
  for (let e in Yl.requests) Yl.requests.hasOwnProperty(e) && Yl.requests[e].abort()
}
const Fb = (() =>
    typeof Promise == 'function' && typeof Promise.resolve == 'function'
      ? (t) => Promise.resolve().then(t)
      : (t, n) => n(t, 0))(),
  ih = Qr.WebSocket || Qr.MozWebSocket,
  aC = !0,
  jY = 'arraybuffer',
  lC =
    typeof navigator < 'u' &&
    typeof navigator.product == 'string' &&
    navigator.product.toLowerCase() === 'reactnative'
class LY extends $b {
  constructor(t) {
    super(t), (this.supportsBinary = !t.forceBase64)
  }
  get name() {
    return 'websocket'
  }
  doOpen() {
    if (!this.check()) return
    const t = this.uri(),
      n = this.opts.protocols,
      r = lC
        ? {}
        : XT(
            this.opts,
            'agent',
            'perMessageDeflate',
            'pfx',
            'key',
            'passphrase',
            'cert',
            'ca',
            'ciphers',
            'rejectUnauthorized',
            'localAddress',
            'protocolVersion',
            'origin',
            'maxPayload',
            'family',
            'checkServerIdentity'
          )
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders)
    try {
      this.ws = aC && !lC ? (n ? new ih(t, n) : new ih(t)) : new ih(t, n, r)
    } catch (i) {
      return this.emitReserved('error', i)
    }
    ;(this.ws.binaryType = this.socket.binaryType), this.addEventListeners()
  }
  addEventListeners() {
    ;(this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen()
    }),
      (this.ws.onclose = (t) =>
        this.onClose({ description: 'websocket connection closed', context: t })),
      (this.ws.onmessage = (t) => this.onData(t.data)),
      (this.ws.onerror = (t) => this.onError('websocket error', t))
  }
  write(t) {
    this.writable = !1
    for (let n = 0; n < t.length; n++) {
      const r = t[n],
        i = n === t.length - 1
      jb(r, this.supportsBinary, (s) => {
        const o = {}
        try {
          aC && this.ws.send(s)
        } catch {}
        i &&
          Fb(() => {
            ;(this.writable = !0), this.emitReserved('drain')
          }, this.setTimeoutFn)
      })
    }
  }
  doClose() {
    typeof this.ws < 'u' && (this.ws.close(), (this.ws = null))
  }
  uri() {
    const t = this.opts.secure ? 'wss' : 'ws',
      n = this.query || {}
    return (
      this.opts.timestampRequests && (n[this.opts.timestampParam] = JT()),
      this.supportsBinary || (n.b64 = 1),
      this.createUri(t, n)
    )
  }
  check() {
    return !!ih
  }
}
class $Y extends $b {
  get name() {
    return 'webtransport'
  }
  doOpen() {
    typeof WebTransport == 'function' &&
      ((this.transport = new WebTransport(
        this.createUri('https'),
        this.opts.transportOptions[this.name]
      )),
      this.transport.closed
        .then(() => {
          this.onClose()
        })
        .catch((t) => {
          this.onError('webtransport error', t)
        }),
      this.transport.ready.then(() => {
        this.transport.createBidirectionalStream().then((t) => {
          const n = xY(Number.MAX_SAFE_INTEGER, this.socket.binaryType),
            r = t.readable.pipeThrough(n).getReader(),
            i = bY()
          i.readable.pipeTo(t.writable), (this.writer = i.writable.getWriter())
          const s = () => {
            r.read()
              .then(({ done: a, value: l }) => {
                a || (this.onPacket(l), s())
              })
              .catch((a) => {})
          }
          s()
          const o = { type: 'open' }
          this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`),
            this.writer.write(o).then(() => this.onOpen())
        })
      }))
  }
  write(t) {
    this.writable = !1
    for (let n = 0; n < t.length; n++) {
      const r = t[n],
        i = n === t.length - 1
      this.writer.write(r).then(() => {
        i &&
          Fb(() => {
            ;(this.writable = !0), this.emitReserved('drain')
          }, this.setTimeoutFn)
      })
    }
  }
  doClose() {
    var t
    ;(t = this.transport) === null || t === void 0 || t.close()
  }
}
const FY = { websocket: LY, webtransport: $Y, polling: MY },
  BY =
    /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
  UY = [
    'source',
    'protocol',
    'authority',
    'userInfo',
    'user',
    'password',
    'host',
    'port',
    'relative',
    'path',
    'directory',
    'file',
    'query',
    'anchor',
  ]
function d1(e) {
  if (e.length > 2e3) throw 'URI too long'
  const t = e,
    n = e.indexOf('['),
    r = e.indexOf(']')
  n != -1 &&
    r != -1 &&
    (e = e.substring(0, n) + e.substring(n, r).replace(/:/g, ';') + e.substring(r, e.length))
  let i = BY.exec(e || ''),
    s = {},
    o = 14
  for (; o--; ) s[UY[o]] = i[o] || ''
  return (
    n != -1 &&
      r != -1 &&
      ((s.source = t),
      (s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ':')),
      (s.authority = s.authority.replace('[', '').replace(']', '').replace(/;/g, ':')),
      (s.ipv6uri = !0)),
    (s.pathNames = zY(s, s.path)),
    (s.queryKey = WY(s, s.query)),
    s
  )
}
function zY(e, t) {
  const n = /\/{2,9}/g,
    r = t.replace(n, '/').split('/')
  return (
    (t.slice(0, 1) == '/' || t.length === 0) && r.splice(0, 1),
    t.slice(-1) == '/' && r.splice(r.length - 1, 1),
    r
  )
}
function WY(e, t) {
  const n = {}
  return (
    t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (r, i, s) {
      i && (n[i] = s)
    }),
    n
  )
}
let n4 = class pl extends sn {
  constructor(t, n = {}) {
    super(),
      (this.binaryType = jY),
      (this.writeBuffer = []),
      t && typeof t == 'object' && ((n = t), (t = null)),
      t
        ? ((t = d1(t)),
          (n.hostname = t.host),
          (n.secure = t.protocol === 'https' || t.protocol === 'wss'),
          (n.port = t.port),
          t.query && (n.query = t.query))
        : n.host && (n.hostname = d1(n.host).host),
      bg(this, n),
      (this.secure =
        n.secure != null ? n.secure : typeof location < 'u' && location.protocol === 'https:'),
      n.hostname && !n.port && (n.port = this.secure ? '443' : '80'),
      (this.hostname = n.hostname || (typeof location < 'u' ? location.hostname : 'localhost')),
      (this.port =
        n.port ||
        (typeof location < 'u' && location.port ? location.port : this.secure ? '443' : '80')),
      (this.transports = n.transports || ['polling', 'websocket', 'webtransport']),
      (this.writeBuffer = []),
      (this.prevBufferLen = 0),
      (this.opts = Object.assign(
        {
          path: '/engine.io',
          agent: !1,
          withCredentials: !1,
          upgrade: !0,
          timestampParam: 't',
          rememberUpgrade: !1,
          addTrailingSlash: !0,
          rejectUnauthorized: !0,
          perMessageDeflate: { threshold: 1024 },
          transportOptions: {},
          closeOnBeforeunload: !1,
        },
        n
      )),
      (this.opts.path =
        this.opts.path.replace(/\/$/, '') + (this.opts.addTrailingSlash ? '/' : '')),
      typeof this.opts.query == 'string' && (this.opts.query = AY(this.opts.query)),
      (this.id = null),
      (this.upgrades = null),
      (this.pingInterval = null),
      (this.pingTimeout = null),
      (this.pingTimeoutTimer = null),
      typeof addEventListener == 'function' &&
        (this.opts.closeOnBeforeunload &&
          ((this.beforeunloadEventListener = () => {
            this.transport && (this.transport.removeAllListeners(), this.transport.close())
          }),
          addEventListener('beforeunload', this.beforeunloadEventListener, !1)),
        this.hostname !== 'localhost' &&
          ((this.offlineEventListener = () => {
            this.onClose('transport close', { description: 'network connection lost' })
          }),
          addEventListener('offline', this.offlineEventListener, !1))),
      this.open()
  }
  createTransport(t) {
    const n = Object.assign({}, this.opts.query)
    ;(n.EIO = QT), (n.transport = t), this.id && (n.sid = this.id)
    const r = Object.assign(
      {},
      this.opts,
      { query: n, socket: this, hostname: this.hostname, secure: this.secure, port: this.port },
      this.opts.transportOptions[t]
    )
    return new FY[t](r)
  }
  open() {
    let t
    if (
      this.opts.rememberUpgrade &&
      pl.priorWebsocketSuccess &&
      this.transports.indexOf('websocket') !== -1
    )
      t = 'websocket'
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved('error', 'No transports available')
      }, 0)
      return
    } else t = this.transports[0]
    this.readyState = 'opening'
    try {
      t = this.createTransport(t)
    } catch {
      this.transports.shift(), this.open()
      return
    }
    t.open(), this.setTransport(t)
  }
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(),
      (this.transport = t),
      t
        .on('drain', this.onDrain.bind(this))
        .on('packet', this.onPacket.bind(this))
        .on('error', this.onError.bind(this))
        .on('close', (n) => this.onClose('transport close', n))
  }
  probe(t) {
    let n = this.createTransport(t),
      r = !1
    pl.priorWebsocketSuccess = !1
    const i = () => {
      r ||
        (n.send([{ type: 'ping', data: 'probe' }]),
        n.once('packet', (f) => {
          if (!r)
            if (f.type === 'pong' && f.data === 'probe') {
              if (((this.upgrading = !0), this.emitReserved('upgrading', n), !n)) return
              ;(pl.priorWebsocketSuccess = n.name === 'websocket'),
                this.transport.pause(() => {
                  r ||
                    (this.readyState !== 'closed' &&
                      (u(),
                      this.setTransport(n),
                      n.send([{ type: 'upgrade' }]),
                      this.emitReserved('upgrade', n),
                      (n = null),
                      (this.upgrading = !1),
                      this.flush()))
                })
            } else {
              const d = new Error('probe error')
              ;(d.transport = n.name), this.emitReserved('upgradeError', d)
            }
        }))
    }
    function s() {
      r || ((r = !0), u(), n.close(), (n = null))
    }
    const o = (f) => {
      const d = new Error('probe error: ' + f)
      ;(d.transport = n.name), s(), this.emitReserved('upgradeError', d)
    }
    function a() {
      o('transport closed')
    }
    function l() {
      o('socket closed')
    }
    function c(f) {
      n && f.name !== n.name && s()
    }
    const u = () => {
      n.removeListener('open', i),
        n.removeListener('error', o),
        n.removeListener('close', a),
        this.off('close', l),
        this.off('upgrading', c)
    }
    n.once('open', i),
      n.once('error', o),
      n.once('close', a),
      this.once('close', l),
      this.once('upgrading', c),
      this.upgrades.indexOf('webtransport') !== -1 && t !== 'webtransport'
        ? this.setTimeoutFn(() => {
            r || n.open()
          }, 200)
        : n.open()
  }
  onOpen() {
    if (
      ((this.readyState = 'open'),
      (pl.priorWebsocketSuccess = this.transport.name === 'websocket'),
      this.emitReserved('open'),
      this.flush(),
      this.readyState === 'open' && this.opts.upgrade)
    ) {
      let t = 0
      const n = this.upgrades.length
      for (; t < n; t++) this.probe(this.upgrades[t])
    }
  }
  onPacket(t) {
    if (
      this.readyState === 'opening' ||
      this.readyState === 'open' ||
      this.readyState === 'closing'
    )
      switch (
        (this.emitReserved('packet', t),
        this.emitReserved('heartbeat'),
        this.resetPingTimeout(),
        t.type)
      ) {
        case 'open':
          this.onHandshake(JSON.parse(t.data))
          break
        case 'ping':
          this.sendPacket('pong'), this.emitReserved('ping'), this.emitReserved('pong')
          break
        case 'error':
          const n = new Error('server error')
          ;(n.code = t.data), this.onError(n)
          break
        case 'message':
          this.emitReserved('data', t.data), this.emitReserved('message', t.data)
          break
      }
  }
  onHandshake(t) {
    this.emitReserved('handshake', t),
      (this.id = t.sid),
      (this.transport.query.sid = t.sid),
      (this.upgrades = this.filterUpgrades(t.upgrades)),
      (this.pingInterval = t.pingInterval),
      (this.pingTimeout = t.pingTimeout),
      (this.maxPayload = t.maxPayload),
      this.onOpen(),
      this.readyState !== 'closed' && this.resetPingTimeout()
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer),
      (this.pingTimeoutTimer = this.setTimeoutFn(() => {
        this.onClose('ping timeout')
      }, this.pingInterval + this.pingTimeout)),
      this.opts.autoUnref && this.pingTimeoutTimer.unref()
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen),
      (this.prevBufferLen = 0),
      this.writeBuffer.length === 0 ? this.emitReserved('drain') : this.flush()
  }
  flush() {
    if (
      this.readyState !== 'closed' &&
      this.transport.writable &&
      !this.upgrading &&
      this.writeBuffer.length
    ) {
      const t = this.getWritablePackets()
      this.transport.send(t), (this.prevBufferLen = t.length), this.emitReserved('flush')
    }
  }
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === 'polling' && this.writeBuffer.length > 1))
      return this.writeBuffer
    let n = 1
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const i = this.writeBuffer[r].data
      if ((i && (n += OY(i)), r > 0 && n > this.maxPayload)) return this.writeBuffer.slice(0, r)
      n += 2
    }
    return this.writeBuffer
  }
  write(t, n, r) {
    return this.sendPacket('message', t, n, r), this
  }
  send(t, n, r) {
    return this.sendPacket('message', t, n, r), this
  }
  sendPacket(t, n, r, i) {
    if (
      (typeof n == 'function' && ((i = n), (n = void 0)),
      typeof r == 'function' && ((i = r), (r = null)),
      this.readyState === 'closing' || this.readyState === 'closed')
    )
      return
    ;(r = r || {}), (r.compress = r.compress !== !1)
    const s = { type: t, data: n, options: r }
    this.emitReserved('packetCreate', s),
      this.writeBuffer.push(s),
      i && this.once('flush', i),
      this.flush()
  }
  close() {
    const t = () => {
        this.onClose('forced close'), this.transport.close()
      },
      n = () => {
        this.off('upgrade', n), this.off('upgradeError', n), t()
      },
      r = () => {
        this.once('upgrade', n), this.once('upgradeError', n)
      }
    return (
      (this.readyState === 'opening' || this.readyState === 'open') &&
        ((this.readyState = 'closing'),
        this.writeBuffer.length
          ? this.once('drain', () => {
              this.upgrading ? r() : t()
            })
          : this.upgrading
          ? r()
          : t()),
      this
    )
  }
  onError(t) {
    ;(pl.priorWebsocketSuccess = !1),
      this.emitReserved('error', t),
      this.onClose('transport error', t)
  }
  onClose(t, n) {
    ;(this.readyState === 'opening' ||
      this.readyState === 'open' ||
      this.readyState === 'closing') &&
      (this.clearTimeoutFn(this.pingTimeoutTimer),
      this.transport.removeAllListeners('close'),
      this.transport.close(),
      this.transport.removeAllListeners(),
      typeof removeEventListener == 'function' &&
        (removeEventListener('beforeunload', this.beforeunloadEventListener, !1),
        removeEventListener('offline', this.offlineEventListener, !1)),
      (this.readyState = 'closed'),
      (this.id = null),
      this.emitReserved('close', t, n),
      (this.writeBuffer = []),
      (this.prevBufferLen = 0))
  }
  filterUpgrades(t) {
    const n = []
    let r = 0
    const i = t.length
    for (; r < i; r++) ~this.transports.indexOf(t[r]) && n.push(t[r])
    return n
  }
}
n4.protocol = QT
function VY(e, t = '', n) {
  let r = e
  ;(n = n || (typeof location < 'u' && location)),
    e == null && (e = n.protocol + '//' + n.host),
    typeof e == 'string' &&
      (e.charAt(0) === '/' && (e.charAt(1) === '/' ? (e = n.protocol + e) : (e = n.host + e)),
      /^(https?|wss?):\/\//.test(e) ||
        (typeof n < 'u' ? (e = n.protocol + '//' + e) : (e = 'https://' + e)),
      (r = d1(e))),
    r.port ||
      (/^(http|ws)$/.test(r.protocol)
        ? (r.port = '80')
        : /^(http|ws)s$/.test(r.protocol) && (r.port = '443')),
    (r.path = r.path || '/')
  const s = r.host.indexOf(':') !== -1 ? '[' + r.host + ']' : r.host
  return (
    (r.id = r.protocol + '://' + s + ':' + r.port + t),
    (r.href = r.protocol + '://' + s + (n && n.port === r.port ? '' : ':' + r.port)),
    r
  )
}
const HY = typeof ArrayBuffer == 'function',
  qY = (e) =>
    typeof ArrayBuffer.isView == 'function'
      ? ArrayBuffer.isView(e)
      : e.buffer instanceof ArrayBuffer,
  r4 = Object.prototype.toString,
  KY =
    typeof Blob == 'function' ||
    (typeof Blob < 'u' && r4.call(Blob) === '[object BlobConstructor]'),
  GY =
    typeof File == 'function' || (typeof File < 'u' && r4.call(File) === '[object FileConstructor]')
function Bb(e) {
  return (
    (HY && (e instanceof ArrayBuffer || qY(e))) ||
    (KY && e instanceof Blob) ||
    (GY && e instanceof File)
  )
}
function ap(e, t) {
  if (!e || typeof e != 'object') return !1
  if (Array.isArray(e)) {
    for (let n = 0, r = e.length; n < r; n++) if (ap(e[n])) return !0
    return !1
  }
  if (Bb(e)) return !0
  if (e.toJSON && typeof e.toJSON == 'function' && arguments.length === 1) return ap(e.toJSON(), !0)
  for (const n in e) if (Object.prototype.hasOwnProperty.call(e, n) && ap(e[n])) return !0
  return !1
}
function YY(e) {
  const t = [],
    n = e.data,
    r = e
  return (r.data = h1(n, t)), (r.attachments = t.length), { packet: r, buffers: t }
}
function h1(e, t) {
  if (!e) return e
  if (Bb(e)) {
    const n = { _placeholder: !0, num: t.length }
    return t.push(e), n
  } else if (Array.isArray(e)) {
    const n = new Array(e.length)
    for (let r = 0; r < e.length; r++) n[r] = h1(e[r], t)
    return n
  } else if (typeof e == 'object' && !(e instanceof Date)) {
    const n = {}
    for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (n[r] = h1(e[r], t))
    return n
  }
  return e
}
function QY(e, t) {
  return (e.data = p1(e.data, t)), delete e.attachments, e
}
function p1(e, t) {
  if (!e) return e
  if (e && e._placeholder === !0) {
    if (typeof e.num == 'number' && e.num >= 0 && e.num < t.length) return t[e.num]
    throw new Error('illegal attachments')
  } else if (Array.isArray(e)) for (let n = 0; n < e.length; n++) e[n] = p1(e[n], t)
  else if (typeof e == 'object')
    for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (e[n] = p1(e[n], t))
  return e
}
const XY = [
    'connect',
    'connect_error',
    'disconnect',
    'disconnecting',
    'newListener',
    'removeListener',
  ],
  ZY = 5
var ut
;(function (e) {
  ;(e[(e.CONNECT = 0)] = 'CONNECT'),
    (e[(e.DISCONNECT = 1)] = 'DISCONNECT'),
    (e[(e.EVENT = 2)] = 'EVENT'),
    (e[(e.ACK = 3)] = 'ACK'),
    (e[(e.CONNECT_ERROR = 4)] = 'CONNECT_ERROR'),
    (e[(e.BINARY_EVENT = 5)] = 'BINARY_EVENT'),
    (e[(e.BINARY_ACK = 6)] = 'BINARY_ACK')
})(ut || (ut = {}))
class JY {
  constructor(t) {
    this.replacer = t
  }
  encode(t) {
    return (t.type === ut.EVENT || t.type === ut.ACK) && ap(t)
      ? this.encodeAsBinary({
          type: t.type === ut.EVENT ? ut.BINARY_EVENT : ut.BINARY_ACK,
          nsp: t.nsp,
          data: t.data,
          id: t.id,
        })
      : [this.encodeAsString(t)]
  }
  encodeAsString(t) {
    let n = '' + t.type
    return (
      (t.type === ut.BINARY_EVENT || t.type === ut.BINARY_ACK) && (n += t.attachments + '-'),
      t.nsp && t.nsp !== '/' && (n += t.nsp + ','),
      t.id != null && (n += t.id),
      t.data != null && (n += JSON.stringify(t.data, this.replacer)),
      n
    )
  }
  encodeAsBinary(t) {
    const n = YY(t),
      r = this.encodeAsString(n.packet),
      i = n.buffers
    return i.unshift(r), i
  }
}
function cC(e) {
  return Object.prototype.toString.call(e) === '[object Object]'
}
class Ub extends sn {
  constructor(t) {
    super(), (this.reviver = t)
  }
  add(t) {
    let n
    if (typeof t == 'string') {
      if (this.reconstructor) throw new Error('got plaintext data when reconstructing a packet')
      n = this.decodeString(t)
      const r = n.type === ut.BINARY_EVENT
      r || n.type === ut.BINARY_ACK
        ? ((n.type = r ? ut.EVENT : ut.ACK),
          (this.reconstructor = new eQ(n)),
          n.attachments === 0 && super.emitReserved('decoded', n))
        : super.emitReserved('decoded', n)
    } else if (Bb(t) || t.base64)
      if (this.reconstructor)
        (n = this.reconstructor.takeBinaryData(t)),
          n && ((this.reconstructor = null), super.emitReserved('decoded', n))
      else throw new Error('got binary data when not reconstructing a packet')
    else throw new Error('Unknown type: ' + t)
  }
  decodeString(t) {
    let n = 0
    const r = { type: Number(t.charAt(0)) }
    if (ut[r.type] === void 0) throw new Error('unknown packet type ' + r.type)
    if (r.type === ut.BINARY_EVENT || r.type === ut.BINARY_ACK) {
      const s = n + 1
      for (; t.charAt(++n) !== '-' && n != t.length; );
      const o = t.substring(s, n)
      if (o != Number(o) || t.charAt(n) !== '-') throw new Error('Illegal attachments')
      r.attachments = Number(o)
    }
    if (t.charAt(n + 1) === '/') {
      const s = n + 1
      for (; ++n && !(t.charAt(n) === ',' || n === t.length); );
      r.nsp = t.substring(s, n)
    } else r.nsp = '/'
    const i = t.charAt(n + 1)
    if (i !== '' && Number(i) == i) {
      const s = n + 1
      for (; ++n; ) {
        const o = t.charAt(n)
        if (o == null || Number(o) != o) {
          --n
          break
        }
        if (n === t.length) break
      }
      r.id = Number(t.substring(s, n + 1))
    }
    if (t.charAt(++n)) {
      const s = this.tryParse(t.substr(n))
      if (Ub.isPayloadValid(r.type, s)) r.data = s
      else throw new Error('invalid payload')
    }
    return r
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver)
    } catch {
      return !1
    }
  }
  static isPayloadValid(t, n) {
    switch (t) {
      case ut.CONNECT:
        return cC(n)
      case ut.DISCONNECT:
        return n === void 0
      case ut.CONNECT_ERROR:
        return typeof n == 'string' || cC(n)
      case ut.EVENT:
      case ut.BINARY_EVENT:
        return (
          Array.isArray(n) &&
          (typeof n[0] == 'number' || (typeof n[0] == 'string' && XY.indexOf(n[0]) === -1))
        )
      case ut.ACK:
      case ut.BINARY_ACK:
        return Array.isArray(n)
    }
  }
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), (this.reconstructor = null))
  }
}
class eQ {
  constructor(t) {
    ;(this.packet = t), (this.buffers = []), (this.reconPack = t)
  }
  takeBinaryData(t) {
    if ((this.buffers.push(t), this.buffers.length === this.reconPack.attachments)) {
      const n = QY(this.reconPack, this.buffers)
      return this.finishedReconstruction(), n
    }
    return null
  }
  finishedReconstruction() {
    ;(this.reconPack = null), (this.buffers = [])
  }
}
const tQ = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      Decoder: Ub,
      Encoder: JY,
      get PacketType() {
        return ut
      },
      protocol: ZY,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function wi(e, t, n) {
  return (
    e.on(t, n),
    function () {
      e.off(t, n)
    }
  )
}
const nQ = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1,
})
class i4 extends sn {
  constructor(t, n, r) {
    super(),
      (this.connected = !1),
      (this.recovered = !1),
      (this.receiveBuffer = []),
      (this.sendBuffer = []),
      (this._queue = []),
      (this._queueSeq = 0),
      (this.ids = 0),
      (this.acks = {}),
      (this.flags = {}),
      (this.io = t),
      (this.nsp = n),
      r && r.auth && (this.auth = r.auth),
      (this._opts = Object.assign({}, r)),
      this.io._autoConnect && this.open()
  }
  get disconnected() {
    return !this.connected
  }
  subEvents() {
    if (this.subs) return
    const t = this.io
    this.subs = [
      wi(t, 'open', this.onopen.bind(this)),
      wi(t, 'packet', this.onpacket.bind(this)),
      wi(t, 'error', this.onerror.bind(this)),
      wi(t, 'close', this.onclose.bind(this)),
    ]
  }
  get active() {
    return !!this.subs
  }
  connect() {
    return this.connected
      ? this
      : (this.subEvents(),
        this.io._reconnecting || this.io.open(),
        this.io._readyState === 'open' && this.onopen(),
        this)
  }
  open() {
    return this.connect()
  }
  send(...t) {
    return t.unshift('message'), this.emit.apply(this, t), this
  }
  emit(t, ...n) {
    if (nQ.hasOwnProperty(t)) throw new Error('"' + t.toString() + '" is a reserved event name')
    if ((n.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile))
      return this._addToQueue(n), this
    const r = { type: ut.EVENT, data: n }
    if (
      ((r.options = {}),
      (r.options.compress = this.flags.compress !== !1),
      typeof n[n.length - 1] == 'function')
    ) {
      const o = this.ids++,
        a = n.pop()
      this._registerAckCallback(o, a), (r.id = o)
    }
    const i = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable
    return (
      (this.flags.volatile && (!i || !this.connected)) ||
        (this.connected
          ? (this.notifyOutgoingListeners(r), this.packet(r))
          : this.sendBuffer.push(r)),
      (this.flags = {}),
      this
    )
  }
  _registerAckCallback(t, n) {
    var r
    const i = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout
    if (i === void 0) {
      this.acks[t] = n
      return
    }
    const s = this.io.setTimeoutFn(() => {
        delete this.acks[t]
        for (let a = 0; a < this.sendBuffer.length; a++)
          this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1)
        n.call(this, new Error('operation has timed out'))
      }, i),
      o = (...a) => {
        this.io.clearTimeoutFn(s), n.apply(this, a)
      }
    ;(o.withError = !0), (this.acks[t] = o)
  }
  emitWithAck(t, ...n) {
    return new Promise((r, i) => {
      const s = (o, a) => (o ? i(o) : r(a))
      ;(s.withError = !0), n.push(s), this.emit(t, ...n)
    })
  }
  _addToQueue(t) {
    let n
    typeof t[t.length - 1] == 'function' && (n = t.pop())
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags),
    }
    t.push((i, ...s) =>
      r !== this._queue[0]
        ? void 0
        : (i !== null
            ? r.tryCount > this._opts.retries && (this._queue.shift(), n && n(i))
            : (this._queue.shift(), n && n(null, ...s)),
          (r.pending = !1),
          this._drainQueue())
    ),
      this._queue.push(r),
      this._drainQueue()
  }
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0) return
    const n = this._queue[0]
    ;(n.pending && !t) ||
      ((n.pending = !0), n.tryCount++, (this.flags = n.flags), this.emit.apply(this, n.args))
  }
  packet(t) {
    ;(t.nsp = this.nsp), this.io._packet(t)
  }
  onopen() {
    typeof this.auth == 'function'
      ? this.auth((t) => {
          this._sendConnectPacket(t)
        })
      : this._sendConnectPacket(this.auth)
  }
  _sendConnectPacket(t) {
    this.packet({
      type: ut.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t,
    })
  }
  onerror(t) {
    this.connected || this.emitReserved('connect_error', t)
  }
  onclose(t, n) {
    ;(this.connected = !1), delete this.id, this.emitReserved('disconnect', t, n), this._clearAcks()
  }
  _clearAcks() {
    Object.keys(this.acks).forEach((t) => {
      if (!this.sendBuffer.some((r) => String(r.id) === t)) {
        const r = this.acks[t]
        delete this.acks[t], r.withError && r.call(this, new Error('socket has been disconnected'))
      }
    })
  }
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case ut.CONNECT:
          t.data && t.data.sid
            ? this.onconnect(t.data.sid, t.data.pid)
            : this.emitReserved(
                'connect_error',
                new Error(
                  'It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)'
                )
              )
          break
        case ut.EVENT:
        case ut.BINARY_EVENT:
          this.onevent(t)
          break
        case ut.ACK:
        case ut.BINARY_ACK:
          this.onack(t)
          break
        case ut.DISCONNECT:
          this.ondisconnect()
          break
        case ut.CONNECT_ERROR:
          this.destroy()
          const r = new Error(t.data.message)
          ;(r.data = t.data.data), this.emitReserved('connect_error', r)
          break
      }
  }
  onevent(t) {
    const n = t.data || []
    t.id != null && n.push(this.ack(t.id)),
      this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n))
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const n = this._anyListeners.slice()
      for (const r of n) r.apply(this, t)
    }
    super.emit.apply(this, t),
      this._pid &&
        t.length &&
        typeof t[t.length - 1] == 'string' &&
        (this._lastOffset = t[t.length - 1])
  }
  ack(t) {
    const n = this
    let r = !1
    return function (...i) {
      r || ((r = !0), n.packet({ type: ut.ACK, id: t, data: i }))
    }
  }
  onack(t) {
    const n = this.acks[t.id]
    typeof n == 'function' &&
      (delete this.acks[t.id], n.withError && t.data.unshift(null), n.apply(this, t.data))
  }
  onconnect(t, n) {
    ;(this.id = t),
      (this.recovered = n && this._pid === n),
      (this._pid = n),
      (this.connected = !0),
      this.emitBuffered(),
      this.emitReserved('connect'),
      this._drainQueue(!0)
  }
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)),
      (this.receiveBuffer = []),
      this.sendBuffer.forEach((t) => {
        this.notifyOutgoingListeners(t), this.packet(t)
      }),
      (this.sendBuffer = [])
  }
  ondisconnect() {
    this.destroy(), this.onclose('io server disconnect')
  }
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), (this.subs = void 0)), this.io._destroy(this)
  }
  disconnect() {
    return (
      this.connected && this.packet({ type: ut.DISCONNECT }),
      this.destroy(),
      this.connected && this.onclose('io client disconnect'),
      this
    )
  }
  close() {
    return this.disconnect()
  }
  compress(t) {
    return (this.flags.compress = t), this
  }
  get volatile() {
    return (this.flags.volatile = !0), this
  }
  timeout(t) {
    return (this.flags.timeout = t), this
  }
  onAny(t) {
    return (this._anyListeners = this._anyListeners || []), this._anyListeners.push(t), this
  }
  prependAny(t) {
    return (this._anyListeners = this._anyListeners || []), this._anyListeners.unshift(t), this
  }
  offAny(t) {
    if (!this._anyListeners) return this
    if (t) {
      const n = this._anyListeners
      for (let r = 0; r < n.length; r++) if (t === n[r]) return n.splice(r, 1), this
    } else this._anyListeners = []
    return this
  }
  listenersAny() {
    return this._anyListeners || []
  }
  onAnyOutgoing(t) {
    return (
      (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
      this._anyOutgoingListeners.push(t),
      this
    )
  }
  prependAnyOutgoing(t) {
    return (
      (this._anyOutgoingListeners = this._anyOutgoingListeners || []),
      this._anyOutgoingListeners.unshift(t),
      this
    )
  }
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners) return this
    if (t) {
      const n = this._anyOutgoingListeners
      for (let r = 0; r < n.length; r++) if (t === n[r]) return n.splice(r, 1), this
    } else this._anyOutgoingListeners = []
    return this
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || []
  }
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const n = this._anyOutgoingListeners.slice()
      for (const r of n) r.apply(this, t.data)
    }
  }
}
function Yc(e) {
  ;(e = e || {}),
    (this.ms = e.min || 100),
    (this.max = e.max || 1e4),
    (this.factor = e.factor || 2),
    (this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0),
    (this.attempts = 0)
}
Yc.prototype.duration = function () {
  var e = this.ms * Math.pow(this.factor, this.attempts++)
  if (this.jitter) {
    var t = Math.random(),
      n = Math.floor(t * this.jitter * e)
    e = Math.floor(t * 10) & 1 ? e + n : e - n
  }
  return Math.min(e, this.max) | 0
}
Yc.prototype.reset = function () {
  this.attempts = 0
}
Yc.prototype.setMin = function (e) {
  this.ms = e
}
Yc.prototype.setMax = function (e) {
  this.max = e
}
Yc.prototype.setJitter = function (e) {
  this.jitter = e
}
class g1 extends sn {
  constructor(t, n) {
    var r
    super(),
      (this.nsps = {}),
      (this.subs = []),
      t && typeof t == 'object' && ((n = t), (t = void 0)),
      (n = n || {}),
      (n.path = n.path || '/socket.io'),
      (this.opts = n),
      bg(this, n),
      this.reconnection(n.reconnection !== !1),
      this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
      this.reconnectionDelay(n.reconnectionDelay || 1e3),
      this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
      this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : 0.5),
      (this.backoff = new Yc({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor(),
      })),
      this.timeout(n.timeout == null ? 2e4 : n.timeout),
      (this._readyState = 'closed'),
      (this.uri = t)
    const i = n.parser || tQ
    ;(this.encoder = new i.Encoder()),
      (this.decoder = new i.Decoder()),
      (this._autoConnect = n.autoConnect !== !1),
      this._autoConnect && this.open()
  }
  reconnection(t) {
    return arguments.length ? ((this._reconnection = !!t), this) : this._reconnection
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : ((this._reconnectionAttempts = t), this)
  }
  reconnectionDelay(t) {
    var n
    return t === void 0
      ? this._reconnectionDelay
      : ((this._reconnectionDelay = t),
        (n = this.backoff) === null || n === void 0 || n.setMin(t),
        this)
  }
  randomizationFactor(t) {
    var n
    return t === void 0
      ? this._randomizationFactor
      : ((this._randomizationFactor = t),
        (n = this.backoff) === null || n === void 0 || n.setJitter(t),
        this)
  }
  reconnectionDelayMax(t) {
    var n
    return t === void 0
      ? this._reconnectionDelayMax
      : ((this._reconnectionDelayMax = t),
        (n = this.backoff) === null || n === void 0 || n.setMax(t),
        this)
  }
  timeout(t) {
    return arguments.length ? ((this._timeout = t), this) : this._timeout
  }
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
  }
  open(t) {
    if (~this._readyState.indexOf('open')) return this
    this.engine = new n4(this.uri, this.opts)
    const n = this.engine,
      r = this
    ;(this._readyState = 'opening'), (this.skipReconnect = !1)
    const i = wi(n, 'open', function () {
        r.onopen(), t && t()
      }),
      s = (a) => {
        this.cleanup(),
          (this._readyState = 'closed'),
          this.emitReserved('error', a),
          t ? t(a) : this.maybeReconnectOnOpen()
      },
      o = wi(n, 'error', s)
    if (this._timeout !== !1) {
      const a = this._timeout,
        l = this.setTimeoutFn(() => {
          i(), s(new Error('timeout')), n.close()
        }, a)
      this.opts.autoUnref && l.unref(),
        this.subs.push(() => {
          this.clearTimeoutFn(l)
        })
    }
    return this.subs.push(i), this.subs.push(o), this
  }
  connect(t) {
    return this.open(t)
  }
  onopen() {
    this.cleanup(), (this._readyState = 'open'), this.emitReserved('open')
    const t = this.engine
    this.subs.push(
      wi(t, 'ping', this.onping.bind(this)),
      wi(t, 'data', this.ondata.bind(this)),
      wi(t, 'error', this.onerror.bind(this)),
      wi(t, 'close', this.onclose.bind(this)),
      wi(this.decoder, 'decoded', this.ondecoded.bind(this))
    )
  }
  onping() {
    this.emitReserved('ping')
  }
  ondata(t) {
    try {
      this.decoder.add(t)
    } catch (n) {
      this.onclose('parse error', n)
    }
  }
  ondecoded(t) {
    Fb(() => {
      this.emitReserved('packet', t)
    }, this.setTimeoutFn)
  }
  onerror(t) {
    this.emitReserved('error', t)
  }
  socket(t, n) {
    let r = this.nsps[t]
    return (
      r
        ? this._autoConnect && !r.active && r.connect()
        : ((r = new i4(this, t, n)), (this.nsps[t] = r)),
      r
    )
  }
  _destroy(t) {
    const n = Object.keys(this.nsps)
    for (const r of n) if (this.nsps[r].active) return
    this._close()
  }
  _packet(t) {
    const n = this.encoder.encode(t)
    for (let r = 0; r < n.length; r++) this.engine.write(n[r], t.options)
  }
  cleanup() {
    this.subs.forEach((t) => t()), (this.subs.length = 0), this.decoder.destroy()
  }
  _close() {
    ;(this.skipReconnect = !0),
      (this._reconnecting = !1),
      this.onclose('forced close'),
      this.engine && this.engine.close()
  }
  disconnect() {
    return this._close()
  }
  onclose(t, n) {
    this.cleanup(),
      this.backoff.reset(),
      (this._readyState = 'closed'),
      this.emitReserved('close', t, n),
      this._reconnection && !this.skipReconnect && this.reconnect()
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect) return this
    const t = this
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved('reconnect_failed'), (this._reconnecting = !1)
    else {
      const n = this.backoff.duration()
      this._reconnecting = !0
      const r = this.setTimeoutFn(() => {
        t.skipReconnect ||
          (this.emitReserved('reconnect_attempt', t.backoff.attempts),
          !t.skipReconnect &&
            t.open((i) => {
              i
                ? ((t._reconnecting = !1), t.reconnect(), this.emitReserved('reconnect_error', i))
                : t.onreconnect()
            }))
      }, n)
      this.opts.autoUnref && r.unref(),
        this.subs.push(() => {
          this.clearTimeoutFn(r)
        })
    }
  }
  onreconnect() {
    const t = this.backoff.attempts
    ;(this._reconnecting = !1), this.backoff.reset(), this.emitReserved('reconnect', t)
  }
}
const pu = {}
function lp(e, t) {
  typeof e == 'object' && ((t = e), (e = void 0)), (t = t || {})
  const n = VY(e, t.path || '/socket.io'),
    r = n.source,
    i = n.id,
    s = n.path,
    o = pu[i] && s in pu[i].nsps,
    a = t.forceNew || t['force new connection'] || t.multiplex === !1 || o
  let l
  return (
    a ? (l = new g1(r, t)) : (pu[i] || (pu[i] = new g1(r, t)), (l = pu[i])),
    n.query && !t.query && (t.query = n.queryKey),
    l.socket(n.path, t)
  )
}
Object.assign(lp, { Manager: g1, Socket: i4, io: lp, connect: lp })
const uC = localStorage.getItem('token'),
  jn = lp('http://localhost:3001', {
    extraHeaders: { Authorization: uC !== null ? uC : '' },
    autoConnect: !0,
  }),
  rQ = () => {
    const [e, t] = w.useState(!0),
      [n, r] = w.useState(!1),
      i = $0(),
      { removeAll: s } = Rw(),
      o = async () => {
        try {
          if (e)
            jn.emit('createGame', (a) => {
              a.status === 200
                ? (i(`/game/${a.board.game_id}`), r(!1), s())
                : a.status === 202
                ? console.log('Waiting for an opponent...')
                : (console.error('Failed to create game'), r(!1))
            }),
              jn.on('createGame', async function (a) {
                a.status === 200 && (i(`/game/${a.board.game_id}`), r(!1), s())
              })
          else {
            const a = await ed
              .post('/new-game-v2', { params: { isPaymentMatch: !1 } }, { headers: G_ })
              .then((l) => l)
            a.data.status === 200 && (i(`/game/${a.data.board.game_id}`), r(!1), s())
          }
        } catch {
          r(!1)
        }
      }
    return E.jsx(VT, {
      className: 'bg-gray-100 min-w-[500px] max-w-[600px]',
      children: E.jsxs('div', {
        className: 'flex flex-col space-y-4',
        children: [
          E.jsx('h1', {
            className: 'mb-4 text-center font-bold text-[20px]',
            children: 'Start Chess Match',
          }),
          E.jsxs('div', {
            className: 'flex justify-between space-x-2 text-center',
            children: [
              E.jsxs('div', {
                className:
                  'border border-2 border-green-400 bg-green-100 rounded-2xl w-1/2 p-2 cursor-pointer',
                children: [
                  E.jsxs('div', {
                    className:
                      'text-[20px] font-semibold flex space-x-2 justify-center items-center',
                    children: [
                      E.jsx('input', {
                        id: 'link-checkbox',
                        type: 'checkbox',
                        disabled: !0,
                        className:
                          'w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600',
                      }),
                      E.jsx('div', { children: 'Betting Match' }),
                    ],
                  }),
                  E.jsxs('div', {
                    className: 'text-[14px]',
                    children: [
                      'Play and earn from winning',
                      E.jsx('p', { className: 'font-bold', children: '(Soon)' }),
                    ],
                  }),
                ],
              }),
              E.jsxs('div', {
                className:
                  'border border-2 border-blue-400 bg-blue-100 rounded-2xl w-1/2 p-2 cursor-pointer',
                onChange: () => t(!0),
                children: [
                  E.jsxs('div', {
                    className:
                      'text-[20px] font-semibold flex space-x-2 justify-center items-center',
                    children: [
                      E.jsx('input', {
                        id: 'link-checkbox',
                        type: 'checkbox',
                        checked: e,
                        onClick: () => t(!0),
                        className:
                          'w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600',
                      }),
                      E.jsx('div', { children: 'Free Match' }),
                    ],
                  }),
                  E.jsx('div', {
                    className: 'text-[14px]',
                    children: 'Available for Web2 and Web3 can be played together',
                  }),
                ],
              }),
            ],
          }),
          E.jsx('div', {
            className: 'mx-auto',
            children: E.jsx(hY, {
              className:
                'cursor-pointer bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 !rounded-xl font-bold text-white min-w-[200px] leading-[21px]',
              size: 'small',
              loading: n,
              onClick: o,
              children: 'Create Game',
            }),
          }),
        ],
      }),
    })
  }
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */ var m1 = function (
  e,
  t
) {
  return (
    (m1 =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r
        }) ||
      function (n, r) {
        for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i])
      }),
    m1(e, t)
  )
}
function iQ(e, t) {
  m1(e, t)
  function n() {
    this.constructor = e
  }
  e.prototype = t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
}
var sQ = 100,
  oQ = 100,
  fC = 50,
  y1 = 50,
  v1 = 50
function dC(e) {
  var t = e.className,
    n = e.counterClockwise,
    r = e.dashRatio,
    i = e.pathRadius,
    s = e.strokeWidth,
    o = e.style
  return w.createElement('path', {
    className: t,
    style: Object.assign({}, o, lQ({ pathRadius: i, dashRatio: r, counterClockwise: n })),
    d: aQ({ pathRadius: i, counterClockwise: n }),
    strokeWidth: s,
    fillOpacity: 0,
  })
}
function aQ(e) {
  var t = e.pathRadius,
    n = e.counterClockwise,
    r = t,
    i = n ? 1 : 0
  return (
    `
      M ` +
    y1 +
    ',' +
    v1 +
    `
      m 0,-` +
    r +
    `
      a ` +
    r +
    ',' +
    r +
    ' ' +
    i +
    ' 1 1 0,' +
    2 * r +
    `
      a ` +
    r +
    ',' +
    r +
    ' ' +
    i +
    ' 1 1 0,-' +
    2 * r +
    `
    `
  )
}
function lQ(e) {
  var t = e.counterClockwise,
    n = e.dashRatio,
    r = e.pathRadius,
    i = Math.PI * 2 * r,
    s = (1 - n) * i
  return { strokeDasharray: i + 'px ' + i + 'px', strokeDashoffset: (t ? -s : s) + 'px' }
}
var cQ = (function (e) {
  iQ(t, e)
  function t() {
    return (e !== null && e.apply(this, arguments)) || this
  }
  return (
    (t.prototype.getBackgroundPadding = function () {
      return this.props.background ? this.props.backgroundPadding : 0
    }),
    (t.prototype.getPathRadius = function () {
      return fC - this.props.strokeWidth / 2 - this.getBackgroundPadding()
    }),
    (t.prototype.getPathRatio = function () {
      var n = this.props,
        r = n.value,
        i = n.minValue,
        s = n.maxValue,
        o = Math.min(Math.max(r, i), s)
      return (o - i) / (s - i)
    }),
    (t.prototype.render = function () {
      var n = this.props,
        r = n.circleRatio,
        i = n.className,
        s = n.classes,
        o = n.counterClockwise,
        a = n.styles,
        l = n.strokeWidth,
        c = n.text,
        u = this.getPathRadius(),
        f = this.getPathRatio()
      return w.createElement(
        'svg',
        {
          className: s.root + ' ' + i,
          style: a.root,
          viewBox: '0 0 ' + sQ + ' ' + oQ,
          'data-test-id': 'CircularProgressbar',
        },
        this.props.background
          ? w.createElement('circle', {
              className: s.background,
              style: a.background,
              cx: y1,
              cy: v1,
              r: fC,
            })
          : null,
        w.createElement(dC, {
          className: s.trail,
          counterClockwise: o,
          dashRatio: r,
          pathRadius: u,
          strokeWidth: l,
          style: a.trail,
        }),
        w.createElement(dC, {
          className: s.path,
          counterClockwise: o,
          dashRatio: f * r,
          pathRadius: u,
          strokeWidth: l,
          style: a.path,
        }),
        c ? w.createElement('text', { className: s.text, style: a.text, x: y1, y: v1 }, c) : null
      )
    }),
    (t.defaultProps = {
      background: !1,
      backgroundPadding: 0,
      circleRatio: 1,
      classes: {
        root: 'CircularProgressbar',
        trail: 'CircularProgressbar-trail',
        path: 'CircularProgressbar-path',
        text: 'CircularProgressbar-text',
        background: 'CircularProgressbar-background',
      },
      counterClockwise: !1,
      className: '',
      maxValue: 100,
      minValue: 0,
      strokeWidth: 8,
      styles: { root: {}, trail: {}, path: {}, text: {}, background: {} },
      text: '',
    }),
    t
  )
})(w.Component)
function uQ() {
  $0()
  const { addPopup: e } = Rw()
  function t() {
    let s = !1
    return localStorage.getItem('token') ? (s = !0) : (s = !1), s
  }
  const [n, r] = w.useState([])
  if (
    (w.useEffect(() => {
      t() &&
        ed
          .get('/get-game-v2', { headers: G_ })
          .then((s) => {
            console.log('7s200:games', n), s.data.status === 200 && r(s.data.games)
          })
          .catch((s) => {
            s.response.status === 403 && localStorage.removeItem('token')
          })
    }, []),
    w.useEffect(() => {
      function s() {}
      function o() {}
      return (
        jn.on('connection', s),
        jn.on('disconnect', o),
        () => {
          jn.off('connection', s), jn.off('disconnect', o)
        }
      )
    }, []),
    !n)
  )
    return E.jsx(E.Fragment, { children: 'Loading...' })
  const i = async () => e({ Component: () => E.jsx(rQ, {}) })
  return E.jsxs(E.Fragment, {
    children: [
      E.jsx(gT, {}),
      E.jsx('div', {
        className: 'flex flex-col pt-4 bg-black h-screen',
        children: E.jsx('div', {
          className: 'border-none rounded-xl bg-gray-1000 min-h-screen',
          children: E.jsxs('div', {
            className:
              'mx-auto flex flex-col items-center justify-center text-center text-white px-6 py-12',
            children: [
              E.jsx('div', { children: E.jsx('h1', { children: 'Nguyen Le' }) }),
              E.jsxs('div', {
                className: 'flex flex-row',
                children: [
                  E.jsx('div', {
                    className: 'flex-auto p-4',
                    children: E.jsx('div', {
                      className: 'w-100 h-100 justify-center items-center',
                      children: E.jsx(cQ, { value: 60 }),
                    }),
                  }),
                  E.jsx('div', {
                    className: 'flex-auto p-4',
                    children: E.jsxs('div', {
                      children: [
                        E.jsx('div', { children: E.jsx('h3', { children: 'ELO RATING' }) }),
                        E.jsx('div', {
                          className: 'space-x-4 p-1',
                          children: E.jsx('button', {
                            className:
                              'bg-gray-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg',
                            onClick: () => i(),
                            children: 'Elo 1500',
                          }),
                        }),
                        E.jsx('div', {
                          className: 'space-x-4 p-1',
                          children: E.jsx('button', {
                            className:
                              'bg-gray-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg',
                            onClick: () => i(),
                            children: 'Elo 1500',
                          }),
                        }),
                        E.jsx('div', {
                          className: 'space-x-4 p-1',
                          children: E.jsx('button', {
                            className:
                              'bg-gray-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg',
                            onClick: () => i(),
                            children: 'Elo 1500',
                          }),
                        }),
                      ],
                    }),
                  }),
                ],
              }),
              E.jsxs('div', {
                className: 'flex flex-row',
                children: [
                  E.jsx('div', {
                    className: 'flex-auto p-4',
                    children: E.jsx('div', {
                      className: 'space-x-4',
                      children: E.jsx('button', {
                        className:
                          'bg-vanilla-100 text-black font-bold py-2 px-6 rounded-lg h-55 w-155',
                        onClick: () => i(),
                        children: 'Leaderboard',
                      }),
                    }),
                  }),
                  E.jsx('div', {
                    className: 'flex-auto p-4',
                    children: E.jsx('div', {
                      className: 'space-x-4',
                      children: E.jsx('button', {
                        className:
                          'bg-vanilla-100 text-black font-bold py-2 px-6 rounded-lg h-55 w-155',
                        onClick: () => i(),
                        children: 'Quest',
                      }),
                    }),
                  }),
                ],
              }),
              E.jsx('div', {
                children: E.jsx('h1', {
                  className: 'font-semibold text-3xl leading-6 mt-5',
                  children: 'Chess Mode',
                }),
              }),
              E.jsxs('div', {
                children: [
                  E.jsx('div', {
                    className: 'space-x-4',
                    children: E.jsx('button', {
                      className:
                        'bg-gray-900 hover:bg-gray-900 text-white font-bold py-2 px-6 rounded-lg m-5 h-100 w-342',
                      onClick: () => i(),
                      children: 'Play',
                    }),
                  }),
                  E.jsx('div', {
                    className: 'space-x-4',
                    children: E.jsx('button', {
                      className:
                        'bg-gray-900 hover:bg-gray-900 text-white font-bold py-2 px-6 rounded-lg m-5 h-100 w-342',
                      onClick: () => i(),
                      children: 'Play versus bot',
                    }),
                  }),
                  E.jsx('div', {
                    className: 'space-x-4',
                    children: E.jsx('button', {
                      className:
                        'bg-gray-900 hover:bg-gray-900 text-white font-bold py-2 px-6 rounded-lg m-5 h-100 w-342',
                      onClick: () => i(),
                      children: 'Puzzles',
                    }),
                  }),
                ],
              }),
            ],
          }),
        }),
      }),
    ],
  })
}
var ua = w.forwardRef(function (e, t) {
  var n = { fill: 'currentColor', xmlns: 'http://www.w3.org/2000/svg' }
  return w.createElement(
    UT,
    He({ iconAttrs: n, iconVerticalAlign: 'middle', iconViewBox: '0 0 320 512' }, e, { ref: t }),
    w.createElement('path', {
      fill: 'currentColor',
      d: 'M128 0c-17.7 0-32 14.3-32 32 0 16.1 11.9 29.4 27.4 31.7C78.4 106.8 8 190 8 288c0 47.4 30.8 72.3 56 84.7V416h192v-43.3c25.2-12.5 56-37.4 56-84.7 0-37.3-10.2-72.4-25.3-104.1l-99.4 99.4c-6.2 6.2-16.4 6.2-22.6 0s-6.2-16.4 0-22.6l106.1-106.1c-23.2-38.1-51.8-69.5-74.2-90.9C212.1 61.4 224 48.1 224 32c0-17.7-14.3-32-32-32h-64zM32 448c-17.7 0-32 14.3-32 32s14.3 32 32 32h256c17.7 0 32-14.3 32-32s-14.3-32-32-32H32z',
    })
  )
})
ua.displayName = 'ChessBishop'
const fQ = () =>
    E.jsx('div', {
      className:
        'relative items-center block w-[500px] h-[500px] p-6 bg-white border border-gray-100 rounded-lg shadow-md dark:bg-gray-800 dark:border-gray-800 dark:hover:bg-gray-700',
      children: E.jsxs('div', {
        role: 'status',
        className: 'absolute -translate-x-1/2 -translate-y-1/2 top-2/4 left-1/2',
        children: [
          E.jsxs('svg', {
            'aria-hidden': 'true',
            className: 'w-8 h-8 text-gray-200 animate-spin dark:text-gray-600 fill-blue-600',
            viewBox: '0 0 100 101',
            fill: 'none',
            xmlns: 'http://www.w3.org/2000/svg',
            children: [
              E.jsx('path', {
                d: 'M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z',
                fill: 'currentColor',
              }),
              E.jsx('path', {
                d: 'M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z',
                fill: 'currentFill',
              }),
            ],
          }),
          E.jsx('span', { className: 'sr-only', children: 'Loading...' }),
        ],
      }),
    }),
  dQ = () => {
    const e = cg(),
      [t, n] = w.useState(!0),
      [r, i] = w.useState(),
      [s, o] = w.useState(null),
      [a, l] = w.useState(''),
      [c, u] = w.useState(''),
      [f, d] = w.useState(''),
      [p, h] = w.useState(''),
      [m, b] = w.useState({}),
      [y, v] = w.useState(!1),
      [S, T] = w.useState({}),
      [A, I] = w.useState({})
    w.useState(new Ad().isGameOver()), w.useState(new Ad().isDraw())
    const [k, D] = w.useState(!1),
      [F, V] = w.useState(!1),
      [ie, de] = w.useState(!1)
    $0()
    const xe = L0()
    w.useEffect(() => {
      ed.get('/load-game-v2', { params: { game_id: xe.pathname.split('/')[2] } })
        .then(async (fe) => {
          if (fe.status === 200) {
            const _e = fe.data.game
            i(new Ad(_e.fen)),
              o(_e),
              l(_e.player_1),
              u(_e.player_2),
              de(_e.turnPlay),
              _e.player_1.length > 0 && _e.player_2.length > 0 && n(!0)
          }
        })
        .catch((fe) => {})
    }),
      w.useEffect(() => {
        function fe() {
          D(!0)
        }
        function _e(Z) {
          Z.fen && (i(new Ad(Z.fen)), de(Z.turn))
        }
        function re(Z) {
          Z.start === !0 && n(!0)
        }
        return (
          jn.connect(),
          jn.on('connection', fe),
          jn.on('newMove', _e),
          jn.on('start', re),
          jn.emit('joinGame', { game_id: xe.pathname.split('/')[2] }),
          () => {
            jn.off('connection', fe), jn.off('newmove', _e), jn.off('start', re)
          }
        )
      }, [])
    function we(fe) {
      const _e = r.moves({ square: fe, verbose: !0 })
      if (_e.length === 0) return T({}), !1
      const re = {}
      return (
        _e.map(
          (Z) => (
            (re[Z.to] = {
              background:
                r.get(Z.to) && r.get(Z.to).color !== r.get(fe).color
                  ? 'radial-gradient(circle, rgba(0,0,0,.1) 85%, transparent 85%)'
                  : 'radial-gradient(circle, rgba(0,0,0,.1) 25%, transparent 25%)',
              borderRadius: '50%',
            }),
            Z
          )
        ),
        (re[fe] = re[fe] = { background: 'rgba(255, 255, 0, 0.4)' }),
        T(re),
        !0
      )
    }
    function Pe(fe) {
      if ((b({}), !p)) {
        if (!f) {
          we(fe) && d(fe)
          return
        }
        const re = r.moves({ square: f, verbose: !0 }).find((wt) => wt.from === f && wt.to === fe)
        if (!re) {
          const wt = we(fe)
          d(wt ? fe : '')
          return
        }
        if (
          (h(fe),
          (re.color === 'w' && re.piece === 'p' && fe[1] === '8') ||
            (re.color === 'b' && re.piece === 'p' && fe[1] === '1'))
        ) {
          v(!0)
          return
        }
        let Z = r
        const it = Z.move({ from: f, to: fe, promation: 'q' })
        if (
          (jn.emit('move', {
            from: f,
            to: fe,
            game_id: xe.pathname.split('/')[2],
            turn: r.turn(),
            address: '',
            fen: r.fen(),
            isPromotion:
              (re.color === 'w' && re.piece === 'p' && fe[1] === '8') ||
              (re.color === 'b' && re.piece === 'p' && fe[1] === '1'),
          }),
          console.log(xe.pathname.split('/')[2]),
          it === null)
        ) {
          we(fe) && d(fe)
          return
        }
        i(Z), d(''), h(null), T({})
        return
      }
    }
    function We(fe) {
      if (fe) {
        let _e = r
        console.log(r)
        const re = _e.move({ from: f, to: p, promotion: fe[1].toLowerCase() ?? 'q' })
        console.log('7s200:pro', { promotion: fe[1].toLowerCase() ?? 'q' }),
          re &&
            (i(_e),
            jn.emit('move', {
              from: f,
              to: p,
              game_id: xe.pathname.split('/')[2],
              turn: r.turn(),
              address: '',
              fen: r.fen(),
              isPromotion: !0,
              promotion: fe[1].toLowerCase() ?? 'q',
            }))
      }
      return d(''), h(null), v(!1), T({}), !0
    }
    function Me(fe) {
      const _e = 'rgba(0, 0, 255, 0.4)'
      b({ ...m, [fe]: m[fe] && m[fe].backgroundColor === _e ? void 0 : { backgroundColor: _e } })
    }
    const K = () =>
        (e == null ? void 0 : e.address) !== a && (e == null ? void 0 : e.address) !== c
          ? E.jsx('div', {
              className: 'px-4 py-2 bg-[#baca44] w-2/3 border border-none rounded-xl shadow-xl',
              children: E.jsxs('div', {
                className: 'flex justify-center items-center space-x-2',
                children: [
                  E.jsx(ua, { color: 'white', size: 26 }),
                  E.jsx('p', {
                    className: 'font-bold text-[14px]',
                    children: s.player_2 === '' ? 'Waiting player...' : hs(s.player_2),
                  }),
                ],
              }),
            })
          : (e == null ? void 0 : e.address) === c
          ? E.jsx('div', {
              className: 'px-4 py-2 bg-[#baca44] w-2/3 border border-none rounded-xl shadow-xl',
              children: E.jsxs('div', {
                className: 'flex justify-center items-center space-x-2',
                children: [
                  E.jsx(ua, { color: 'white', size: 26 }),
                  E.jsx('p', { className: 'font-bold text-[14px]', children: hs(a) }),
                ],
              }),
            })
          : E.jsx('div', {
              className: 'px-4 py-2 bg-[#baca44] w-2/3 border border-none rounded-xl shadow-xl',
              children: E.jsxs('div', {
                className: 'flex justify-center items-center space-x-2',
                children: [
                  E.jsx(ua, { color: 'white', size: 26 }),
                  E.jsx('p', { className: 'font-bold text-[14px]', children: hs(c) }),
                ],
              }),
            }),
      H = () =>
        (e == null ? void 0 : e.address) !== a && (e == null ? void 0 : e.address) !== c
          ? E.jsx('div', {
              className: 'px-4 py-2 bg-[#baca44] w-2/3 border border-none rounded-xl shadow-xl',
              children: E.jsxs('div', {
                className: 'flex justify-center items-center space-x-2',
                children: [
                  E.jsx(ua, { color: 'white', size: 26 }),
                  E.jsx('p', { className: 'font-bold text-[14px]', children: hs(s.player_1) }),
                ],
              }),
            })
          : (e == null ? void 0 : e.address) === a
          ? E.jsx('div', {
              className: 'px-4 py-2 bg-[#baca44] w-2/3 border border-none rounded-xl shadow-xl',
              children: E.jsxs('div', {
                className: 'flex justify-center items-center space-x-2',
                children: [
                  E.jsx(ua, { color: 'white', size: 26 }),
                  E.jsx('p', { className: 'font-bold text-[14px]', children: hs(a) }),
                ],
              }),
            })
          : E.jsx('div', {
              className: 'px-4 py-2 bg-[#baca44] w-2/3 border border-none rounded-xl shadow-xl',
              children: E.jsxs('div', {
                className: 'flex justify-center items-center space-x-2',
                children: [
                  E.jsx(ua, { color: 'white', size: 26 }),
                  E.jsx('p', { className: 'font-bold text-[14px]', children: hs(c) }),
                ],
              }),
            }),
      oe = () =>
        t
          ? E.jsx(E.Fragment, {})
          : E.jsx('div', {
              className:
                'absolute top-1/3 left-[50px] w-[400px] bg-white border boder-none rounded-xl',
              children: E.jsx('div', {
                className: 'flex flex-col space-y-4 justify-center items-center h-[150px]',
                children: E.jsx('div', {
                  className: 'font-bold',
                  children: 'Waiting player join the game...',
                }),
              }),
            }),
      Ae = () => ((e == null ? void 0 : e.address) === a ? 'white' : 'black'),
      Ie = () =>
        E.jsx('div', {
          className: 'relative',
          style: { height: '500px', width: '500px', cursor: 'pointer' },
          children: E.jsxs('div', {
            className: 'flex flex-col space-y-4',
            children: [
              K(),
              E.jsxs('div', {
                className: 'relative',
                children: [
                  E.jsx(kN, {
                    boardOrientation: Ae(),
                    position: r.fen(),
                    id: 'ClickToMove',
                    animationDuration: 200,
                    arePiecesDraggable: !1,
                    onSquareClick: Pe,
                    onSquareRightClick: Me,
                    onPromotionPieceSelect: We,
                    customBoardStyle: {
                      borderRadius: '4px',
                      boxShadow: '0 2px 10px rgba(0, 0, 0, 0.5)',
                    },
                    customSquareStyles: { ...A, ...S, ...m },
                    promotionToSquare: p,
                    showPromotionDialog: y,
                  }),
                  (r.isGameOver() || r.isDraw()) &&
                    E.jsx('div', {
                      className: `absolute top-1/3 left-[50px] w-[400px] ${F && 'hidden'}`,
                      onClick: () => V(!0),
                      children: E.jsx(VT, {
                        className: 'bg-gray-50 w-[400px]',
                        children: E.jsxs('h1', {
                          className: 'mb-4 text-center font-bold text-[20px]',
                          children: [
                            r.isGameOver() &&
                              E.jsx('div', { children: r.turn() === 'b' ? hs(a) : hs(c) }),
                            r.isDraw() && E.jsx('div', { children: 'Draw' }),
                          ],
                        }),
                      }),
                    }),
                  oe(),
                ],
              }),
              H(),
            ],
          }),
        })
    return !r || !s
      ? E.jsx(fQ, {})
      : E.jsxs(E.Fragment, {
          children: [
            E.jsx(gT, {}),
            E.jsx('div', {
              className: 'flex p-8 md:ml-64 mt-14 bg-gray-100 h-screen',
              children: Ie(),
            }),
          ],
        })
  }
const hQ = {
    testnet: { url: 'https://fullnode.testnet.sui.io:443' },
    mainnet: { url: 'https://fullnode.mainnet.sui.io:443' },
  },
  pQ = new n7(),
  gQ = pI([
    {
      element: E.jsx(Q_, { children: E.jsx(uI, {}) }),
      children: [
        { path: '/', element: E.jsx(uQ, {}) },
        { path: '/game/:id', element: E.jsx(dQ, {}) },
      ],
    },
  ]),
  mQ = qm.createRoot(document.getElementById('root'))
mQ.render(
  E.jsx(fn.StrictMode, {
    children: E.jsx(QR, {
      store: eG,
      children: E.jsx(a7, {
        client: pQ,
        children: E.jsx(cq, {
          networks: hQ,
          children: E.jsx(Vq, { children: E.jsx(Q_, { children: E.jsx(EI, { router: gQ }) }) }),
        }),
      }),
    }),
  })
)
